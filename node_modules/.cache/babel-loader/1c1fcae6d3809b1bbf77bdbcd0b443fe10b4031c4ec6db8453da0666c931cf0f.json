{"ast":null,"code":"import { useEffect, useRef } from 'react';\nimport { MISSING_DOC } from 'pouchdb-errors';\nimport { useContext } from './context';\nimport useStateMachine from './state-machine';\nimport { useDeepMemo } from './utils';\n/**\n * Query a view and subscribe to its updates.\n * @param {string | function | object} fun The name of the view or a temporary view.\n * @param {object} [opts] PouchDB's query-options\n */\nexport default function useView(fun, opts) {\n  const {\n    pouchdb: pouch,\n    subscriptionManager\n  } = useContext(opts === null || opts === void 0 ? void 0 : opts.db);\n  if (typeof (pouch === null || pouch === void 0 ? void 0 : pouch.query) !== 'function') {\n    throw new TypeError('db.query() is not defined. Please install \"pouchdb-mapreduce\"');\n  }\n  const lastView = useRef(null);\n  const {\n    reduce,\n    include_docs,\n    conflicts,\n    attachments,\n    binary,\n    inclusive_end,\n    limit,\n    skip,\n    descending,\n    group,\n    group_level,\n    update_seq,\n    stale\n  } = opts || {};\n  const startkey = useDeepMemo(opts === null || opts === void 0 ? void 0 : opts.startkey);\n  const endkey = useDeepMemo(opts === null || opts === void 0 ? void 0 : opts.endkey);\n  const key = useDeepMemo(opts === null || opts === void 0 ? void 0 : opts.key);\n  const keys = useDeepMemo(opts === null || opts === void 0 ? void 0 : opts.keys);\n  const [state, dispatch] = useStateMachine(() => ({\n    rows: [],\n    total_rows: 0,\n    offset: 0\n  }));\n  useEffect(() => {\n    const options = {\n      reduce,\n      include_docs,\n      conflicts,\n      attachments,\n      binary,\n      inclusive_end,\n      limit,\n      skip,\n      descending,\n      group,\n      group_level,\n      update_seq,\n      startkey,\n      endkey,\n      key,\n      keys,\n      // only add the stale option if the view is not the same as last request.\n      // Because the view is already upto date.\n      stale: lastView.current === fun ? undefined : stale\n    };\n    if (typeof fun === 'string') {\n      lastView.current = fun;\n      return doDDocQuery(dispatch, pouch, subscriptionManager, fun, options);\n    } else {\n      return doTemporaryQuery(dispatch, pouch, subscriptionManager, fun, options);\n    }\n  }, [dispatch, pouch, subscriptionManager, fun, reduce, include_docs, conflicts, attachments, binary, startkey, endkey, inclusive_end, limit, skip, descending, key, keys, group, group_level, update_seq, stale]);\n  return state;\n}\n/**\n * Query and subscribe to updates of a view in a ddoc.\n * @param setResult setState for the result.\n * @param setState setState for state.\n * @param setError setState to set the error.\n * @param pouch The pouch db.\n * @param fn Name of the view.\n * @param option PouchDB's query options.\n */\nfunction doDDocQuery(dispatch, pouch, subscriptionManager, fn, option) {\n  let isMounted = true;\n  let isFetching = false; // A query is underway.\n  let shouldUpdateAfter = false; // A relevant update did happen while fetching.\n  let isReduce = Boolean(option === null || option === void 0 ? void 0 : option.reduce);\n  let unsubscribeFromDocs = null;\n  let lastResultIds = new Set();\n  const id = '_design/' + fn.split('/')[0];\n  // Subscribe to updates of documents that where returned in the last query,\n  // and the design doc.\n  // It subscribes to the result docs, to be notified of deletions and other updates of docs\n  // which removes them from the view.\n  const createDocSubscription = ids => {\n    if (unsubscribeFromDocs != null) {\n      unsubscribeFromDocs();\n    }\n    unsubscribeFromDocs = subscriptionManager.subscribeToDocs(\n    // when reduce listen to all doc changes. Because reduce doesn't have ids in the result.\n    isReduce ? null : ids, (deleted, docId) => {\n      if (!isMounted) return;\n      if (docId === id && deleted) {\n        dispatch({\n          type: 'loading_error',\n          payload: {\n            error: MISSING_DOC,\n            setResult: true,\n            result: {\n              rows: [],\n              total_rows: 0,\n              offset: 0\n            }\n          }\n        });\n      } else {\n        query();\n      }\n    });\n  };\n  // Does the query.\n  // It updates the state only if this function is still active.\n  const query = async () => {\n    if (isFetching) {\n      shouldUpdateAfter = true;\n      return;\n    }\n    isFetching = true;\n    shouldUpdateAfter = false;\n    dispatch({\n      type: 'loading_started'\n    });\n    try {\n      const result = await pouch.query(fn, option);\n      if (!isMounted) return;\n      dispatch({\n        type: 'loading_finished',\n        payload: result\n      });\n      const ids = new Set();\n      for (const row of result.rows) {\n        if (row.id != null) {\n          ids.add(row.id);\n        }\n      }\n      lastResultIds = ids;\n      // Reduce doesn't return ids. Only keys and values.\n      // Checked because the reduce option defaults to true.\n      const isThisReduced = ids.size === 0 && result.rows.length > 0;\n      if (!isReduce || isReduce !== isThisReduced) {\n        isReduce = isThisReduced;\n        ids.add(id);\n        createDocSubscription(Array.from(ids));\n      }\n    } catch (error) {\n      if (isMounted) {\n        dispatch({\n          type: 'loading_error',\n          payload: {\n            error: error,\n            setResult: false\n          }\n        });\n      }\n    } finally {\n      if (isMounted) {\n        // refresh if change did happen while querying\n        isFetching = false;\n        if (option === null || option === void 0 ? void 0 : option.stale) {\n          // future queries shouldn't be stale\n          delete option.stale;\n          query();\n        } else if (shouldUpdateAfter) {\n          query();\n        }\n      }\n    }\n  };\n  query();\n  createDocSubscription([id]);\n  // Subscribe to new entries in the view.\n  const unsubscribe = subscriptionManager.subscribeToView(fn, id => {\n    if (isMounted && !isReduce && !lastResultIds.has(id)) {\n      query();\n    }\n  });\n  return () => {\n    isMounted = false;\n    unsubscribe();\n    if (unsubscribeFromDocs) {\n      unsubscribeFromDocs();\n    }\n  };\n}\n/**\n * Query and subscribe to updates of a temporary view (function or object with map function).\n * @param setResult setState for the result.\n * @param setState setState for state.\n * @param setError setState to set the error.\n * @param pouch The pouch db.\n * @param fn The temporary view.\n * @param option PouchDB's query options.\n */\nfunction doTemporaryQuery(dispatch, pouch, subscriptionManager, fn, option) {\n  let isMounted = true;\n  let isFetching = false; // A query is underway.\n  let shouldUpdateAfter = false; // A relevant update did happen while fetching.\n  const isReduce = typeof (option === null || option === void 0 ? void 0 : option.reduce) === 'string' || (option === null || option === void 0 ? void 0 : option.reduce) !== false && typeof fn === 'object' && Boolean(fn.reduce);\n  let resultIds = null;\n  // Does the query.\n  // It updates the state only if this function is still active.\n  const query = async () => {\n    if (isFetching) {\n      shouldUpdateAfter = true;\n      return;\n    }\n    isFetching = true;\n    shouldUpdateAfter = false;\n    dispatch({\n      type: 'loading_started'\n    });\n    try {\n      const result = await pouch.query(fn, option);\n      if (!isMounted) return;\n      dispatch({\n        type: 'loading_finished',\n        payload: result\n      });\n      const ids = new Set();\n      for (const row of result.rows) {\n        if (row.id != null) {\n          ids.add(row.id);\n        }\n      }\n      if (ids.size === 0) {\n        resultIds = null;\n      } else {\n        resultIds = ids;\n      }\n    } catch (error) {\n      if (isMounted) {\n        dispatch({\n          type: 'loading_error',\n          payload: {\n            error: error,\n            setResult: false\n          }\n        });\n      }\n    } finally {\n      // refresh if change did happen while querying\n      isFetching = false;\n      if (shouldUpdateAfter && isMounted) {\n        query();\n      }\n    }\n  };\n  query();\n  let viewFunction;\n  if (typeof fn === 'function') {\n    viewFunction = fn;\n  } else if (typeof fn === 'object' && typeof fn.map === 'function') {\n    viewFunction = fn.map;\n  }\n  // Subscribe to updates of the view.\n  const unsubscribe = subscriptionManager.subscribeToDocs(null, (_deleted, id, doc) => {\n    if (isReduce) {\n      query();\n      return;\n    }\n    try {\n      let isDocInView = false;\n      if (doc) {\n        viewFunction(doc, () => {\n          isDocInView = true;\n        });\n      }\n      // Also check if one of the result documents did update in a way,\n      // that removes it from the view.\n      if (isDocInView || (resultIds === null || resultIds === void 0 ? void 0 : resultIds.has(id))) {\n        query();\n      }\n    } catch (err) {\n      console.error(err);\n    }\n  });\n  return () => {\n    isMounted = false;\n    unsubscribe();\n  };\n}","map":{"version":3,"names":["useEffect","useRef","MISSING_DOC","useContext","useStateMachine","useDeepMemo","useView","fun","opts","pouchdb","pouch","subscriptionManager","db","query","TypeError","lastView","reduce","include_docs","conflicts","attachments","binary","inclusive_end","limit","skip","descending","group","group_level","update_seq","stale","startkey","endkey","key","keys","state","dispatch","rows","total_rows","offset","options","current","undefined","doDDocQuery","doTemporaryQuery","fn","option","isMounted","isFetching","shouldUpdateAfter","isReduce","Boolean","unsubscribeFromDocs","lastResultIds","Set","id","split","createDocSubscription","ids","subscribeToDocs","deleted","docId","type","payload","error","setResult","result","row","add","isThisReduced","size","length","Array","from","unsubscribe","subscribeToView","has","resultIds","viewFunction","map","_deleted","doc","isDocInView","err","console"],"sources":["/home/sol/Documentos/AUS/3ro segundo cuatri/ing 2/URV/node_modules/use-pouchdb/lib/useView.js"],"sourcesContent":["import { useEffect, useRef } from 'react';\nimport { MISSING_DOC } from 'pouchdb-errors';\nimport { useContext } from './context';\nimport useStateMachine from './state-machine';\nimport { useDeepMemo } from './utils';\n/**\n * Query a view and subscribe to its updates.\n * @param {string | function | object} fun The name of the view or a temporary view.\n * @param {object} [opts] PouchDB's query-options\n */\nexport default function useView(fun, opts) {\n    const { pouchdb: pouch, subscriptionManager } = useContext(opts === null || opts === void 0 ? void 0 : opts.db);\n    if (typeof (pouch === null || pouch === void 0 ? void 0 : pouch.query) !== 'function') {\n        throw new TypeError('db.query() is not defined. Please install \"pouchdb-mapreduce\"');\n    }\n    const lastView = useRef(null);\n    const { reduce, include_docs, conflicts, attachments, binary, inclusive_end, limit, skip, descending, group, group_level, update_seq, stale, } = opts || {};\n    const startkey = useDeepMemo(opts === null || opts === void 0 ? void 0 : opts.startkey);\n    const endkey = useDeepMemo(opts === null || opts === void 0 ? void 0 : opts.endkey);\n    const key = useDeepMemo(opts === null || opts === void 0 ? void 0 : opts.key);\n    const keys = useDeepMemo(opts === null || opts === void 0 ? void 0 : opts.keys);\n    const [state, dispatch] = useStateMachine(() => ({\n        rows: [],\n        total_rows: 0,\n        offset: 0,\n    }));\n    useEffect(() => {\n        const options = {\n            reduce,\n            include_docs,\n            conflicts,\n            attachments,\n            binary,\n            inclusive_end,\n            limit,\n            skip,\n            descending,\n            group,\n            group_level,\n            update_seq,\n            startkey,\n            endkey,\n            key,\n            keys,\n            // only add the stale option if the view is not the same as last request.\n            // Because the view is already upto date.\n            stale: lastView.current === fun ? undefined : stale,\n        };\n        if (typeof fun === 'string') {\n            lastView.current = fun;\n            return doDDocQuery(dispatch, pouch, subscriptionManager, fun, options);\n        }\n        else {\n            return doTemporaryQuery(dispatch, pouch, subscriptionManager, fun, options);\n        }\n    }, [\n        dispatch,\n        pouch,\n        subscriptionManager,\n        fun,\n        reduce,\n        include_docs,\n        conflicts,\n        attachments,\n        binary,\n        startkey,\n        endkey,\n        inclusive_end,\n        limit,\n        skip,\n        descending,\n        key,\n        keys,\n        group,\n        group_level,\n        update_seq,\n        stale,\n    ]);\n    return state;\n}\n/**\n * Query and subscribe to updates of a view in a ddoc.\n * @param setResult setState for the result.\n * @param setState setState for state.\n * @param setError setState to set the error.\n * @param pouch The pouch db.\n * @param fn Name of the view.\n * @param option PouchDB's query options.\n */\nfunction doDDocQuery(dispatch, pouch, subscriptionManager, fn, option) {\n    let isMounted = true;\n    let isFetching = false; // A query is underway.\n    let shouldUpdateAfter = false; // A relevant update did happen while fetching.\n    let isReduce = Boolean(option === null || option === void 0 ? void 0 : option.reduce);\n    let unsubscribeFromDocs = null;\n    let lastResultIds = new Set();\n    const id = '_design/' + fn.split('/')[0];\n    // Subscribe to updates of documents that where returned in the last query,\n    // and the design doc.\n    // It subscribes to the result docs, to be notified of deletions and other updates of docs\n    // which removes them from the view.\n    const createDocSubscription = (ids) => {\n        if (unsubscribeFromDocs != null) {\n            unsubscribeFromDocs();\n        }\n        unsubscribeFromDocs = subscriptionManager.subscribeToDocs(\n        // when reduce listen to all doc changes. Because reduce doesn't have ids in the result.\n        isReduce ? null : ids, (deleted, docId) => {\n            if (!isMounted)\n                return;\n            if (docId === id && deleted) {\n                dispatch({\n                    type: 'loading_error',\n                    payload: {\n                        error: MISSING_DOC,\n                        setResult: true,\n                        result: {\n                            rows: [],\n                            total_rows: 0,\n                            offset: 0,\n                        },\n                    },\n                });\n            }\n            else {\n                query();\n            }\n        });\n    };\n    // Does the query.\n    // It updates the state only if this function is still active.\n    const query = async () => {\n        if (isFetching) {\n            shouldUpdateAfter = true;\n            return;\n        }\n        isFetching = true;\n        shouldUpdateAfter = false;\n        dispatch({ type: 'loading_started' });\n        try {\n            const result = await pouch.query(fn, option);\n            if (!isMounted)\n                return;\n            dispatch({\n                type: 'loading_finished',\n                payload: result,\n            });\n            const ids = new Set();\n            for (const row of result.rows) {\n                if (row.id != null) {\n                    ids.add(row.id);\n                }\n            }\n            lastResultIds = ids;\n            // Reduce doesn't return ids. Only keys and values.\n            // Checked because the reduce option defaults to true.\n            const isThisReduced = ids.size === 0 && result.rows.length > 0;\n            if (!isReduce || isReduce !== isThisReduced) {\n                isReduce = isThisReduced;\n                ids.add(id);\n                createDocSubscription(Array.from(ids));\n            }\n        }\n        catch (error) {\n            if (isMounted) {\n                dispatch({\n                    type: 'loading_error',\n                    payload: {\n                        error: error,\n                        setResult: false,\n                    },\n                });\n            }\n        }\n        finally {\n            if (isMounted) {\n                // refresh if change did happen while querying\n                isFetching = false;\n                if (option === null || option === void 0 ? void 0 : option.stale) {\n                    // future queries shouldn't be stale\n                    delete option.stale;\n                    query();\n                }\n                else if (shouldUpdateAfter) {\n                    query();\n                }\n            }\n        }\n    };\n    query();\n    createDocSubscription([id]);\n    // Subscribe to new entries in the view.\n    const unsubscribe = subscriptionManager.subscribeToView(fn, id => {\n        if (isMounted && !isReduce && !lastResultIds.has(id)) {\n            query();\n        }\n    });\n    return () => {\n        isMounted = false;\n        unsubscribe();\n        if (unsubscribeFromDocs) {\n            unsubscribeFromDocs();\n        }\n    };\n}\n/**\n * Query and subscribe to updates of a temporary view (function or object with map function).\n * @param setResult setState for the result.\n * @param setState setState for state.\n * @param setError setState to set the error.\n * @param pouch The pouch db.\n * @param fn The temporary view.\n * @param option PouchDB's query options.\n */\nfunction doTemporaryQuery(dispatch, pouch, subscriptionManager, fn, option) {\n    let isMounted = true;\n    let isFetching = false; // A query is underway.\n    let shouldUpdateAfter = false; // A relevant update did happen while fetching.\n    const isReduce = typeof (option === null || option === void 0 ? void 0 : option.reduce) === 'string' ||\n        ((option === null || option === void 0 ? void 0 : option.reduce) !== false && typeof fn === 'object' && Boolean(fn.reduce));\n    let resultIds = null;\n    // Does the query.\n    // It updates the state only if this function is still active.\n    const query = async () => {\n        if (isFetching) {\n            shouldUpdateAfter = true;\n            return;\n        }\n        isFetching = true;\n        shouldUpdateAfter = false;\n        dispatch({ type: 'loading_started' });\n        try {\n            const result = await pouch.query(fn, option);\n            if (!isMounted)\n                return;\n            dispatch({\n                type: 'loading_finished',\n                payload: result,\n            });\n            const ids = new Set();\n            for (const row of result.rows) {\n                if (row.id != null) {\n                    ids.add(row.id);\n                }\n            }\n            if (ids.size === 0) {\n                resultIds = null;\n            }\n            else {\n                resultIds = ids;\n            }\n        }\n        catch (error) {\n            if (isMounted) {\n                dispatch({\n                    type: 'loading_error',\n                    payload: {\n                        error: error,\n                        setResult: false,\n                    },\n                });\n            }\n        }\n        finally {\n            // refresh if change did happen while querying\n            isFetching = false;\n            if (shouldUpdateAfter && isMounted) {\n                query();\n            }\n        }\n    };\n    query();\n    let viewFunction;\n    if (typeof fn === 'function') {\n        viewFunction = fn;\n    }\n    else if (typeof fn === 'object' && typeof fn.map === 'function') {\n        viewFunction = fn.map;\n    }\n    // Subscribe to updates of the view.\n    const unsubscribe = subscriptionManager.subscribeToDocs(null, (_deleted, id, doc) => {\n        if (isReduce) {\n            query();\n            return;\n        }\n        try {\n            let isDocInView = false;\n            if (doc) {\n                viewFunction(doc, () => {\n                    isDocInView = true;\n                });\n            }\n            // Also check if one of the result documents did update in a way,\n            // that removes it from the view.\n            if (isDocInView || (resultIds === null || resultIds === void 0 ? void 0 : resultIds.has(id))) {\n                query();\n            }\n        }\n        catch (err) {\n            console.error(err);\n        }\n    });\n    return () => {\n        isMounted = false;\n        unsubscribe();\n    };\n}\n"],"mappings":"AAAA,SAASA,SAAS,EAAEC,MAAM,QAAQ,OAAO;AACzC,SAASC,WAAW,QAAQ,gBAAgB;AAC5C,SAASC,UAAU,QAAQ,WAAW;AACtC,OAAOC,eAAe,MAAM,iBAAiB;AAC7C,SAASC,WAAW,QAAQ,SAAS;AACrC;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,OAAO,CAACC,GAAG,EAAEC,IAAI,EAAE;EACvC,MAAM;IAAEC,OAAO,EAAEC,KAAK;IAAEC;EAAoB,CAAC,GAAGR,UAAU,CAACK,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,IAAI,CAACI,EAAE,CAAC;EAC/G,IAAI,QAAQF,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,KAAK,CAACG,KAAK,CAAC,KAAK,UAAU,EAAE;IACnF,MAAM,IAAIC,SAAS,CAAC,+DAA+D,CAAC;EACxF;EACA,MAAMC,QAAQ,GAAGd,MAAM,CAAC,IAAI,CAAC;EAC7B,MAAM;IAAEe,MAAM;IAAEC,YAAY;IAAEC,SAAS;IAAEC,WAAW;IAAEC,MAAM;IAAEC,aAAa;IAAEC,KAAK;IAAEC,IAAI;IAAEC,UAAU;IAAEC,KAAK;IAAEC,WAAW;IAAEC,UAAU;IAAEC;EAAO,CAAC,GAAGpB,IAAI,IAAI,CAAC,CAAC;EAC3J,MAAMqB,QAAQ,GAAGxB,WAAW,CAACG,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,IAAI,CAACqB,QAAQ,CAAC;EACvF,MAAMC,MAAM,GAAGzB,WAAW,CAACG,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,IAAI,CAACsB,MAAM,CAAC;EACnF,MAAMC,GAAG,GAAG1B,WAAW,CAACG,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,IAAI,CAACuB,GAAG,CAAC;EAC7E,MAAMC,IAAI,GAAG3B,WAAW,CAACG,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,IAAI,CAACwB,IAAI,CAAC;EAC/E,MAAM,CAACC,KAAK,EAAEC,QAAQ,CAAC,GAAG9B,eAAe,CAAC,OAAO;IAC7C+B,IAAI,EAAE,EAAE;IACRC,UAAU,EAAE,CAAC;IACbC,MAAM,EAAE;EACZ,CAAC,CAAC,CAAC;EACHrC,SAAS,CAAC,MAAM;IACZ,MAAMsC,OAAO,GAAG;MACZtB,MAAM;MACNC,YAAY;MACZC,SAAS;MACTC,WAAW;MACXC,MAAM;MACNC,aAAa;MACbC,KAAK;MACLC,IAAI;MACJC,UAAU;MACVC,KAAK;MACLC,WAAW;MACXC,UAAU;MACVE,QAAQ;MACRC,MAAM;MACNC,GAAG;MACHC,IAAI;MACJ;MACA;MACAJ,KAAK,EAAEb,QAAQ,CAACwB,OAAO,KAAKhC,GAAG,GAAGiC,SAAS,GAAGZ;IAClD,CAAC;IACD,IAAI,OAAOrB,GAAG,KAAK,QAAQ,EAAE;MACzBQ,QAAQ,CAACwB,OAAO,GAAGhC,GAAG;MACtB,OAAOkC,WAAW,CAACP,QAAQ,EAAExB,KAAK,EAAEC,mBAAmB,EAAEJ,GAAG,EAAE+B,OAAO,CAAC;IAC1E,CAAC,MACI;MACD,OAAOI,gBAAgB,CAACR,QAAQ,EAAExB,KAAK,EAAEC,mBAAmB,EAAEJ,GAAG,EAAE+B,OAAO,CAAC;IAC/E;EACJ,CAAC,EAAE,CACCJ,QAAQ,EACRxB,KAAK,EACLC,mBAAmB,EACnBJ,GAAG,EACHS,MAAM,EACNC,YAAY,EACZC,SAAS,EACTC,WAAW,EACXC,MAAM,EACNS,QAAQ,EACRC,MAAM,EACNT,aAAa,EACbC,KAAK,EACLC,IAAI,EACJC,UAAU,EACVO,GAAG,EACHC,IAAI,EACJP,KAAK,EACLC,WAAW,EACXC,UAAU,EACVC,KAAK,CACR,CAAC;EACF,OAAOK,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASQ,WAAW,CAACP,QAAQ,EAAExB,KAAK,EAAEC,mBAAmB,EAAEgC,EAAE,EAAEC,MAAM,EAAE;EACnE,IAAIC,SAAS,GAAG,IAAI;EACpB,IAAIC,UAAU,GAAG,KAAK,CAAC,CAAC;EACxB,IAAIC,iBAAiB,GAAG,KAAK,CAAC,CAAC;EAC/B,IAAIC,QAAQ,GAAGC,OAAO,CAACL,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,MAAM,CAAC5B,MAAM,CAAC;EACrF,IAAIkC,mBAAmB,GAAG,IAAI;EAC9B,IAAIC,aAAa,GAAG,IAAIC,GAAG,EAAE;EAC7B,MAAMC,EAAE,GAAG,UAAU,GAAGV,EAAE,CAACW,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;EACxC;EACA;EACA;EACA;EACA,MAAMC,qBAAqB,GAAIC,GAAG,IAAK;IACnC,IAAIN,mBAAmB,IAAI,IAAI,EAAE;MAC7BA,mBAAmB,EAAE;IACzB;IACAA,mBAAmB,GAAGvC,mBAAmB,CAAC8C,eAAe;IACzD;IACAT,QAAQ,GAAG,IAAI,GAAGQ,GAAG,EAAE,CAACE,OAAO,EAAEC,KAAK,KAAK;MACvC,IAAI,CAACd,SAAS,EACV;MACJ,IAAIc,KAAK,KAAKN,EAAE,IAAIK,OAAO,EAAE;QACzBxB,QAAQ,CAAC;UACL0B,IAAI,EAAE,eAAe;UACrBC,OAAO,EAAE;YACLC,KAAK,EAAE5D,WAAW;YAClB6D,SAAS,EAAE,IAAI;YACfC,MAAM,EAAE;cACJ7B,IAAI,EAAE,EAAE;cACRC,UAAU,EAAE,CAAC;cACbC,MAAM,EAAE;YACZ;UACJ;QACJ,CAAC,CAAC;MACN,CAAC,MACI;QACDxB,KAAK,EAAE;MACX;IACJ,CAAC,CAAC;EACN,CAAC;EACD;EACA;EACA,MAAMA,KAAK,GAAG,YAAY;IACtB,IAAIiC,UAAU,EAAE;MACZC,iBAAiB,GAAG,IAAI;MACxB;IACJ;IACAD,UAAU,GAAG,IAAI;IACjBC,iBAAiB,GAAG,KAAK;IACzBb,QAAQ,CAAC;MAAE0B,IAAI,EAAE;IAAkB,CAAC,CAAC;IACrC,IAAI;MACA,MAAMI,MAAM,GAAG,MAAMtD,KAAK,CAACG,KAAK,CAAC8B,EAAE,EAAEC,MAAM,CAAC;MAC5C,IAAI,CAACC,SAAS,EACV;MACJX,QAAQ,CAAC;QACL0B,IAAI,EAAE,kBAAkB;QACxBC,OAAO,EAAEG;MACb,CAAC,CAAC;MACF,MAAMR,GAAG,GAAG,IAAIJ,GAAG,EAAE;MACrB,KAAK,MAAMa,GAAG,IAAID,MAAM,CAAC7B,IAAI,EAAE;QAC3B,IAAI8B,GAAG,CAACZ,EAAE,IAAI,IAAI,EAAE;UAChBG,GAAG,CAACU,GAAG,CAACD,GAAG,CAACZ,EAAE,CAAC;QACnB;MACJ;MACAF,aAAa,GAAGK,GAAG;MACnB;MACA;MACA,MAAMW,aAAa,GAAGX,GAAG,CAACY,IAAI,KAAK,CAAC,IAAIJ,MAAM,CAAC7B,IAAI,CAACkC,MAAM,GAAG,CAAC;MAC9D,IAAI,CAACrB,QAAQ,IAAIA,QAAQ,KAAKmB,aAAa,EAAE;QACzCnB,QAAQ,GAAGmB,aAAa;QACxBX,GAAG,CAACU,GAAG,CAACb,EAAE,CAAC;QACXE,qBAAqB,CAACe,KAAK,CAACC,IAAI,CAACf,GAAG,CAAC,CAAC;MAC1C;IACJ,CAAC,CACD,OAAOM,KAAK,EAAE;MACV,IAAIjB,SAAS,EAAE;QACXX,QAAQ,CAAC;UACL0B,IAAI,EAAE,eAAe;UACrBC,OAAO,EAAE;YACLC,KAAK,EAAEA,KAAK;YACZC,SAAS,EAAE;UACf;QACJ,CAAC,CAAC;MACN;IACJ,CAAC,SACO;MACJ,IAAIlB,SAAS,EAAE;QACX;QACAC,UAAU,GAAG,KAAK;QAClB,IAAIF,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,MAAM,CAAChB,KAAK,EAAE;UAC9D;UACA,OAAOgB,MAAM,CAAChB,KAAK;UACnBf,KAAK,EAAE;QACX,CAAC,MACI,IAAIkC,iBAAiB,EAAE;UACxBlC,KAAK,EAAE;QACX;MACJ;IACJ;EACJ,CAAC;EACDA,KAAK,EAAE;EACP0C,qBAAqB,CAAC,CAACF,EAAE,CAAC,CAAC;EAC3B;EACA,MAAMmB,WAAW,GAAG7D,mBAAmB,CAAC8D,eAAe,CAAC9B,EAAE,EAAEU,EAAE,IAAI;IAC9D,IAAIR,SAAS,IAAI,CAACG,QAAQ,IAAI,CAACG,aAAa,CAACuB,GAAG,CAACrB,EAAE,CAAC,EAAE;MAClDxC,KAAK,EAAE;IACX;EACJ,CAAC,CAAC;EACF,OAAO,MAAM;IACTgC,SAAS,GAAG,KAAK;IACjB2B,WAAW,EAAE;IACb,IAAItB,mBAAmB,EAAE;MACrBA,mBAAmB,EAAE;IACzB;EACJ,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASR,gBAAgB,CAACR,QAAQ,EAAExB,KAAK,EAAEC,mBAAmB,EAAEgC,EAAE,EAAEC,MAAM,EAAE;EACxE,IAAIC,SAAS,GAAG,IAAI;EACpB,IAAIC,UAAU,GAAG,KAAK,CAAC,CAAC;EACxB,IAAIC,iBAAiB,GAAG,KAAK,CAAC,CAAC;EAC/B,MAAMC,QAAQ,GAAG,QAAQJ,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,MAAM,CAAC5B,MAAM,CAAC,KAAK,QAAQ,IAC/F,CAAC4B,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,MAAM,CAAC5B,MAAM,MAAM,KAAK,IAAI,OAAO2B,EAAE,KAAK,QAAQ,IAAIM,OAAO,CAACN,EAAE,CAAC3B,MAAM,CAAE;EAC/H,IAAI2D,SAAS,GAAG,IAAI;EACpB;EACA;EACA,MAAM9D,KAAK,GAAG,YAAY;IACtB,IAAIiC,UAAU,EAAE;MACZC,iBAAiB,GAAG,IAAI;MACxB;IACJ;IACAD,UAAU,GAAG,IAAI;IACjBC,iBAAiB,GAAG,KAAK;IACzBb,QAAQ,CAAC;MAAE0B,IAAI,EAAE;IAAkB,CAAC,CAAC;IACrC,IAAI;MACA,MAAMI,MAAM,GAAG,MAAMtD,KAAK,CAACG,KAAK,CAAC8B,EAAE,EAAEC,MAAM,CAAC;MAC5C,IAAI,CAACC,SAAS,EACV;MACJX,QAAQ,CAAC;QACL0B,IAAI,EAAE,kBAAkB;QACxBC,OAAO,EAAEG;MACb,CAAC,CAAC;MACF,MAAMR,GAAG,GAAG,IAAIJ,GAAG,EAAE;MACrB,KAAK,MAAMa,GAAG,IAAID,MAAM,CAAC7B,IAAI,EAAE;QAC3B,IAAI8B,GAAG,CAACZ,EAAE,IAAI,IAAI,EAAE;UAChBG,GAAG,CAACU,GAAG,CAACD,GAAG,CAACZ,EAAE,CAAC;QACnB;MACJ;MACA,IAAIG,GAAG,CAACY,IAAI,KAAK,CAAC,EAAE;QAChBO,SAAS,GAAG,IAAI;MACpB,CAAC,MACI;QACDA,SAAS,GAAGnB,GAAG;MACnB;IACJ,CAAC,CACD,OAAOM,KAAK,EAAE;MACV,IAAIjB,SAAS,EAAE;QACXX,QAAQ,CAAC;UACL0B,IAAI,EAAE,eAAe;UACrBC,OAAO,EAAE;YACLC,KAAK,EAAEA,KAAK;YACZC,SAAS,EAAE;UACf;QACJ,CAAC,CAAC;MACN;IACJ,CAAC,SACO;MACJ;MACAjB,UAAU,GAAG,KAAK;MAClB,IAAIC,iBAAiB,IAAIF,SAAS,EAAE;QAChChC,KAAK,EAAE;MACX;IACJ;EACJ,CAAC;EACDA,KAAK,EAAE;EACP,IAAI+D,YAAY;EAChB,IAAI,OAAOjC,EAAE,KAAK,UAAU,EAAE;IAC1BiC,YAAY,GAAGjC,EAAE;EACrB,CAAC,MACI,IAAI,OAAOA,EAAE,KAAK,QAAQ,IAAI,OAAOA,EAAE,CAACkC,GAAG,KAAK,UAAU,EAAE;IAC7DD,YAAY,GAAGjC,EAAE,CAACkC,GAAG;EACzB;EACA;EACA,MAAML,WAAW,GAAG7D,mBAAmB,CAAC8C,eAAe,CAAC,IAAI,EAAE,CAACqB,QAAQ,EAAEzB,EAAE,EAAE0B,GAAG,KAAK;IACjF,IAAI/B,QAAQ,EAAE;MACVnC,KAAK,EAAE;MACP;IACJ;IACA,IAAI;MACA,IAAImE,WAAW,GAAG,KAAK;MACvB,IAAID,GAAG,EAAE;QACLH,YAAY,CAACG,GAAG,EAAE,MAAM;UACpBC,WAAW,GAAG,IAAI;QACtB,CAAC,CAAC;MACN;MACA;MACA;MACA,IAAIA,WAAW,KAAKL,SAAS,KAAK,IAAI,IAAIA,SAAS,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,SAAS,CAACD,GAAG,CAACrB,EAAE,CAAC,CAAC,EAAE;QAC1FxC,KAAK,EAAE;MACX;IACJ,CAAC,CACD,OAAOoE,GAAG,EAAE;MACRC,OAAO,CAACpB,KAAK,CAACmB,GAAG,CAAC;IACtB;EACJ,CAAC,CAAC;EACF,OAAO,MAAM;IACTpC,SAAS,GAAG,KAAK;IACjB2B,WAAW,EAAE;EACjB,CAAC;AACL"},"metadata":{},"sourceType":"module","externalDependencies":[]}