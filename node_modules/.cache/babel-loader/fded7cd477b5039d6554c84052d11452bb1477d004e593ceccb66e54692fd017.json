{"ast":null,"code":"import { generateErrorFromResponse } from 'pouchdb-errors';\nimport { Headers } from 'pouchdb-fetch';\nimport abstractMapReduce from 'pouchdb-abstract-mapreduce';\nimport { stringMd5 } from 'pouchdb-md5';\nimport { collate } from 'pouchdb-collate';\nimport { getFieldFromDoc, setFieldInDoc, parseField, matchesSelector, getKey, getValue, compare, massageSelector, filterInMemoryFields } from 'pouchdb-selector-core';\nimport { clone, assign, nextTick, upsert, toPromise, isRemote } from 'pouchdb-utils';\n\n// we restucture the supplied JSON considerably, because the official\n// Mango API is very particular about a lot of this stuff, but we like\n// to be liberal with what we accept in order to prevent mental\n// breakdowns in our users\nfunction massageCreateIndexRequest(requestDef) {\n  requestDef = clone(requestDef);\n  if (!requestDef.index) {\n    requestDef.index = {};\n  }\n  ['type', 'name', 'ddoc'].forEach(function (key) {\n    if (requestDef.index[key]) {\n      requestDef[key] = requestDef.index[key];\n      delete requestDef.index[key];\n    }\n  });\n  if (requestDef.fields) {\n    requestDef.index.fields = requestDef.fields;\n    delete requestDef.fields;\n  }\n  if (!requestDef.type) {\n    requestDef.type = 'json';\n  }\n  return requestDef;\n}\n\n// throws if the user is using the wrong query field value type\nfunction checkFieldValueType(name, value, isHttp) {\n  var message = '';\n  var received = value;\n  var addReceived = true;\n  if (['$in', '$nin', '$or', '$and', '$mod', '$nor', '$all'].indexOf(name) !== -1) {\n    if (!Array.isArray(value)) {\n      message = 'Query operator ' + name + ' must be an array.';\n    }\n  }\n  if (['$not', '$elemMatch', '$allMatch'].indexOf(name) !== -1) {\n    if (!(!Array.isArray(value) && typeof value === 'object' && value !== null)) {\n      message = 'Query operator ' + name + ' must be an object.';\n    }\n  }\n  if (name === '$mod' && Array.isArray(value)) {\n    if (value.length !== 2) {\n      message = 'Query operator $mod must be in the format [divisor, remainder], ' + 'where divisor and remainder are both integers.';\n    } else {\n      var divisor = value[0];\n      var mod = value[1];\n      if (divisor === 0) {\n        message = 'Query operator $mod\\'s divisor cannot be 0, cannot divide by zero.';\n        addReceived = false;\n      }\n      if (typeof divisor !== 'number' || parseInt(divisor, 10) !== divisor) {\n        message = 'Query operator $mod\\'s divisor is not an integer.';\n        received = divisor;\n      }\n      if (parseInt(mod, 10) !== mod) {\n        message = 'Query operator $mod\\'s remainder is not an integer.';\n        received = mod;\n      }\n    }\n  }\n  if (name === '$exists') {\n    if (typeof value !== 'boolean') {\n      message = 'Query operator $exists must be a boolean.';\n    }\n  }\n  if (name === '$type') {\n    var allowed = ['null', 'boolean', 'number', 'string', 'array', 'object'];\n    var allowedStr = '\"' + allowed.slice(0, allowed.length - 1).join('\", \"') + '\", or \"' + allowed[allowed.length - 1] + '\"';\n    if (typeof value !== 'string') {\n      message = 'Query operator $type must be a string. Supported values: ' + allowedStr + '.';\n    } else if (allowed.indexOf(value) == -1) {\n      message = 'Query operator $type must be a string. Supported values: ' + allowedStr + '.';\n    }\n  }\n  if (name === '$size') {\n    if (parseInt(value, 10) !== value) {\n      message = 'Query operator $size must be a integer.';\n    }\n  }\n  if (name === '$regex') {\n    if (typeof value !== 'string') {\n      console.log(\"here\", isHttp);\n      if (isHttp) {\n        message = 'Query operator $regex must be a string.';\n      } else if (!(value instanceof RegExp)) {\n        message = 'Query operator $regex must be a string or an instance ' + 'of a javascript regular expression.';\n      }\n    }\n  }\n  if (message) {\n    if (addReceived) {\n      var type = received === null ? ' ' : Array.isArray(received) ? ' array' : ' ' + typeof received;\n      var receivedStr = typeof received === 'object' && received !== null ? JSON.stringify(received, null, '\\t') : received;\n      message += ' Received' + type + ': ' + receivedStr;\n    }\n    throw new Error(message);\n  }\n}\nvar requireValidation = ['$all', '$allMatch', '$and', '$elemMatch', '$exists', '$in', '$mod', '$nin', '$nor', '$not', '$or', '$regex', '$size', '$type'];\nvar arrayTypeComparisonOperators = ['$in', '$nin', '$mod', '$all'];\nvar equalityOperators = ['$eq', '$gt', '$gte', '$lt', '$lte'];\n\n// recursively walks down the a query selector validating any operators\nfunction validateSelector(input, isHttp) {\n  if (Array.isArray(input)) {\n    for (var entry of input) {\n      if (typeof entry === 'object' && value !== null) {\n        validateSelector(entry, isHttp);\n      }\n    }\n  } else {\n    var fields = Object.keys(input);\n    for (var i = 0; i < fields.length; i++) {\n      var key = fields[i];\n      var value = input[key];\n      if (requireValidation.indexOf(key) !== -1) {\n        checkFieldValueType(key, value, isHttp);\n      }\n      if (equalityOperators.indexOf(key) !== -1) {\n        // skip, explicit comparison operators can be anything\n        continue;\n      }\n      if (arrayTypeComparisonOperators.indexOf(key) !== -1) {\n        // skip, their values are already valid\n        continue;\n      }\n      if (typeof value === 'object' && value !== null) {\n        validateSelector(value, isHttp);\n      }\n    }\n  }\n}\nfunction dbFetch(db, path, opts, callback) {\n  var status, ok;\n  opts.headers = new Headers({\n    'Content-type': 'application/json'\n  });\n  db.fetch(path, opts).then(function (response) {\n    status = response.status;\n    ok = response.ok;\n    return response.json();\n  }).then(function (json) {\n    if (!ok) {\n      json.status = status;\n      var err = generateErrorFromResponse(json);\n      callback(err);\n    } else {\n      callback(null, json);\n    }\n  }).catch(callback);\n}\nfunction createIndex(db, requestDef, callback) {\n  requestDef = massageCreateIndexRequest(requestDef);\n  dbFetch(db, '_index', {\n    method: 'POST',\n    body: JSON.stringify(requestDef)\n  }, callback);\n}\nfunction find(db, requestDef, callback) {\n  validateSelector(requestDef.selector, true);\n  dbFetch(db, '_find', {\n    method: 'POST',\n    body: JSON.stringify(requestDef)\n  }, callback);\n}\nfunction explain(db, requestDef, callback) {\n  dbFetch(db, '_explain', {\n    method: 'POST',\n    body: JSON.stringify(requestDef)\n  }, callback);\n}\nfunction getIndexes(db, callback) {\n  dbFetch(db, '_index', {\n    method: 'GET'\n  }, callback);\n}\nfunction deleteIndex(db, indexDef, callback) {\n  var ddoc = indexDef.ddoc;\n  var type = indexDef.type || 'json';\n  var name = indexDef.name;\n  if (!ddoc) {\n    return callback(new Error('you must provide an index\\'s ddoc'));\n  }\n  if (!name) {\n    return callback(new Error('you must provide an index\\'s name'));\n  }\n  var url = '_index/' + [ddoc, type, name].map(encodeURIComponent).join('/');\n  dbFetch(db, url, {\n    method: 'DELETE'\n  }, callback);\n}\nfunction getArguments(fun) {\n  return function () {\n    var len = arguments.length;\n    var args = new Array(len);\n    var i = -1;\n    while (++i < len) {\n      args[i] = arguments[i];\n    }\n    return fun.call(this, args);\n  };\n}\nfunction callbackify(fun) {\n  return getArguments(function (args) {\n    var cb = args.pop();\n    var promise = fun.apply(this, args);\n    promisedCallback(promise, cb);\n    return promise;\n  });\n}\nfunction promisedCallback(promise, callback) {\n  promise.then(function (res) {\n    nextTick(function () {\n      callback(null, res);\n    });\n  }, function (reason) {\n    nextTick(function () {\n      callback(reason);\n    });\n  });\n  return promise;\n}\nvar flatten = getArguments(function (args) {\n  var res = [];\n  for (var i = 0, len = args.length; i < len; i++) {\n    var subArr = args[i];\n    if (Array.isArray(subArr)) {\n      res = res.concat(flatten.apply(null, subArr));\n    } else {\n      res.push(subArr);\n    }\n  }\n  return res;\n});\nfunction mergeObjects(arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    res = assign(res, arr[i]);\n  }\n  return res;\n}\n\n// Selects a list of fields defined in dot notation from one doc\n// and copies them to a new doc. Like underscore _.pick but supports nesting.\nfunction pick(obj, arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var parsedField = parseField(arr[i]);\n    var value = getFieldFromDoc(obj, parsedField);\n    if (typeof value !== 'undefined') {\n      setFieldInDoc(res, parsedField, value);\n    }\n  }\n  return res;\n}\n\n// e.g. ['a'], ['a', 'b'] is true, but ['b'], ['a', 'b'] is false\nfunction oneArrayIsSubArrayOfOther(left, right) {\n  for (var i = 0, len = Math.min(left.length, right.length); i < len; i++) {\n    if (left[i] !== right[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// e.g.['a', 'b', 'c'], ['a', 'b'] is false\nfunction oneArrayIsStrictSubArrayOfOther(left, right) {\n  if (left.length > right.length) {\n    return false;\n  }\n  return oneArrayIsSubArrayOfOther(left, right);\n}\n\n// same as above, but treat the left array as an unordered set\n// e.g. ['b', 'a'], ['a', 'b', 'c'] is true, but ['c'], ['a', 'b', 'c'] is false\nfunction oneSetIsSubArrayOfOther(left, right) {\n  left = left.slice();\n  for (var i = 0, len = right.length; i < len; i++) {\n    var field = right[i];\n    if (!left.length) {\n      break;\n    }\n    var leftIdx = left.indexOf(field);\n    if (leftIdx === -1) {\n      return false;\n    } else {\n      left.splice(leftIdx, 1);\n    }\n  }\n  return true;\n}\nfunction arrayToObject(arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    res[arr[i]] = true;\n  }\n  return res;\n}\nfunction max(arr, fun) {\n  var max = null;\n  var maxScore = -1;\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var element = arr[i];\n    var score = fun(element);\n    if (score > maxScore) {\n      maxScore = score;\n      max = element;\n    }\n  }\n  return max;\n}\nfunction arrayEquals(arr1, arr2) {\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n  for (var i = 0, len = arr1.length; i < len; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction uniq(arr) {\n  var obj = {};\n  for (var i = 0; i < arr.length; i++) {\n    obj['$' + arr[i]] = true;\n  }\n  return Object.keys(obj).map(function (key) {\n    return key.substring(1);\n  });\n}\n\n//\n// One thing about these mappers:\n//\n// Per the advice of John-David Dalton (http://youtu.be/NthmeLEhDDM),\n// what you want to do in this case is optimize for the smallest possible\n// function, since that's the thing that gets run over and over again.\n//\n// This code would be a lot simpler if all the if/elses were inside\n// the function, but it would also be a lot less performant.\n//\n\nfunction createDeepMultiMapper(fields, emit, selector) {\n  return function (doc) {\n    if (selector && !matchesSelector(doc, selector)) {\n      return;\n    }\n    var toEmit = [];\n    for (var i = 0, iLen = fields.length; i < iLen; i++) {\n      var parsedField = parseField(fields[i]);\n      var value = doc;\n      for (var j = 0, jLen = parsedField.length; j < jLen; j++) {\n        var key = parsedField[j];\n        value = value[key];\n        if (typeof value === 'undefined') {\n          return; // don't emit\n        }\n      }\n\n      toEmit.push(value);\n    }\n    emit(toEmit);\n  };\n}\nfunction createDeepSingleMapper(field, emit, selector) {\n  var parsedField = parseField(field);\n  return function (doc) {\n    if (selector && !matchesSelector(doc, selector)) {\n      return;\n    }\n    var value = doc;\n    for (var i = 0, len = parsedField.length; i < len; i++) {\n      var key = parsedField[i];\n      value = value[key];\n      if (typeof value === 'undefined') {\n        return; // do nothing\n      }\n    }\n\n    emit(value);\n  };\n}\nfunction createShallowSingleMapper(field, emit, selector) {\n  return function (doc) {\n    if (selector && !matchesSelector(doc, selector)) {\n      return;\n    }\n    emit(doc[field]);\n  };\n}\nfunction createShallowMultiMapper(fields, emit, selector) {\n  return function (doc) {\n    if (selector && !matchesSelector(doc, selector)) {\n      return;\n    }\n    var toEmit = [];\n    for (var i = 0, len = fields.length; i < len; i++) {\n      toEmit.push(doc[fields[i]]);\n    }\n    emit(toEmit);\n  };\n}\nfunction checkShallow(fields) {\n  for (var i = 0, len = fields.length; i < len; i++) {\n    var field = fields[i];\n    if (field.indexOf('.') !== -1) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction createMapper(fields, emit, selector) {\n  var isShallow = checkShallow(fields);\n  var isSingle = fields.length === 1;\n\n  // notice we try to optimize for the most common case,\n  // i.e. single shallow indexes\n  if (isShallow) {\n    if (isSingle) {\n      return createShallowSingleMapper(fields[0], emit, selector);\n    } else {\n      // multi\n      return createShallowMultiMapper(fields, emit, selector);\n    }\n  } else {\n    // deep\n    if (isSingle) {\n      return createDeepSingleMapper(fields[0], emit, selector);\n    } else {\n      // multi\n      return createDeepMultiMapper(fields, emit, selector);\n    }\n  }\n}\nfunction mapper(mapFunDef, emit) {\n  // mapFunDef is a list of fields\n\n  const fields = Object.keys(mapFunDef.fields);\n  const partialSelector = mapFunDef.partial_filter_selector;\n  return createMapper(fields, emit, partialSelector);\n}\n\n/* istanbul ignore next */\nfunction reducer( /*reduceFunDef*/\n) {\n  throw new Error('reduce not supported');\n}\nfunction ddocValidator(ddoc, viewName) {\n  var view = ddoc.views[viewName];\n  // This doesn't actually need to be here apparently, but\n  // I feel safer keeping it.\n  /* istanbul ignore if */\n  if (!view.map || !view.map.fields) {\n    throw new Error('ddoc ' + ddoc._id + ' with view ' + viewName + ' doesn\\'t have map.fields defined. ' + 'maybe it wasn\\'t created by this plugin?');\n  }\n}\nvar abstractMapper = abstractMapReduce( /* localDocName */'indexes', mapper, reducer, ddocValidator);\nfunction abstractMapper$1(db) {\n  return db._customFindAbstractMapper || abstractMapper;\n}\n\n// normalize the \"sort\" value\nfunction massageSort(sort) {\n  if (!Array.isArray(sort)) {\n    throw new Error('invalid sort json - should be an array');\n  }\n  return sort.map(function (sorting) {\n    if (typeof sorting === 'string') {\n      var obj = {};\n      obj[sorting] = 'asc';\n      return obj;\n    } else {\n      return sorting;\n    }\n  });\n}\nfunction massageUseIndex(useIndex) {\n  var cleanedUseIndex = [];\n  if (typeof useIndex === 'string') {\n    cleanedUseIndex.push(useIndex);\n  } else {\n    cleanedUseIndex = useIndex;\n  }\n  return cleanedUseIndex.map(function (name) {\n    return name.replace('_design/', '');\n  });\n}\nfunction massageIndexDef(indexDef) {\n  indexDef.fields = indexDef.fields.map(function (field) {\n    if (typeof field === 'string') {\n      var obj = {};\n      obj[field] = 'asc';\n      return obj;\n    }\n    return field;\n  });\n  return indexDef;\n}\nfunction getKeyFromDoc(doc, index) {\n  var res = [];\n  for (var i = 0; i < index.def.fields.length; i++) {\n    var field = getKey(index.def.fields[i]);\n    res.push(doc[field]);\n  }\n  return res;\n}\n\n// have to do this manually because REASONS. I don't know why\n// CouchDB didn't implement inclusive_start\nfunction filterInclusiveStart(rows, targetValue, index) {\n  var indexFields = index.def.fields;\n  for (var i = 0, len = rows.length; i < len; i++) {\n    var row = rows[i];\n\n    // shave off any docs at the beginning that are <= the\n    // target value\n\n    var docKey = getKeyFromDoc(row.doc, index);\n    if (indexFields.length === 1) {\n      docKey = docKey[0]; // only one field, not multi-field\n    } else {\n      // more than one field in index\n      // in the case where e.g. the user is searching {$gt: {a: 1}}\n      // but the index is [a, b], then we need to shorten the doc key\n      while (docKey.length > targetValue.length) {\n        docKey.pop();\n      }\n    }\n    //ABS as we just looking for values that don't match\n    if (Math.abs(collate(docKey, targetValue)) > 0) {\n      // no need to filter any further; we're past the key\n      break;\n    }\n  }\n  return i > 0 ? rows.slice(i) : rows;\n}\nfunction reverseOptions(opts) {\n  var newOpts = clone(opts);\n  delete newOpts.startkey;\n  delete newOpts.endkey;\n  delete newOpts.inclusive_start;\n  delete newOpts.inclusive_end;\n  if ('endkey' in opts) {\n    newOpts.startkey = opts.endkey;\n  }\n  if ('startkey' in opts) {\n    newOpts.endkey = opts.startkey;\n  }\n  if ('inclusive_start' in opts) {\n    newOpts.inclusive_end = opts.inclusive_start;\n  }\n  if ('inclusive_end' in opts) {\n    newOpts.inclusive_start = opts.inclusive_end;\n  }\n  return newOpts;\n}\nfunction validateIndex(index) {\n  var ascFields = index.fields.filter(function (field) {\n    return getValue(field) === 'asc';\n  });\n  if (ascFields.length !== 0 && ascFields.length !== index.fields.length) {\n    throw new Error('unsupported mixed sorting');\n  }\n}\nfunction validateSort(requestDef, index) {\n  if (index.defaultUsed && requestDef.sort) {\n    var noneIdSorts = requestDef.sort.filter(function (sortItem) {\n      return Object.keys(sortItem)[0] !== '_id';\n    }).map(function (sortItem) {\n      return Object.keys(sortItem)[0];\n    });\n    if (noneIdSorts.length > 0) {\n      throw new Error('Cannot sort on field(s) \"' + noneIdSorts.join(',') + '\" when using the default index');\n    }\n  }\n  if (index.defaultUsed) {\n    return;\n  }\n}\nfunction validateFindRequest(requestDef) {\n  if (typeof requestDef.selector !== 'object') {\n    throw new Error('you must provide a selector when you find()');\n  }\n\n  /*var selectors = requestDef.selector['$and'] || [requestDef.selector];\n  for (var i = 0; i < selectors.length; i++) {\n    var selector = selectors[i];\n    var keys = Object.keys(selector);\n    if (keys.length === 0) {\n      throw new Error('invalid empty selector');\n    }\n    //var selection = selector[keys[0]];\n    /*if (Object.keys(selection).length !== 1) {\n      throw new Error('invalid selector: ' + JSON.stringify(selection) +\n        ' - it must have exactly one key/value');\n    }\n  }*/\n}\n\n// determine the maximum number of fields\n// we're going to need to query, e.g. if the user\n// has selection ['a'] and sorting ['a', 'b'], then we\n// need to use the longer of the two: ['a', 'b']\nfunction getUserFields(selector, sort) {\n  var selectorFields = Object.keys(selector);\n  var sortFields = sort ? sort.map(getKey) : [];\n  var userFields;\n  if (selectorFields.length >= sortFields.length) {\n    userFields = selectorFields;\n  } else {\n    userFields = sortFields;\n  }\n  if (sortFields.length === 0) {\n    return {\n      fields: userFields\n    };\n  }\n\n  // sort according to the user's preferred sorting\n  userFields = userFields.sort(function (left, right) {\n    var leftIdx = sortFields.indexOf(left);\n    if (leftIdx === -1) {\n      leftIdx = Number.MAX_VALUE;\n    }\n    var rightIdx = sortFields.indexOf(right);\n    if (rightIdx === -1) {\n      rightIdx = Number.MAX_VALUE;\n    }\n    return leftIdx < rightIdx ? -1 : leftIdx > rightIdx ? 1 : 0;\n  });\n  return {\n    fields: userFields,\n    sortOrder: sort.map(getKey)\n  };\n}\nfunction createIndex$1(db, requestDef) {\n  requestDef = massageCreateIndexRequest(requestDef);\n  var originalIndexDef = clone(requestDef.index);\n  requestDef.index = massageIndexDef(requestDef.index);\n  validateIndex(requestDef.index);\n\n  // calculating md5 is expensive - memoize and only\n  // run if required\n  var md5;\n  function getMd5() {\n    return md5 || (md5 = stringMd5(JSON.stringify(requestDef)));\n  }\n  var viewName = requestDef.name || 'idx-' + getMd5();\n  var ddocName = requestDef.ddoc || 'idx-' + getMd5();\n  var ddocId = '_design/' + ddocName;\n  var hasInvalidLanguage = false;\n  var viewExists = false;\n  function updateDdoc(doc) {\n    if (doc._rev && doc.language !== 'query') {\n      hasInvalidLanguage = true;\n    }\n    doc.language = 'query';\n    doc.views = doc.views || {};\n    viewExists = !!doc.views[viewName];\n    if (viewExists) {\n      return false;\n    }\n    doc.views[viewName] = {\n      map: {\n        fields: mergeObjects(requestDef.index.fields)\n      },\n      reduce: '_count',\n      options: {\n        def: originalIndexDef\n      }\n    };\n    return doc;\n  }\n  db.constructor.emit('debug', ['find', 'creating index', ddocId]);\n  return upsert(db, ddocId, updateDdoc).then(function () {\n    if (hasInvalidLanguage) {\n      throw new Error('invalid language for ddoc with id \"' + ddocId + '\" (should be \"query\")');\n    }\n  }).then(function () {\n    // kick off a build\n    // TODO: abstract-pouchdb-mapreduce should support auto-updating\n    // TODO: should also use update_after, but pouchdb/pouchdb#3415 blocks me\n    var signature = ddocName + '/' + viewName;\n    return abstractMapper$1(db).query.call(db, signature, {\n      limit: 0,\n      reduce: false\n    }).then(function () {\n      return {\n        id: ddocId,\n        name: viewName,\n        result: viewExists ? 'exists' : 'created'\n      };\n    });\n  });\n}\nfunction getIndexes$1(db) {\n  // just search through all the design docs and filter in-memory.\n  // hopefully there aren't that many ddocs.\n  return db.allDocs({\n    startkey: '_design/',\n    endkey: '_design/\\uffff',\n    include_docs: true\n  }).then(function (allDocsRes) {\n    var res = {\n      indexes: [{\n        ddoc: null,\n        name: '_all_docs',\n        type: 'special',\n        def: {\n          fields: [{\n            _id: 'asc'\n          }]\n        }\n      }]\n    };\n    res.indexes = flatten(res.indexes, allDocsRes.rows.filter(function (row) {\n      return row.doc.language === 'query';\n    }).map(function (row) {\n      var viewNames = row.doc.views !== undefined ? Object.keys(row.doc.views) : [];\n      return viewNames.map(function (viewName) {\n        var view = row.doc.views[viewName];\n        return {\n          ddoc: row.id,\n          name: viewName,\n          type: 'json',\n          def: massageIndexDef(view.options.def)\n        };\n      });\n    }));\n\n    // these are sorted by view name for some reason\n    res.indexes.sort(function (left, right) {\n      return compare(left.name, right.name);\n    });\n    res.total_rows = res.indexes.length;\n    return res;\n  });\n}\n\n// couchdb lowest collation value\nvar COLLATE_LO = null;\n\n// couchdb highest collation value (TODO: well not really, but close enough amirite)\nvar COLLATE_HI = {\n  \"\\uffff\": {}\n};\nconst SHORT_CIRCUIT_QUERY = {\n  queryOpts: {\n    limit: 0,\n    startkey: COLLATE_HI,\n    endkey: COLLATE_LO\n  },\n  inMemoryFields: []\n};\n\n// couchdb second-lowest collation value\n\nfunction checkFieldInIndex(index, field) {\n  var indexFields = index.def.fields.map(getKey);\n  for (var i = 0, len = indexFields.length; i < len; i++) {\n    var indexField = indexFields[i];\n    if (field === indexField) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// so when you do e.g. $eq/$eq, we can do it entirely in the database.\n// but when you do e.g. $gt/$eq, the first part can be done\n// in the database, but the second part has to be done in-memory,\n// because $gt has forced us to lose precision.\n// so that's what this determines\nfunction userOperatorLosesPrecision(selector, field) {\n  var matcher = selector[field];\n  var userOperator = getKey(matcher);\n  return userOperator !== '$eq';\n}\n\n// sort the user fields by their position in the index,\n// if they're in the index\nfunction sortFieldsByIndex(userFields, index) {\n  var indexFields = index.def.fields.map(getKey);\n  return userFields.slice().sort(function (a, b) {\n    var aIdx = indexFields.indexOf(a);\n    var bIdx = indexFields.indexOf(b);\n    if (aIdx === -1) {\n      aIdx = Number.MAX_VALUE;\n    }\n    if (bIdx === -1) {\n      bIdx = Number.MAX_VALUE;\n    }\n    return compare(aIdx, bIdx);\n  });\n}\n\n// first pass to try to find fields that will need to be sorted in-memory\nfunction getBasicInMemoryFields(index, selector, userFields) {\n  userFields = sortFieldsByIndex(userFields, index);\n\n  // check if any of the user selectors lose precision\n  var needToFilterInMemory = false;\n  for (var i = 0, len = userFields.length; i < len; i++) {\n    var field = userFields[i];\n    if (needToFilterInMemory || !checkFieldInIndex(index, field)) {\n      return userFields.slice(i);\n    }\n    if (i < len - 1 && userOperatorLosesPrecision(selector, field)) {\n      needToFilterInMemory = true;\n    }\n  }\n  return [];\n}\nfunction getInMemoryFieldsFromNe(selector) {\n  var fields = [];\n  Object.keys(selector).forEach(function (field) {\n    var matcher = selector[field];\n    Object.keys(matcher).forEach(function (operator) {\n      if (operator === '$ne') {\n        fields.push(field);\n      }\n    });\n  });\n  return fields;\n}\nfunction getInMemoryFields(coreInMemoryFields, index, selector, userFields) {\n  var result = flatten(\n  // in-memory fields reported as necessary by the query planner\n  coreInMemoryFields,\n  // combine with another pass that checks for any we may have missed\n  getBasicInMemoryFields(index, selector, userFields),\n  // combine with another pass that checks for $ne's\n  getInMemoryFieldsFromNe(selector));\n  return sortFieldsByIndex(uniq(result), index);\n}\n\n// check that at least one field in the user's query is represented\n// in the index. order matters in the case of sorts\nfunction checkIndexFieldsMatch(indexFields, sortOrder, fields) {\n  if (sortOrder) {\n    // array has to be a strict subarray of index array. furthermore,\n    // the sortOrder fields need to all be represented in the index\n    var sortMatches = oneArrayIsStrictSubArrayOfOther(sortOrder, indexFields);\n    var selectorMatches = oneArrayIsSubArrayOfOther(fields, indexFields);\n    return sortMatches && selectorMatches;\n  }\n\n  // all of the user's specified fields still need to be\n  // on the left side of the index array, although the order\n  // doesn't matter\n  return oneSetIsSubArrayOfOther(fields, indexFields);\n}\nvar logicalMatchers = ['$eq', '$gt', '$gte', '$lt', '$lte'];\nfunction isNonLogicalMatcher(matcher) {\n  return logicalMatchers.indexOf(matcher) === -1;\n}\n\n// check all the index fields for usages of '$ne'\n// e.g. if the user queries {foo: {$ne: 'foo'}, bar: {$eq: 'bar'}},\n// then we can neither use an index on ['foo'] nor an index on\n// ['foo', 'bar'], but we can use an index on ['bar'] or ['bar', 'foo']\nfunction checkFieldsLogicallySound(indexFields, selector) {\n  var firstField = indexFields[0];\n  var matcher = selector[firstField];\n  if (typeof matcher === 'undefined') {\n    /* istanbul ignore next */\n    return true;\n  }\n  var isInvalidNe = Object.keys(matcher).length === 1 && getKey(matcher) === '$ne';\n  return !isInvalidNe;\n}\nfunction checkIndexMatches(index, sortOrder, fields, selector) {\n  var indexFields = index.def.fields.map(getKey);\n  var fieldsMatch = checkIndexFieldsMatch(indexFields, sortOrder, fields);\n  if (!fieldsMatch) {\n    return false;\n  }\n  return checkFieldsLogicallySound(indexFields, selector);\n}\n\n//\n// the algorithm is very simple:\n// take all the fields the user supplies, and if those fields\n// are a strict subset of the fields in some index,\n// then use that index\n//\n//\nfunction findMatchingIndexes(selector, userFields, sortOrder, indexes) {\n  return indexes.filter(function (index) {\n    return checkIndexMatches(index, sortOrder, userFields, selector);\n  });\n}\n\n// find the best index, i.e. the one that matches the most fields\n// in the user's query\nfunction findBestMatchingIndex(selector, userFields, sortOrder, indexes, useIndex) {\n  var matchingIndexes = findMatchingIndexes(selector, userFields, sortOrder, indexes);\n  if (matchingIndexes.length === 0) {\n    if (useIndex) {\n      throw {\n        error: \"no_usable_index\",\n        message: \"There is no index available for this selector.\"\n      };\n    }\n    //return `all_docs` as a default index;\n    //I'm assuming that _all_docs is always first\n    var defaultIndex = indexes[0];\n    defaultIndex.defaultUsed = true;\n    return defaultIndex;\n  }\n  if (matchingIndexes.length === 1 && !useIndex) {\n    return matchingIndexes[0];\n  }\n  var userFieldsMap = arrayToObject(userFields);\n  function scoreIndex(index) {\n    var indexFields = index.def.fields.map(getKey);\n    var score = 0;\n    for (var i = 0, len = indexFields.length; i < len; i++) {\n      var indexField = indexFields[i];\n      if (userFieldsMap[indexField]) {\n        score++;\n      }\n    }\n    return score;\n  }\n  if (useIndex) {\n    var useIndexDdoc = '_design/' + useIndex[0];\n    var useIndexName = useIndex.length === 2 ? useIndex[1] : false;\n    var index = matchingIndexes.find(function (index) {\n      if (useIndexName && index.ddoc === useIndexDdoc && useIndexName === index.name) {\n        return true;\n      }\n      if (index.ddoc === useIndexDdoc) {\n        /* istanbul ignore next */\n        return true;\n      }\n      return false;\n    });\n    if (!index) {\n      throw {\n        error: \"unknown_error\",\n        message: \"Could not find that index or could not use that index for the query\"\n      };\n    }\n    return index;\n  }\n  return max(matchingIndexes, scoreIndex);\n}\nfunction getSingleFieldQueryOptsFor(userOperator, userValue) {\n  switch (userOperator) {\n    case '$eq':\n      return {\n        key: userValue\n      };\n    case '$lte':\n      return {\n        endkey: userValue\n      };\n    case '$gte':\n      return {\n        startkey: userValue\n      };\n    case '$lt':\n      return {\n        endkey: userValue,\n        inclusive_end: false\n      };\n    case '$gt':\n      return {\n        startkey: userValue,\n        inclusive_start: false\n      };\n  }\n  return {\n    startkey: COLLATE_LO\n  };\n}\nfunction getSingleFieldCoreQueryPlan(selector, index) {\n  var field = getKey(index.def.fields[0]);\n  //ignoring this because the test to exercise the branch is skipped at the moment\n  /* istanbul ignore next */\n  var matcher = selector[field] || {};\n  var inMemoryFields = [];\n  var userOperators = Object.keys(matcher);\n  var combinedOpts;\n  userOperators.forEach(function (userOperator) {\n    if (isNonLogicalMatcher(userOperator)) {\n      inMemoryFields.push(field);\n    }\n    var userValue = matcher[userOperator];\n    var newQueryOpts = getSingleFieldQueryOptsFor(userOperator, userValue);\n    if (combinedOpts) {\n      combinedOpts = mergeObjects([combinedOpts, newQueryOpts]);\n    } else {\n      combinedOpts = newQueryOpts;\n    }\n  });\n  return {\n    queryOpts: combinedOpts,\n    inMemoryFields: inMemoryFields\n  };\n}\nfunction getMultiFieldCoreQueryPlan(userOperator, userValue) {\n  switch (userOperator) {\n    case '$eq':\n      return {\n        startkey: userValue,\n        endkey: userValue\n      };\n    case '$lte':\n      return {\n        endkey: userValue\n      };\n    case '$gte':\n      return {\n        startkey: userValue\n      };\n    case '$lt':\n      return {\n        endkey: userValue,\n        inclusive_end: false\n      };\n    case '$gt':\n      return {\n        startkey: userValue,\n        inclusive_start: false\n      };\n  }\n}\nfunction getMultiFieldQueryOpts(selector, index) {\n  var indexFields = index.def.fields.map(getKey);\n  var inMemoryFields = [];\n  var startkey = [];\n  var endkey = [];\n  var inclusiveStart;\n  var inclusiveEnd;\n  function finish(i) {\n    if (inclusiveStart !== false) {\n      startkey.push(COLLATE_LO);\n    }\n    if (inclusiveEnd !== false) {\n      endkey.push(COLLATE_HI);\n    }\n    // keep track of the fields where we lost specificity,\n    // and therefore need to filter in-memory\n    inMemoryFields = indexFields.slice(i);\n  }\n  for (var i = 0, len = indexFields.length; i < len; i++) {\n    var indexField = indexFields[i];\n    var matcher = selector[indexField];\n    if (!matcher || !Object.keys(matcher).length) {\n      // fewer fields in user query than in index\n      finish(i);\n      break;\n    } else if (Object.keys(matcher).some(isNonLogicalMatcher)) {\n      // non-logical are ignored\n      finish(i);\n      break;\n    } else if (i > 0) {\n      var usingGtlt = '$gt' in matcher || '$gte' in matcher || '$lt' in matcher || '$lte' in matcher;\n      var previousKeys = Object.keys(selector[indexFields[i - 1]]);\n      var previousWasEq = arrayEquals(previousKeys, ['$eq']);\n      var previousWasSame = arrayEquals(previousKeys, Object.keys(matcher));\n      var gtltLostSpecificity = usingGtlt && !previousWasEq && !previousWasSame;\n      if (gtltLostSpecificity) {\n        finish(i);\n        break;\n      }\n    }\n    var userOperators = Object.keys(matcher);\n    var combinedOpts = null;\n    for (var j = 0; j < userOperators.length; j++) {\n      var userOperator = userOperators[j];\n      var userValue = matcher[userOperator];\n      var newOpts = getMultiFieldCoreQueryPlan(userOperator, userValue);\n      if (combinedOpts) {\n        combinedOpts = mergeObjects([combinedOpts, newOpts]);\n      } else {\n        combinedOpts = newOpts;\n      }\n    }\n    startkey.push('startkey' in combinedOpts ? combinedOpts.startkey : COLLATE_LO);\n    endkey.push('endkey' in combinedOpts ? combinedOpts.endkey : COLLATE_HI);\n    if ('inclusive_start' in combinedOpts) {\n      inclusiveStart = combinedOpts.inclusive_start;\n    }\n    if ('inclusive_end' in combinedOpts) {\n      inclusiveEnd = combinedOpts.inclusive_end;\n    }\n  }\n  var res = {\n    startkey: startkey,\n    endkey: endkey\n  };\n  if (typeof inclusiveStart !== 'undefined') {\n    res.inclusive_start = inclusiveStart;\n  }\n  if (typeof inclusiveEnd !== 'undefined') {\n    res.inclusive_end = inclusiveEnd;\n  }\n  return {\n    queryOpts: res,\n    inMemoryFields: inMemoryFields\n  };\n}\nfunction shouldShortCircuit(selector) {\n  // We have a field to select from, but not a valid value\n  // this should result in a short circuited query \n  // just like the http adapter (couchdb) and mongodb\n  // see tests for issue #7810\n\n  // @todo Use 'Object.values' when Node.js v6 support is dropped.\n  const values = Object.keys(selector).map(function (key) {\n    return selector[key];\n  });\n  return values.some(function (val) {\n    return typeof val === 'object' && Object.keys(val).length === 0;\n  });\n}\nfunction getDefaultQueryPlan(selector) {\n  //using default index, so all fields need to be done in memory\n  return {\n    queryOpts: {\n      startkey: null\n    },\n    inMemoryFields: [Object.keys(selector)]\n  };\n}\nfunction getCoreQueryPlan(selector, index) {\n  if (index.defaultUsed) {\n    return getDefaultQueryPlan(selector, index);\n  }\n  if (index.def.fields.length === 1) {\n    // one field in index, so the value was indexed as a singleton\n    return getSingleFieldCoreQueryPlan(selector, index);\n  }\n  // else index has multiple fields, so the value was indexed as an array\n  return getMultiFieldQueryOpts(selector, index);\n}\nfunction planQuery(request, indexes) {\n  var selector = request.selector;\n  var sort = request.sort;\n  if (shouldShortCircuit(selector)) {\n    return assign({}, SHORT_CIRCUIT_QUERY, {\n      index: indexes[0]\n    });\n  }\n  var userFieldsRes = getUserFields(selector, sort);\n  var userFields = userFieldsRes.fields;\n  var sortOrder = userFieldsRes.sortOrder;\n  var index = findBestMatchingIndex(selector, userFields, sortOrder, indexes, request.use_index);\n  var coreQueryPlan = getCoreQueryPlan(selector, index);\n  var queryOpts = coreQueryPlan.queryOpts;\n  var coreInMemoryFields = coreQueryPlan.inMemoryFields;\n  var inMemoryFields = getInMemoryFields(coreInMemoryFields, index, selector, userFields);\n  var res = {\n    queryOpts: queryOpts,\n    index: index,\n    inMemoryFields: inMemoryFields\n  };\n  return res;\n}\nfunction indexToSignature(index) {\n  // remove '_design/'\n  return index.ddoc.substring(8) + '/' + index.name;\n}\nfunction doAllDocs(db, originalOpts) {\n  var opts = clone(originalOpts);\n\n  // CouchDB responds in weird ways when you provide a non-string to _id;\n  // we mimic the behavior for consistency. See issue66 tests for details.\n  if (opts.descending) {\n    if ('endkey' in opts && typeof opts.endkey !== 'string') {\n      opts.endkey = '';\n    }\n    if ('startkey' in opts && typeof opts.startkey !== 'string') {\n      opts.limit = 0;\n    }\n  } else {\n    if ('startkey' in opts && typeof opts.startkey !== 'string') {\n      opts.startkey = '';\n    }\n    if ('endkey' in opts && typeof opts.endkey !== 'string') {\n      opts.limit = 0;\n    }\n  }\n  if ('key' in opts && typeof opts.key !== 'string') {\n    opts.limit = 0;\n  }\n  if (opts.limit > 0 && opts.indexes_count) {\n    // brute force and quite naive impl.\n    // amp up the limit with the amount of (indexes) design docs\n    // or is this too naive? How about skip?\n    opts.original_limit = opts.limit;\n    opts.limit += opts.indexes_count;\n  }\n  return db.allDocs(opts).then(function (res) {\n    // filter out any design docs that _all_docs might return\n    res.rows = res.rows.filter(function (row) {\n      return !/^_design\\//.test(row.id);\n    });\n    // put back original limit\n    if (opts.original_limit) {\n      opts.limit = opts.original_limit;\n    }\n    // enforce the rows to respect the given limit\n    res.rows = res.rows.slice(0, opts.limit);\n    return res;\n  });\n}\nfunction find$1(db, requestDef, explain) {\n  if (requestDef.selector) {\n    // must be validated before massaging\n    validateSelector(requestDef.selector, false);\n    requestDef.selector = massageSelector(requestDef.selector);\n  }\n  if (requestDef.sort) {\n    requestDef.sort = massageSort(requestDef.sort);\n  }\n  if (requestDef.use_index) {\n    requestDef.use_index = massageUseIndex(requestDef.use_index);\n  }\n  validateFindRequest(requestDef);\n  return getIndexes$1(db).then(function (getIndexesRes) {\n    db.constructor.emit('debug', ['find', 'planning query', requestDef]);\n    var queryPlan = planQuery(requestDef, getIndexesRes.indexes);\n    db.constructor.emit('debug', ['find', 'query plan', queryPlan]);\n    var indexToUse = queryPlan.index;\n    validateSort(requestDef, indexToUse);\n    var opts = assign({\n      include_docs: true,\n      reduce: false,\n      // Add amount of index for doAllDocs to use (related to issue #7810)\n      indexes_count: getIndexesRes.total_rows\n    }, queryPlan.queryOpts);\n    if ('startkey' in opts && 'endkey' in opts && collate(opts.startkey, opts.endkey) > 0) {\n      // can't possibly return any results, startkey > endkey\n      /* istanbul ignore next */\n      return {\n        docs: []\n      };\n    }\n    var isDescending = requestDef.sort && typeof requestDef.sort[0] !== 'string' && getValue(requestDef.sort[0]) === 'desc';\n    if (isDescending) {\n      // either all descending or all ascending\n      opts.descending = true;\n      opts = reverseOptions(opts);\n    }\n    if (!queryPlan.inMemoryFields.length) {\n      // no in-memory filtering necessary, so we can let the\n      // database do the limit/skip for us\n      if ('limit' in requestDef) {\n        opts.limit = requestDef.limit;\n      }\n      if ('skip' in requestDef) {\n        opts.skip = requestDef.skip;\n      }\n    }\n    if (explain) {\n      return Promise.resolve(queryPlan, opts);\n    }\n    return Promise.resolve().then(function () {\n      if (indexToUse.name === '_all_docs') {\n        return doAllDocs(db, opts);\n      } else {\n        var signature = indexToSignature(indexToUse);\n        return abstractMapper$1(db).query.call(db, signature, opts);\n      }\n    }).then(function (res) {\n      if (opts.inclusive_start === false) {\n        // may have to manually filter the first one,\n        // since couchdb has no true inclusive_start option\n        res.rows = filterInclusiveStart(res.rows, opts.startkey, indexToUse);\n      }\n      if (queryPlan.inMemoryFields.length) {\n        // need to filter some stuff in-memory\n        res.rows = filterInMemoryFields(res.rows, requestDef, queryPlan.inMemoryFields);\n      }\n      var resp = {\n        docs: res.rows.map(function (row) {\n          var doc = row.doc;\n          if (requestDef.fields) {\n            return pick(doc, requestDef.fields);\n          }\n          return doc;\n        })\n      };\n      if (indexToUse.defaultUsed) {\n        resp.warning = 'No matching index found, create an index to optimize query time.';\n      }\n      return resp;\n    });\n  });\n}\nfunction explain$1(db, requestDef) {\n  return find$1(db, requestDef, true).then(function (queryPlan) {\n    return {\n      dbname: db.name,\n      index: queryPlan.index,\n      selector: requestDef.selector,\n      range: {\n        start_key: queryPlan.queryOpts.startkey,\n        end_key: queryPlan.queryOpts.endkey\n      },\n      opts: {\n        use_index: requestDef.use_index || [],\n        bookmark: \"nil\",\n        //hardcoded to match CouchDB since its not supported,\n        limit: requestDef.limit,\n        skip: requestDef.skip,\n        sort: requestDef.sort || {},\n        fields: requestDef.fields,\n        conflicts: false,\n        //hardcoded to match CouchDB since its not supported,\n        r: [49] // hardcoded to match CouchDB since its not support\n      },\n\n      limit: requestDef.limit,\n      skip: requestDef.skip || 0,\n      fields: requestDef.fields\n    };\n  });\n}\nfunction deleteIndex$1(db, index) {\n  if (!index.ddoc) {\n    throw new Error('you must supply an index.ddoc when deleting');\n  }\n  if (!index.name) {\n    throw new Error('you must supply an index.name when deleting');\n  }\n  var docId = index.ddoc;\n  var viewName = index.name;\n  function deltaFun(doc) {\n    if (Object.keys(doc.views).length === 1 && doc.views[viewName]) {\n      // only one view in this ddoc, delete the whole ddoc\n      return {\n        _id: docId,\n        _deleted: true\n      };\n    }\n    // more than one view here, just remove the view\n    delete doc.views[viewName];\n    return doc;\n  }\n  return upsert(db, docId, deltaFun).then(function () {\n    return abstractMapper$1(db).viewCleanup.apply(db);\n  }).then(function () {\n    return {\n      ok: true\n    };\n  });\n}\nvar createIndexAsCallback = callbackify(createIndex$1);\nvar findAsCallback = callbackify(find$1);\nvar explainAsCallback = callbackify(explain$1);\nvar getIndexesAsCallback = callbackify(getIndexes$1);\nvar deleteIndexAsCallback = callbackify(deleteIndex$1);\nvar plugin = {};\nplugin.createIndex = toPromise(function (requestDef, callback) {\n  if (typeof requestDef !== 'object') {\n    return callback(new Error('you must provide an index to create'));\n  }\n  var createIndex$$1 = isRemote(this) ? createIndex : createIndexAsCallback;\n  createIndex$$1(this, requestDef, callback);\n});\nplugin.find = toPromise(function (requestDef, callback) {\n  if (typeof callback === 'undefined') {\n    callback = requestDef;\n    requestDef = undefined;\n  }\n  if (typeof requestDef !== 'object') {\n    return callback(new Error('you must provide search parameters to find()'));\n  }\n  var find$$1 = isRemote(this) ? find : findAsCallback;\n  find$$1(this, requestDef, callback);\n});\nplugin.explain = toPromise(function (requestDef, callback) {\n  if (typeof callback === 'undefined') {\n    callback = requestDef;\n    requestDef = undefined;\n  }\n  if (typeof requestDef !== 'object') {\n    return callback(new Error('you must provide search parameters to explain()'));\n  }\n  var find$$1 = isRemote(this) ? explain : explainAsCallback;\n  find$$1(this, requestDef, callback);\n});\nplugin.getIndexes = toPromise(function (callback) {\n  var getIndexes$$1 = isRemote(this) ? getIndexes : getIndexesAsCallback;\n  getIndexes$$1(this, callback);\n});\nplugin.deleteIndex = toPromise(function (indexDef, callback) {\n  if (typeof indexDef !== 'object') {\n    return callback(new Error('you must provide an index to delete'));\n  }\n  var deleteIndex$$1 = isRemote(this) ? deleteIndex : deleteIndexAsCallback;\n  deleteIndex$$1(this, indexDef, callback);\n});\nexport default plugin;","map":{"version":3,"names":["generateErrorFromResponse","Headers","abstractMapReduce","stringMd5","collate","getFieldFromDoc","setFieldInDoc","parseField","matchesSelector","getKey","getValue","compare","massageSelector","filterInMemoryFields","clone","assign","nextTick","upsert","toPromise","isRemote","massageCreateIndexRequest","requestDef","index","forEach","key","fields","type","checkFieldValueType","name","value","isHttp","message","received","addReceived","indexOf","Array","isArray","length","divisor","mod","parseInt","allowed","allowedStr","slice","join","console","log","RegExp","receivedStr","JSON","stringify","Error","requireValidation","arrayTypeComparisonOperators","equalityOperators","validateSelector","input","entry","Object","keys","i","dbFetch","db","path","opts","callback","status","ok","headers","fetch","then","response","json","err","catch","createIndex","method","body","find","selector","explain","getIndexes","deleteIndex","indexDef","ddoc","url","map","encodeURIComponent","getArguments","fun","len","arguments","args","call","callbackify","cb","pop","promise","apply","promisedCallback","res","reason","flatten","subArr","concat","push","mergeObjects","arr","pick","obj","parsedField","oneArrayIsSubArrayOfOther","left","right","Math","min","oneArrayIsStrictSubArrayOfOther","oneSetIsSubArrayOfOther","field","leftIdx","splice","arrayToObject","max","maxScore","element","score","arrayEquals","arr1","arr2","uniq","substring","createDeepMultiMapper","emit","doc","toEmit","iLen","j","jLen","createDeepSingleMapper","createShallowSingleMapper","createShallowMultiMapper","checkShallow","createMapper","isShallow","isSingle","mapper","mapFunDef","partialSelector","partial_filter_selector","reducer","ddocValidator","viewName","view","views","_id","abstractMapper","abstractMapper$1","_customFindAbstractMapper","massageSort","sort","sorting","massageUseIndex","useIndex","cleanedUseIndex","replace","massageIndexDef","getKeyFromDoc","def","filterInclusiveStart","rows","targetValue","indexFields","row","docKey","abs","reverseOptions","newOpts","startkey","endkey","inclusive_start","inclusive_end","validateIndex","ascFields","filter","validateSort","defaultUsed","noneIdSorts","sortItem","validateFindRequest","getUserFields","selectorFields","sortFields","userFields","Number","MAX_VALUE","rightIdx","sortOrder","createIndex$1","originalIndexDef","md5","getMd5","ddocName","ddocId","hasInvalidLanguage","viewExists","updateDdoc","_rev","language","reduce","options","constructor","signature","query","limit","id","result","getIndexes$1","allDocs","include_docs","allDocsRes","indexes","viewNames","undefined","total_rows","COLLATE_LO","COLLATE_HI","SHORT_CIRCUIT_QUERY","queryOpts","inMemoryFields","checkFieldInIndex","indexField","userOperatorLosesPrecision","matcher","userOperator","sortFieldsByIndex","a","b","aIdx","bIdx","getBasicInMemoryFields","needToFilterInMemory","getInMemoryFieldsFromNe","operator","getInMemoryFields","coreInMemoryFields","checkIndexFieldsMatch","sortMatches","selectorMatches","logicalMatchers","isNonLogicalMatcher","checkFieldsLogicallySound","firstField","isInvalidNe","checkIndexMatches","fieldsMatch","findMatchingIndexes","findBestMatchingIndex","matchingIndexes","error","defaultIndex","userFieldsMap","scoreIndex","useIndexDdoc","useIndexName","getSingleFieldQueryOptsFor","userValue","getSingleFieldCoreQueryPlan","userOperators","combinedOpts","newQueryOpts","getMultiFieldCoreQueryPlan","getMultiFieldQueryOpts","inclusiveStart","inclusiveEnd","finish","some","usingGtlt","previousKeys","previousWasEq","previousWasSame","gtltLostSpecificity","shouldShortCircuit","values","val","getDefaultQueryPlan","getCoreQueryPlan","planQuery","request","userFieldsRes","use_index","coreQueryPlan","indexToSignature","doAllDocs","originalOpts","descending","indexes_count","original_limit","test","find$1","getIndexesRes","queryPlan","indexToUse","docs","isDescending","skip","Promise","resolve","resp","warning","explain$1","dbname","range","start_key","end_key","bookmark","conflicts","r","deleteIndex$1","docId","deltaFun","_deleted","viewCleanup","createIndexAsCallback","findAsCallback","explainAsCallback","getIndexesAsCallback","deleteIndexAsCallback","plugin","createIndex$$1","find$$1","getIndexes$$1","deleteIndex$$1"],"sources":["/home/sol/Documentos/AUS/3ro segundo cuatri/ing 2/URV/node_modules/pouchdb-find/lib/index-browser.es.js"],"sourcesContent":["import { generateErrorFromResponse } from 'pouchdb-errors';\nimport { Headers } from 'pouchdb-fetch';\nimport abstractMapReduce from 'pouchdb-abstract-mapreduce';\nimport { stringMd5 } from 'pouchdb-md5';\nimport { collate } from 'pouchdb-collate';\nimport { getFieldFromDoc, setFieldInDoc, parseField, matchesSelector, getKey, getValue, compare, massageSelector, filterInMemoryFields } from 'pouchdb-selector-core';\nimport { clone, assign, nextTick, upsert, toPromise, isRemote } from 'pouchdb-utils';\n\n// we restucture the supplied JSON considerably, because the official\n// Mango API is very particular about a lot of this stuff, but we like\n// to be liberal with what we accept in order to prevent mental\n// breakdowns in our users\nfunction massageCreateIndexRequest(requestDef) {\n  requestDef = clone(requestDef);\n\n  if (!requestDef.index) {\n    requestDef.index = {};\n  }\n\n  ['type', 'name', 'ddoc'].forEach(function (key) {\n    if (requestDef.index[key]) {\n      requestDef[key] = requestDef.index[key];\n      delete requestDef.index[key];\n    }\n  });\n\n  if (requestDef.fields) {\n    requestDef.index.fields = requestDef.fields;\n    delete requestDef.fields;\n  }\n\n  if (!requestDef.type) {\n    requestDef.type = 'json';\n  }\n  return requestDef;\n}\n\n// throws if the user is using the wrong query field value type\nfunction checkFieldValueType(name, value, isHttp) {\n\tvar message = '';\n\tvar received = value;\n\tvar addReceived = true;\n\tif ([ '$in', '$nin', '$or', '$and', '$mod', '$nor', '$all' ].indexOf(name) !== -1) {\n\t\tif (!Array.isArray(value)) {\n\t\t\tmessage = 'Query operator ' + name + ' must be an array.';\n\n\t\t}\n\t}\n\n\tif ([ '$not', '$elemMatch', '$allMatch' ].indexOf(name) !== -1) {\n\t\tif (!(!Array.isArray(value) && typeof value === 'object' && value !== null)) {\n\t\t\tmessage = 'Query operator ' + name + ' must be an object.';\n\t\t}\n\t}\n\n\tif (name === '$mod' && Array.isArray(value)) {\n\t\tif (value.length !== 2) {\n\t\t\tmessage = 'Query operator $mod must be in the format [divisor, remainder], ' +\n\t\t\t\t'where divisor and remainder are both integers.';\n\t\t} else {\n\t\t\tvar divisor = value[0];\n\t\t\tvar mod = value[1];\n\t\t\tif (divisor === 0) {\n\t\t\t\tmessage = 'Query operator $mod\\'s divisor cannot be 0, cannot divide by zero.';\n\t\t\t\taddReceived = false;\n\t\t\t}\n\t\t\tif (typeof divisor !== 'number' || parseInt(divisor, 10) !== divisor) {\n\t\t\t\tmessage = 'Query operator $mod\\'s divisor is not an integer.';\n\t\t\t\treceived = divisor;\n\t\t\t}\n\t\t\tif (parseInt(mod, 10) !== mod) {\n\t\t\t\tmessage = 'Query operator $mod\\'s remainder is not an integer.';\n\t\t\t\treceived = mod;\n\t\t\t}\n\t\t}\n\t}\n\tif (name === '$exists') {\n\t\tif (typeof value !== 'boolean') {\n\t\t\tmessage = 'Query operator $exists must be a boolean.';\n\t\t}\n\t}\n\n\tif (name === '$type') {\n\t\tvar allowed = [ 'null', 'boolean', 'number', 'string', 'array', 'object' ];\n\t\tvar allowedStr = '\"' + allowed.slice(0, allowed.length - 1).join('\", \"') + '\", or \"' + allowed[allowed.length - 1] + '\"';\n\t\tif (typeof value !== 'string') {\n\t\t\tmessage = 'Query operator $type must be a string. Supported values: ' + allowedStr + '.';\n\t\t} else if (allowed.indexOf(value) == -1) {\n\t\t\tmessage = 'Query operator $type must be a string. Supported values: ' + allowedStr + '.';\n\t\t}\n\t}\n\n\tif (name === '$size') {\n\t\tif (parseInt(value, 10) !== value) {\n\t\t\tmessage = 'Query operator $size must be a integer.';\n\t\t}\n\t}\n\n\tif (name === '$regex') {\n\t\tif (typeof value !== 'string') {\n\t\t\tconsole.log(\"here\", isHttp);\n\t\t\tif (isHttp) {\n\t\t\t\tmessage = 'Query operator $regex must be a string.';\n\t\t\t} else if (!(value instanceof RegExp)) {\n\t\t\t\tmessage = 'Query operator $regex must be a string or an instance ' +\n\t\t\t\t\t'of a javascript regular expression.';\n\t\t\t}\n\t\t}\n\t}\n\n\tif (message) {\n\t\tif (addReceived) {\n\n\t\t\tvar type = received === null\n\t\t\t? ' '\n\t\t\t: Array.isArray(received)\n\t\t\t? ' array'\n\t\t\t: ' ' + typeof received;\n\t\t\tvar receivedStr = typeof received === 'object' && received !== null\n\t\t\t?  JSON.stringify(received, null, '\\t')\n\t\t\t: received;\n\n\t\t\tmessage += ' Received' + type + ': ' + receivedStr;\n\t\t}\n\t\tthrow new Error(message);\n\t}\n}\n\n\nvar requireValidation = [ '$all', '$allMatch', '$and', '$elemMatch', '$exists', '$in', '$mod', '$nin', '$nor', '$not', '$or', '$regex', '$size', '$type' ];\n\nvar arrayTypeComparisonOperators = [ '$in', '$nin', '$mod', '$all'];\n\nvar equalityOperators = [ '$eq', '$gt', '$gte', '$lt', '$lte' ];\n\n// recursively walks down the a query selector validating any operators\nfunction validateSelector(input, isHttp) {\n\tif (Array.isArray(input)) {\n\t\tfor (var entry of input) {\n\t\t\tif (typeof entry === 'object' && value !== null) {\n\t\t\t\tvalidateSelector(entry, isHttp);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tvar fields = Object.keys(input);\n\n\t\tfor (var i = 0; i < fields.length; i++) {\n\t\t\tvar key = fields[i];\n\t\t\tvar value = input[key];\n\n\t\t\tif (requireValidation.indexOf(key) !== -1) {\n\t\t\t\tcheckFieldValueType(key, value, isHttp);\n\t\t\t}\n\t\t\tif (equalityOperators.indexOf(key) !== -1) {\n\t\t\t\t// skip, explicit comparison operators can be anything\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (arrayTypeComparisonOperators.indexOf(key) !== -1) {\n\t\t\t\t// skip, their values are already valid\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (typeof value === 'object' && value !== null) {\n\t\t\t\tvalidateSelector(value, isHttp);\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction dbFetch(db, path, opts, callback) {\n  var status, ok;\n  opts.headers = new Headers({'Content-type': 'application/json'});\n  db.fetch(path, opts).then(function (response) {\n    status = response.status;\n    ok = response.ok;\n    return response.json();\n  }).then(function (json) {\n    if (!ok) {\n      json.status = status;\n      var err = generateErrorFromResponse(json);\n      callback(err);\n    } else {\n      callback(null, json);\n    }\n  }).catch(callback);\n}\n\nfunction createIndex(db, requestDef, callback) {\n  requestDef = massageCreateIndexRequest(requestDef);\n  dbFetch(db, '_index', {\n    method: 'POST',\n    body: JSON.stringify(requestDef)\n  }, callback);\n}\n\nfunction find(db, requestDef, callback) {\n  validateSelector(requestDef.selector, true);\n  dbFetch(db, '_find', {\n    method: 'POST',\n    body: JSON.stringify(requestDef)\n  }, callback);\n}\n\nfunction explain(db, requestDef, callback) {\n  dbFetch(db, '_explain', {\n    method: 'POST',\n    body: JSON.stringify(requestDef)\n  }, callback);\n}\n\nfunction getIndexes(db, callback) {\n  dbFetch(db, '_index', {\n    method: 'GET'\n  }, callback);\n}\n\nfunction deleteIndex(db, indexDef, callback) {\n\n\n  var ddoc = indexDef.ddoc;\n  var type = indexDef.type || 'json';\n  var name = indexDef.name;\n\n  if (!ddoc) {\n    return callback(new Error('you must provide an index\\'s ddoc'));\n  }\n\n  if (!name) {\n    return callback(new Error('you must provide an index\\'s name'));\n  }\n\n  var url = '_index/' + [ddoc, type, name].map(encodeURIComponent).join('/');\n\n  dbFetch(db, url, {method: 'DELETE'}, callback);\n}\n\nfunction getArguments(fun) {\n  return function () {\n    var len = arguments.length;\n    var args = new Array(len);\n    var i = -1;\n    while (++i < len) {\n      args[i] = arguments[i];\n    }\n    return fun.call(this, args);\n  };\n}\n\nfunction callbackify(fun) {\n  return getArguments(function (args) {\n    var cb = args.pop();\n    var promise = fun.apply(this, args);\n    promisedCallback(promise, cb);\n    return promise;\n  });\n}\n\nfunction promisedCallback(promise, callback) {\n  promise.then(function (res) {\n    nextTick(function () {\n      callback(null, res);\n    });\n  }, function (reason) {\n    nextTick(function () {\n      callback(reason);\n    });\n  });\n  return promise;\n}\n\nvar flatten = getArguments(function (args) {\n  var res = [];\n  for (var i = 0, len = args.length; i < len; i++) {\n    var subArr = args[i];\n    if (Array.isArray(subArr)) {\n      res = res.concat(flatten.apply(null, subArr));\n    } else {\n      res.push(subArr);\n    }\n  }\n  return res;\n});\n\nfunction mergeObjects(arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    res = assign(res, arr[i]);\n  }\n  return res;\n}\n\n// Selects a list of fields defined in dot notation from one doc\n// and copies them to a new doc. Like underscore _.pick but supports nesting.\nfunction pick(obj, arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var parsedField = parseField(arr[i]);\n    var value = getFieldFromDoc(obj, parsedField);\n    if (typeof value !== 'undefined') {\n      setFieldInDoc(res, parsedField, value);\n    }\n  }\n  return res;\n}\n\n// e.g. ['a'], ['a', 'b'] is true, but ['b'], ['a', 'b'] is false\nfunction oneArrayIsSubArrayOfOther(left, right) {\n\n  for (var i = 0, len = Math.min(left.length, right.length); i < len; i++) {\n    if (left[i] !== right[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// e.g.['a', 'b', 'c'], ['a', 'b'] is false\nfunction oneArrayIsStrictSubArrayOfOther(left, right) {\n\n  if (left.length > right.length) {\n    return false;\n  }\n\n  return oneArrayIsSubArrayOfOther(left, right);\n}\n\n// same as above, but treat the left array as an unordered set\n// e.g. ['b', 'a'], ['a', 'b', 'c'] is true, but ['c'], ['a', 'b', 'c'] is false\nfunction oneSetIsSubArrayOfOther(left, right) {\n  left = left.slice();\n  for (var i = 0, len = right.length; i < len; i++) {\n    var field = right[i];\n    if (!left.length) {\n      break;\n    }\n    var leftIdx = left.indexOf(field);\n    if (leftIdx === -1) {\n      return false;\n    } else {\n      left.splice(leftIdx, 1);\n    }\n  }\n  return true;\n}\n\nfunction arrayToObject(arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    res[arr[i]] = true;\n  }\n  return res;\n}\n\nfunction max(arr, fun) {\n  var max = null;\n  var maxScore = -1;\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var element = arr[i];\n    var score = fun(element);\n    if (score > maxScore) {\n      maxScore = score;\n      max = element;\n    }\n  }\n  return max;\n}\n\nfunction arrayEquals(arr1, arr2) {\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n  for (var i = 0, len = arr1.length; i < len; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction uniq(arr) {\n  var obj = {};\n  for (var i = 0; i < arr.length; i++) {\n    obj['$' + arr[i]] = true;\n  }\n  return Object.keys(obj).map(function (key) {\n    return key.substring(1);\n  });\n}\n\n//\n// One thing about these mappers:\n//\n// Per the advice of John-David Dalton (http://youtu.be/NthmeLEhDDM),\n// what you want to do in this case is optimize for the smallest possible\n// function, since that's the thing that gets run over and over again.\n//\n// This code would be a lot simpler if all the if/elses were inside\n// the function, but it would also be a lot less performant.\n//\n\n\nfunction createDeepMultiMapper(fields, emit, selector) {\n  return function (doc) {\n    if (selector && !matchesSelector(doc, selector)) { return; }\n    var toEmit = [];\n    for (var i = 0, iLen = fields.length; i < iLen; i++) {\n      var parsedField = parseField(fields[i]);\n      var value = doc;\n      for (var j = 0, jLen = parsedField.length; j < jLen; j++) {\n        var key = parsedField[j];\n        value = value[key];\n        if (typeof value === 'undefined') {\n          return; // don't emit\n        }\n      }\n      toEmit.push(value);\n    }\n    emit(toEmit);\n  };\n}\n\nfunction createDeepSingleMapper(field, emit, selector) {\n  var parsedField = parseField(field);\n  return function (doc) {\n    if (selector && !matchesSelector(doc, selector)) { return; }\n    var value = doc;\n    for (var i = 0, len = parsedField.length; i < len; i++) {\n      var key = parsedField[i];\n      value = value[key];\n      if (typeof value === 'undefined') {\n        return; // do nothing\n      }\n    }\n    emit(value);\n  };\n}\n\nfunction createShallowSingleMapper(field, emit, selector) {\n  return function (doc) {\n    if (selector && !matchesSelector(doc, selector)) { return; }\n    emit(doc[field]);\n  };\n}\n\nfunction createShallowMultiMapper(fields, emit, selector) {\n  return function (doc) {\n    if (selector && !matchesSelector(doc, selector)) { return; }\n    var toEmit = [];\n    for (var i = 0, len = fields.length; i < len; i++) {\n      toEmit.push(doc[fields[i]]);\n    }\n    emit(toEmit);\n  };\n}\n\nfunction checkShallow(fields) {\n  for (var i = 0, len = fields.length; i < len; i++) {\n    var field = fields[i];\n    if (field.indexOf('.') !== -1) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction createMapper(fields, emit, selector) {\n  var isShallow = checkShallow(fields);\n  var isSingle = fields.length === 1;\n\n  // notice we try to optimize for the most common case,\n  // i.e. single shallow indexes\n  if (isShallow) {\n    if (isSingle) {\n      return createShallowSingleMapper(fields[0], emit, selector);\n    } else { // multi\n      return createShallowMultiMapper(fields, emit, selector);\n    }\n  } else { // deep\n    if (isSingle) {\n      return createDeepSingleMapper(fields[0], emit, selector);\n    } else { // multi\n      return createDeepMultiMapper(fields, emit, selector);\n    }\n  }\n}\n\nfunction mapper(mapFunDef, emit) {\n  // mapFunDef is a list of fields\n\n  const fields = Object.keys(mapFunDef.fields);\n  const partialSelector = mapFunDef.partial_filter_selector;\n\n  return createMapper(fields, emit, partialSelector);\n}\n\n/* istanbul ignore next */\nfunction reducer(/*reduceFunDef*/) {\n  throw new Error('reduce not supported');\n}\n\nfunction ddocValidator(ddoc, viewName) {\n  var view = ddoc.views[viewName];\n  // This doesn't actually need to be here apparently, but\n  // I feel safer keeping it.\n  /* istanbul ignore if */\n  if (!view.map || !view.map.fields) {\n    throw new Error('ddoc ' + ddoc._id +' with view ' + viewName +\n      ' doesn\\'t have map.fields defined. ' +\n      'maybe it wasn\\'t created by this plugin?');\n  }\n}\n\nvar abstractMapper = abstractMapReduce(\n  /* localDocName */ 'indexes',\n  mapper,\n  reducer,\n  ddocValidator\n);\n\nfunction abstractMapper$1 (db) {\n  return db._customFindAbstractMapper || abstractMapper;\n}\n\n// normalize the \"sort\" value\nfunction massageSort(sort) {\n  if (!Array.isArray(sort)) {\n    throw new Error('invalid sort json - should be an array');\n  }\n  return sort.map(function (sorting) {\n    if (typeof sorting === 'string') {\n      var obj = {};\n      obj[sorting] = 'asc';\n      return obj;\n    } else {\n      return sorting;\n    }\n  });\n}\n\nfunction massageUseIndex(useIndex) {\n  var cleanedUseIndex = [];\n  if (typeof useIndex === 'string') {\n    cleanedUseIndex.push(useIndex);\n  } else {\n    cleanedUseIndex = useIndex;\n  }\n\n  return cleanedUseIndex.map(function (name) {\n    return name.replace('_design/', '');\n  });\n}\n\nfunction massageIndexDef(indexDef) {\n  indexDef.fields = indexDef.fields.map(function (field) {\n    if (typeof field === 'string') {\n      var obj = {};\n      obj[field] = 'asc';\n      return obj;\n    }\n    return field;\n  });\n  return indexDef;\n}\n\nfunction getKeyFromDoc(doc, index) {\n  var res = [];\n  for (var i = 0; i < index.def.fields.length; i++) {\n    var field = getKey(index.def.fields[i]);\n    res.push(doc[field]);\n  }\n  return res;\n}\n\n// have to do this manually because REASONS. I don't know why\n// CouchDB didn't implement inclusive_start\nfunction filterInclusiveStart(rows, targetValue, index) {\n  var indexFields = index.def.fields;\n  for (var i = 0, len = rows.length; i < len; i++) {\n    var row = rows[i];\n\n    // shave off any docs at the beginning that are <= the\n    // target value\n\n    var docKey = getKeyFromDoc(row.doc, index);\n    if (indexFields.length === 1) {\n      docKey = docKey[0]; // only one field, not multi-field\n    } else { // more than one field in index\n      // in the case where e.g. the user is searching {$gt: {a: 1}}\n      // but the index is [a, b], then we need to shorten the doc key\n      while (docKey.length > targetValue.length) {\n        docKey.pop();\n      }\n    }\n    //ABS as we just looking for values that don't match\n    if (Math.abs(collate(docKey, targetValue)) > 0) {\n      // no need to filter any further; we're past the key\n      break;\n    }\n  }\n  return i > 0 ? rows.slice(i) : rows;\n}\n\nfunction reverseOptions(opts) {\n  var newOpts = clone(opts);\n  delete newOpts.startkey;\n  delete newOpts.endkey;\n  delete newOpts.inclusive_start;\n  delete newOpts.inclusive_end;\n\n  if ('endkey' in opts) {\n    newOpts.startkey = opts.endkey;\n  }\n  if ('startkey' in opts) {\n    newOpts.endkey = opts.startkey;\n  }\n  if ('inclusive_start' in opts) {\n    newOpts.inclusive_end = opts.inclusive_start;\n  }\n  if ('inclusive_end' in opts) {\n    newOpts.inclusive_start = opts.inclusive_end;\n  }\n  return newOpts;\n}\n\nfunction validateIndex(index) {\n  var ascFields = index.fields.filter(function (field) {\n    return getValue(field) === 'asc';\n  });\n  if (ascFields.length !== 0 && ascFields.length !== index.fields.length) {\n    throw new Error('unsupported mixed sorting');\n  }\n}\n\nfunction validateSort(requestDef, index) {\n  if (index.defaultUsed && requestDef.sort) {\n    var noneIdSorts = requestDef.sort.filter(function (sortItem) {\n      return Object.keys(sortItem)[0] !== '_id';\n    }).map(function (sortItem) {\n      return Object.keys(sortItem)[0];\n    });\n\n    if (noneIdSorts.length > 0) {\n      throw new Error('Cannot sort on field(s) \"' + noneIdSorts.join(',') +\n      '\" when using the default index');\n    }\n  }\n\n  if (index.defaultUsed) {\n    return;\n  }\n}\n\nfunction validateFindRequest(requestDef) {\n  if (typeof requestDef.selector !== 'object') {\n    throw new Error('you must provide a selector when you find()');\n  }\n\n  /*var selectors = requestDef.selector['$and'] || [requestDef.selector];\n  for (var i = 0; i < selectors.length; i++) {\n    var selector = selectors[i];\n    var keys = Object.keys(selector);\n    if (keys.length === 0) {\n      throw new Error('invalid empty selector');\n    }\n    //var selection = selector[keys[0]];\n    /*if (Object.keys(selection).length !== 1) {\n      throw new Error('invalid selector: ' + JSON.stringify(selection) +\n        ' - it must have exactly one key/value');\n    }\n  }*/\n}\n\n// determine the maximum number of fields\n// we're going to need to query, e.g. if the user\n// has selection ['a'] and sorting ['a', 'b'], then we\n// need to use the longer of the two: ['a', 'b']\nfunction getUserFields(selector, sort) {\n  var selectorFields = Object.keys(selector);\n  var sortFields = sort? sort.map(getKey) : [];\n  var userFields;\n  if (selectorFields.length >= sortFields.length) {\n    userFields = selectorFields;\n  } else {\n    userFields = sortFields;\n  }\n\n  if (sortFields.length === 0) {\n    return {\n      fields: userFields\n    };\n  }\n\n  // sort according to the user's preferred sorting\n  userFields = userFields.sort(function (left, right) {\n    var leftIdx = sortFields.indexOf(left);\n    if (leftIdx === -1) {\n      leftIdx = Number.MAX_VALUE;\n    }\n    var rightIdx = sortFields.indexOf(right);\n    if (rightIdx === -1) {\n      rightIdx = Number.MAX_VALUE;\n    }\n    return leftIdx < rightIdx ? -1 : leftIdx > rightIdx ? 1 : 0;\n  });\n\n  return {\n    fields: userFields,\n    sortOrder: sort.map(getKey)\n  };\n}\n\nfunction createIndex$1(db, requestDef) {\n  requestDef = massageCreateIndexRequest(requestDef);\n  var originalIndexDef = clone(requestDef.index);\n  requestDef.index = massageIndexDef(requestDef.index);\n\n  validateIndex(requestDef.index);\n\n  // calculating md5 is expensive - memoize and only\n  // run if required\n  var md5;\n  function getMd5() {\n    return md5 || (md5 = stringMd5(JSON.stringify(requestDef)));\n  }\n\n  var viewName = requestDef.name || ('idx-' + getMd5());\n\n  var ddocName = requestDef.ddoc || ('idx-' + getMd5());\n  var ddocId = '_design/' + ddocName;\n\n  var hasInvalidLanguage = false;\n  var viewExists = false;\n\n  function updateDdoc(doc) {\n    if (doc._rev && doc.language !== 'query') {\n      hasInvalidLanguage = true;\n    }\n    doc.language = 'query';\n    doc.views = doc.views || {};\n\n    viewExists = !!doc.views[viewName];\n\n    if (viewExists) {\n      return false;\n    }\n\n    doc.views[viewName] = {\n      map: {\n        fields: mergeObjects(requestDef.index.fields)\n      },\n      reduce: '_count',\n      options: {\n        def: originalIndexDef\n      }\n    };\n\n    return doc;\n  }\n\n  db.constructor.emit('debug', ['find', 'creating index', ddocId]);\n\n  return upsert(db, ddocId, updateDdoc).then(function () {\n    if (hasInvalidLanguage) {\n      throw new Error('invalid language for ddoc with id \"' +\n      ddocId +\n      '\" (should be \"query\")');\n    }\n  }).then(function () {\n    // kick off a build\n    // TODO: abstract-pouchdb-mapreduce should support auto-updating\n    // TODO: should also use update_after, but pouchdb/pouchdb#3415 blocks me\n    var signature = ddocName + '/' + viewName;\n    return abstractMapper$1(db).query.call(db, signature, {\n      limit: 0,\n      reduce: false\n    }).then(function () {\n      return {\n        id: ddocId,\n        name: viewName,\n        result: viewExists ? 'exists' : 'created'\n      };\n    });\n  });\n}\n\nfunction getIndexes$1(db) {\n  // just search through all the design docs and filter in-memory.\n  // hopefully there aren't that many ddocs.\n  return db.allDocs({\n    startkey: '_design/',\n    endkey: '_design/\\uffff',\n    include_docs: true\n  }).then(function (allDocsRes) {\n    var res = {\n      indexes: [{\n        ddoc: null,\n        name: '_all_docs',\n        type: 'special',\n        def: {\n          fields: [{_id: 'asc'}]\n        }\n      }]\n    };\n\n    res.indexes = flatten(res.indexes, allDocsRes.rows.filter(function (row) {\n      return row.doc.language === 'query';\n    }).map(function (row) {\n      var viewNames = row.doc.views !== undefined ? Object.keys(row.doc.views) : [];\n\n      return viewNames.map(function (viewName) {\n        var view = row.doc.views[viewName];\n        return {\n          ddoc: row.id,\n          name: viewName,\n          type: 'json',\n          def: massageIndexDef(view.options.def)\n        };\n      });\n    }));\n\n    // these are sorted by view name for some reason\n    res.indexes.sort(function (left, right) {\n      return compare(left.name, right.name);\n    });\n    res.total_rows = res.indexes.length;\n    return res;\n  });\n}\n\n// couchdb lowest collation value\nvar COLLATE_LO = null;\n\n// couchdb highest collation value (TODO: well not really, but close enough amirite)\nvar COLLATE_HI = {\"\\uffff\": {}};\n\nconst SHORT_CIRCUIT_QUERY = {\n  queryOpts: { limit: 0, startkey: COLLATE_HI, endkey: COLLATE_LO },\n  inMemoryFields: [],\n};\n\n// couchdb second-lowest collation value\n\nfunction checkFieldInIndex(index, field) {\n  var indexFields = index.def.fields.map(getKey);\n  for (var i = 0, len = indexFields.length; i < len; i++) {\n    var indexField = indexFields[i];\n    if (field === indexField) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// so when you do e.g. $eq/$eq, we can do it entirely in the database.\n// but when you do e.g. $gt/$eq, the first part can be done\n// in the database, but the second part has to be done in-memory,\n// because $gt has forced us to lose precision.\n// so that's what this determines\nfunction userOperatorLosesPrecision(selector, field) {\n  var matcher = selector[field];\n  var userOperator = getKey(matcher);\n\n  return userOperator !== '$eq';\n}\n\n// sort the user fields by their position in the index,\n// if they're in the index\nfunction sortFieldsByIndex(userFields, index) {\n  var indexFields = index.def.fields.map(getKey);\n\n  return userFields.slice().sort(function (a, b) {\n    var aIdx = indexFields.indexOf(a);\n    var bIdx = indexFields.indexOf(b);\n    if (aIdx === -1) {\n      aIdx = Number.MAX_VALUE;\n    }\n    if (bIdx === -1) {\n      bIdx = Number.MAX_VALUE;\n    }\n    return compare(aIdx, bIdx);\n  });\n}\n\n// first pass to try to find fields that will need to be sorted in-memory\nfunction getBasicInMemoryFields(index, selector, userFields) {\n\n  userFields = sortFieldsByIndex(userFields, index);\n\n  // check if any of the user selectors lose precision\n  var needToFilterInMemory = false;\n  for (var i = 0, len = userFields.length; i < len; i++) {\n    var field = userFields[i];\n    if (needToFilterInMemory || !checkFieldInIndex(index, field)) {\n      return userFields.slice(i);\n    }\n    if (i < len - 1 && userOperatorLosesPrecision(selector, field)) {\n      needToFilterInMemory = true;\n    }\n  }\n  return [];\n}\n\nfunction getInMemoryFieldsFromNe(selector) {\n  var fields = [];\n  Object.keys(selector).forEach(function (field) {\n    var matcher = selector[field];\n    Object.keys(matcher).forEach(function (operator) {\n      if (operator === '$ne') {\n        fields.push(field);\n      }\n    });\n  });\n  return fields;\n}\n\nfunction getInMemoryFields(coreInMemoryFields, index, selector, userFields) {\n  var result = flatten(\n    // in-memory fields reported as necessary by the query planner\n    coreInMemoryFields,\n    // combine with another pass that checks for any we may have missed\n    getBasicInMemoryFields(index, selector, userFields),\n    // combine with another pass that checks for $ne's\n    getInMemoryFieldsFromNe(selector)\n  );\n\n  return sortFieldsByIndex(uniq(result), index);\n}\n\n// check that at least one field in the user's query is represented\n// in the index. order matters in the case of sorts\nfunction checkIndexFieldsMatch(indexFields, sortOrder, fields) {\n  if (sortOrder) {\n    // array has to be a strict subarray of index array. furthermore,\n    // the sortOrder fields need to all be represented in the index\n    var sortMatches = oneArrayIsStrictSubArrayOfOther(sortOrder, indexFields);\n    var selectorMatches = oneArrayIsSubArrayOfOther(fields, indexFields);\n\n    return sortMatches && selectorMatches;\n  }\n\n  // all of the user's specified fields still need to be\n  // on the left side of the index array, although the order\n  // doesn't matter\n  return oneSetIsSubArrayOfOther(fields, indexFields);\n}\n\nvar logicalMatchers = ['$eq', '$gt', '$gte', '$lt', '$lte'];\nfunction isNonLogicalMatcher(matcher) {\n  return logicalMatchers.indexOf(matcher) === -1;\n}\n\n// check all the index fields for usages of '$ne'\n// e.g. if the user queries {foo: {$ne: 'foo'}, bar: {$eq: 'bar'}},\n// then we can neither use an index on ['foo'] nor an index on\n// ['foo', 'bar'], but we can use an index on ['bar'] or ['bar', 'foo']\nfunction checkFieldsLogicallySound(indexFields, selector) {\n  var firstField = indexFields[0];\n  var matcher = selector[firstField];\n\n  if (typeof matcher === 'undefined') {\n    /* istanbul ignore next */\n    return true;\n  }\n\n  var isInvalidNe = Object.keys(matcher).length === 1 &&\n    getKey(matcher) === '$ne';\n\n  return !isInvalidNe;\n}\n\nfunction checkIndexMatches(index, sortOrder, fields, selector) {\n\n  var indexFields = index.def.fields.map(getKey);\n\n  var fieldsMatch = checkIndexFieldsMatch(indexFields, sortOrder, fields);\n\n  if (!fieldsMatch) {\n    return false;\n  }\n\n  return checkFieldsLogicallySound(indexFields, selector);\n}\n\n//\n// the algorithm is very simple:\n// take all the fields the user supplies, and if those fields\n// are a strict subset of the fields in some index,\n// then use that index\n//\n//\nfunction findMatchingIndexes(selector, userFields, sortOrder, indexes) {\n  return indexes.filter(function (index) {\n    return checkIndexMatches(index, sortOrder, userFields, selector);\n  });\n}\n\n// find the best index, i.e. the one that matches the most fields\n// in the user's query\nfunction findBestMatchingIndex(selector, userFields, sortOrder, indexes, useIndex) {\n\n  var matchingIndexes = findMatchingIndexes(selector, userFields, sortOrder, indexes);\n\n  if (matchingIndexes.length === 0) {\n    if (useIndex) {\n      throw {\n        error: \"no_usable_index\",\n        message: \"There is no index available for this selector.\"\n      };\n    }\n    //return `all_docs` as a default index;\n    //I'm assuming that _all_docs is always first\n    var defaultIndex = indexes[0];\n    defaultIndex.defaultUsed = true;\n    return defaultIndex;\n  }\n  if (matchingIndexes.length === 1 && !useIndex) {\n    return matchingIndexes[0];\n  }\n\n  var userFieldsMap = arrayToObject(userFields);\n\n  function scoreIndex(index) {\n    var indexFields = index.def.fields.map(getKey);\n    var score = 0;\n    for (var i = 0, len = indexFields.length; i < len; i++) {\n      var indexField = indexFields[i];\n      if (userFieldsMap[indexField]) {\n        score++;\n      }\n    }\n    return score;\n  }\n\n  if (useIndex) {\n    var useIndexDdoc = '_design/' + useIndex[0];\n    var useIndexName = useIndex.length === 2 ? useIndex[1] : false;\n    var index = matchingIndexes.find(function (index) {\n      if (useIndexName && index.ddoc === useIndexDdoc && useIndexName === index.name) {\n        return true;\n      }\n\n      if (index.ddoc === useIndexDdoc) {\n        /* istanbul ignore next */\n        return true;\n      }\n\n      return false;\n    });\n\n    if (!index) {\n      throw {\n        error: \"unknown_error\",\n        message: \"Could not find that index or could not use that index for the query\"\n      };\n    }\n    return index;\n  }\n\n  return max(matchingIndexes, scoreIndex);\n}\n\nfunction getSingleFieldQueryOptsFor(userOperator, userValue) {\n  switch (userOperator) {\n    case '$eq':\n      return {key: userValue};\n    case '$lte':\n      return {endkey: userValue};\n    case '$gte':\n      return {startkey: userValue};\n    case '$lt':\n      return {\n        endkey: userValue,\n        inclusive_end: false\n      };\n    case '$gt':\n      return {\n        startkey: userValue,\n        inclusive_start: false\n      };\n  }\n\n  return {\n    startkey: COLLATE_LO\n  };\n}\n\nfunction getSingleFieldCoreQueryPlan(selector, index) {\n  var field = getKey(index.def.fields[0]);\n  //ignoring this because the test to exercise the branch is skipped at the moment\n  /* istanbul ignore next */\n  var matcher = selector[field] || {};\n  var inMemoryFields = [];\n\n  var userOperators = Object.keys(matcher);\n\n  var combinedOpts;\n\n  userOperators.forEach(function (userOperator) {\n\n    if (isNonLogicalMatcher(userOperator)) {\n      inMemoryFields.push(field);\n    }\n\n    var userValue = matcher[userOperator];\n\n    var newQueryOpts = getSingleFieldQueryOptsFor(userOperator, userValue);\n\n    if (combinedOpts) {\n      combinedOpts = mergeObjects([combinedOpts, newQueryOpts]);\n    } else {\n      combinedOpts = newQueryOpts;\n    }\n  });\n\n  return {\n    queryOpts: combinedOpts,\n    inMemoryFields: inMemoryFields\n  };\n}\n\nfunction getMultiFieldCoreQueryPlan(userOperator, userValue) {\n  switch (userOperator) {\n    case '$eq':\n      return {\n        startkey: userValue,\n        endkey: userValue\n      };\n    case '$lte':\n      return {\n        endkey: userValue\n      };\n    case '$gte':\n      return {\n        startkey: userValue\n      };\n    case '$lt':\n      return {\n        endkey: userValue,\n        inclusive_end: false\n      };\n    case '$gt':\n      return {\n        startkey: userValue,\n        inclusive_start: false\n      };\n  }\n}\n\nfunction getMultiFieldQueryOpts(selector, index) {\n\n  var indexFields = index.def.fields.map(getKey);\n\n  var inMemoryFields = [];\n  var startkey = [];\n  var endkey = [];\n  var inclusiveStart;\n  var inclusiveEnd;\n\n\n  function finish(i) {\n\n    if (inclusiveStart !== false) {\n      startkey.push(COLLATE_LO);\n    }\n    if (inclusiveEnd !== false) {\n      endkey.push(COLLATE_HI);\n    }\n    // keep track of the fields where we lost specificity,\n    // and therefore need to filter in-memory\n    inMemoryFields = indexFields.slice(i);\n  }\n\n  for (var i = 0, len = indexFields.length; i < len; i++) {\n    var indexField = indexFields[i];\n\n    var matcher = selector[indexField];\n\n    if (!matcher || !Object.keys(matcher).length) { // fewer fields in user query than in index\n      finish(i);\n      break;\n    } else if (Object.keys(matcher).some(isNonLogicalMatcher)) { // non-logical are ignored\n      finish(i);\n      break;\n    } else if (i > 0) {\n      var usingGtlt = (\n        '$gt' in matcher || '$gte' in matcher ||\n        '$lt' in matcher || '$lte' in matcher);\n      var previousKeys = Object.keys(selector[indexFields[i - 1]]);\n      var previousWasEq = arrayEquals(previousKeys, ['$eq']);\n      var previousWasSame = arrayEquals(previousKeys, Object.keys(matcher));\n      var gtltLostSpecificity = usingGtlt && !previousWasEq && !previousWasSame;\n      if (gtltLostSpecificity) {\n        finish(i);\n        break;\n      }\n    }\n\n    var userOperators = Object.keys(matcher);\n\n    var combinedOpts = null;\n\n    for (var j = 0; j < userOperators.length; j++) {\n      var userOperator = userOperators[j];\n      var userValue = matcher[userOperator];\n\n      var newOpts = getMultiFieldCoreQueryPlan(userOperator, userValue);\n\n      if (combinedOpts) {\n        combinedOpts = mergeObjects([combinedOpts, newOpts]);\n      } else {\n        combinedOpts = newOpts;\n      }\n    }\n\n    startkey.push('startkey' in combinedOpts ? combinedOpts.startkey : COLLATE_LO);\n    endkey.push('endkey' in combinedOpts ? combinedOpts.endkey : COLLATE_HI);\n    if ('inclusive_start' in combinedOpts) {\n      inclusiveStart = combinedOpts.inclusive_start;\n    }\n    if ('inclusive_end' in combinedOpts) {\n      inclusiveEnd = combinedOpts.inclusive_end;\n    }\n  }\n\n  var res = {\n    startkey: startkey,\n    endkey: endkey\n  };\n\n  if (typeof inclusiveStart !== 'undefined') {\n    res.inclusive_start = inclusiveStart;\n  }\n  if (typeof inclusiveEnd !== 'undefined') {\n    res.inclusive_end = inclusiveEnd;\n  }\n\n  return {\n    queryOpts: res,\n    inMemoryFields: inMemoryFields\n  };\n}\n\nfunction shouldShortCircuit(selector) {\n  // We have a field to select from, but not a valid value\n  // this should result in a short circuited query \n  // just like the http adapter (couchdb) and mongodb\n  // see tests for issue #7810\n  \n  // @todo Use 'Object.values' when Node.js v6 support is dropped.\n  const values = Object.keys(selector).map(function (key) {\n    return selector[key];\n  });\n  return values.some(function (val) { \n    return typeof val === 'object' && Object.keys(val).length === 0;\n});\n}\n\nfunction getDefaultQueryPlan(selector) {\n  //using default index, so all fields need to be done in memory\n  return {\n    queryOpts: {startkey: null},\n    inMemoryFields: [Object.keys(selector)]\n  };\n}\n\nfunction getCoreQueryPlan(selector, index) {\n  if (index.defaultUsed) {\n    return getDefaultQueryPlan(selector, index);\n  }\n\n  if (index.def.fields.length === 1) {\n    // one field in index, so the value was indexed as a singleton\n    return getSingleFieldCoreQueryPlan(selector, index);\n  }\n  // else index has multiple fields, so the value was indexed as an array\n  return getMultiFieldQueryOpts(selector, index);\n}\n\nfunction planQuery(request, indexes) {\n\n  var selector = request.selector;\n  var sort = request.sort;\n\n  if (shouldShortCircuit(selector)) {\n    return assign({}, SHORT_CIRCUIT_QUERY, { index: indexes[0] });\n  }\n\n  var userFieldsRes = getUserFields(selector, sort);\n\n  var userFields = userFieldsRes.fields;\n  var sortOrder = userFieldsRes.sortOrder;\n  var index = findBestMatchingIndex(selector, userFields, sortOrder, indexes, request.use_index);\n\n  var coreQueryPlan = getCoreQueryPlan(selector, index);\n  var queryOpts = coreQueryPlan.queryOpts;\n  var coreInMemoryFields = coreQueryPlan.inMemoryFields;\n\n  var inMemoryFields = getInMemoryFields(coreInMemoryFields, index, selector, userFields);\n\n  var res = {\n    queryOpts: queryOpts,\n    index: index,\n    inMemoryFields: inMemoryFields\n  };\n  return res;\n}\n\nfunction indexToSignature(index) {\n  // remove '_design/'\n  return index.ddoc.substring(8) + '/' + index.name;\n}\n\nfunction doAllDocs(db, originalOpts) {\n  var opts = clone(originalOpts);\n\n  // CouchDB responds in weird ways when you provide a non-string to _id;\n  // we mimic the behavior for consistency. See issue66 tests for details.\n  if (opts.descending) {\n    if ('endkey' in opts && typeof opts.endkey !== 'string') {\n      opts.endkey = '';\n    }\n    if ('startkey' in opts && typeof opts.startkey !== 'string') {\n      opts.limit = 0;\n    }\n  } else {\n    if ('startkey' in opts && typeof opts.startkey !== 'string') {\n      opts.startkey = '';\n    }\n    if ('endkey' in opts && typeof opts.endkey !== 'string') {\n      opts.limit = 0;\n    }\n  }\n  if ('key' in opts && typeof opts.key !== 'string') {\n    opts.limit = 0;\n  }\n\n  if (opts.limit > 0 && opts.indexes_count) {\n    // brute force and quite naive impl.\n    // amp up the limit with the amount of (indexes) design docs\n    // or is this too naive? How about skip?\n    opts.original_limit = opts.limit;\n    opts.limit += opts.indexes_count;\n  }\n\n  return db.allDocs(opts)\n    .then(function (res) {\n      // filter out any design docs that _all_docs might return\n      res.rows = res.rows.filter(function (row) {\n        return !/^_design\\//.test(row.id);\n      });\n      // put back original limit\n      if (opts.original_limit) {\n        opts.limit = opts.original_limit;\n      }\n      // enforce the rows to respect the given limit\n      res.rows = res.rows.slice(0, opts.limit);\n      return res;\n    });\n}\n\nfunction find$1(db, requestDef, explain) {\n  if (requestDef.selector) {\n    // must be validated before massaging\n    validateSelector(requestDef.selector, false);\n    requestDef.selector = massageSelector(requestDef.selector);\n  }\n\n  if (requestDef.sort) {\n    requestDef.sort = massageSort(requestDef.sort);\n  }\n\n  if (requestDef.use_index) {\n    requestDef.use_index = massageUseIndex(requestDef.use_index);\n  }\n\n  validateFindRequest(requestDef);\n\n  return getIndexes$1(db).then(function (getIndexesRes) {\n\n    db.constructor.emit('debug', ['find', 'planning query', requestDef]);\n    var queryPlan = planQuery(requestDef, getIndexesRes.indexes);\n    db.constructor.emit('debug', ['find', 'query plan', queryPlan]);\n\n    var indexToUse = queryPlan.index;\n\n    validateSort(requestDef, indexToUse);\n\n    var opts = assign({\n      include_docs: true,\n      reduce: false,\n      // Add amount of index for doAllDocs to use (related to issue #7810)\n      indexes_count: getIndexesRes.total_rows,\n    }, queryPlan.queryOpts);\n\n    if ('startkey' in opts && 'endkey' in opts &&\n        collate(opts.startkey, opts.endkey) > 0) {\n      // can't possibly return any results, startkey > endkey\n      /* istanbul ignore next */\n      return {docs: []};\n    }\n\n    var isDescending = requestDef.sort &&\n      typeof requestDef.sort[0] !== 'string' &&\n      getValue(requestDef.sort[0]) === 'desc';\n\n    if (isDescending) {\n      // either all descending or all ascending\n      opts.descending = true;\n      opts = reverseOptions(opts);\n    }\n\n    if (!queryPlan.inMemoryFields.length) {\n      // no in-memory filtering necessary, so we can let the\n      // database do the limit/skip for us\n      if ('limit' in requestDef) {\n        opts.limit = requestDef.limit;\n      }\n      if ('skip' in requestDef) {\n        opts.skip = requestDef.skip;\n      }\n    }\n\n    if (explain) {\n      return Promise.resolve(queryPlan, opts);\n    }\n\n    return Promise.resolve().then(function () {\n      if (indexToUse.name === '_all_docs') {\n        return doAllDocs(db, opts);\n      } else {\n        var signature = indexToSignature(indexToUse);\n        return abstractMapper$1(db).query.call(db, signature, opts);\n      }\n    }).then(function (res) {\n      if (opts.inclusive_start === false) {\n        // may have to manually filter the first one,\n        // since couchdb has no true inclusive_start option\n        res.rows = filterInclusiveStart(res.rows, opts.startkey, indexToUse);\n      }\n\n      if (queryPlan.inMemoryFields.length) {\n        // need to filter some stuff in-memory\n        res.rows = filterInMemoryFields(res.rows, requestDef, queryPlan.inMemoryFields);\n      }\n\n      var resp = {\n        docs: res.rows.map(function (row) {\n          var doc = row.doc;\n          if (requestDef.fields) {\n            return pick(doc, requestDef.fields);\n          }\n          return doc;\n        })\n      };\n\n      if (indexToUse.defaultUsed) {\n        resp.warning = 'No matching index found, create an index to optimize query time.';\n      }\n\n      return resp;\n    });\n  });\n}\n\nfunction explain$1(db, requestDef) {\n  return find$1(db, requestDef, true)\n  .then(function (queryPlan) {\n    return {\n      dbname: db.name,\n      index: queryPlan.index,\n      selector: requestDef.selector,\n      range: {\n        start_key: queryPlan.queryOpts.startkey,\n        end_key: queryPlan.queryOpts.endkey,\n      },\n      opts: {\n        use_index: requestDef.use_index || [],\n        bookmark: \"nil\", //hardcoded to match CouchDB since its not supported,\n        limit: requestDef.limit,\n        skip: requestDef.skip,\n        sort: requestDef.sort || {},\n        fields: requestDef.fields,\n        conflicts: false, //hardcoded to match CouchDB since its not supported,\n        r: [49], // hardcoded to match CouchDB since its not support\n      },\n      limit: requestDef.limit,\n      skip: requestDef.skip || 0,\n      fields: requestDef.fields,\n    };\n  });\n}\n\nfunction deleteIndex$1(db, index) {\n\n  if (!index.ddoc) {\n    throw new Error('you must supply an index.ddoc when deleting');\n  }\n\n  if (!index.name) {\n    throw new Error('you must supply an index.name when deleting');\n  }\n\n  var docId = index.ddoc;\n  var viewName = index.name;\n\n  function deltaFun(doc) {\n    if (Object.keys(doc.views).length === 1 && doc.views[viewName]) {\n      // only one view in this ddoc, delete the whole ddoc\n      return {_id: docId, _deleted: true};\n    }\n    // more than one view here, just remove the view\n    delete doc.views[viewName];\n    return doc;\n  }\n\n  return upsert(db, docId, deltaFun).then(function () {\n    return abstractMapper$1(db).viewCleanup.apply(db);\n  }).then(function () {\n    return {ok: true};\n  });\n}\n\nvar createIndexAsCallback = callbackify(createIndex$1);\nvar findAsCallback = callbackify(find$1);\nvar explainAsCallback = callbackify(explain$1);\nvar getIndexesAsCallback = callbackify(getIndexes$1);\nvar deleteIndexAsCallback = callbackify(deleteIndex$1);\n\nvar plugin = {};\nplugin.createIndex = toPromise(function (requestDef, callback) {\n\n  if (typeof requestDef !== 'object') {\n    return callback(new Error('you must provide an index to create'));\n  }\n\n  var createIndex$$1 = isRemote(this) ?\n    createIndex : createIndexAsCallback;\n  createIndex$$1(this, requestDef, callback);\n});\n\nplugin.find = toPromise(function (requestDef, callback) {\n\n  if (typeof callback === 'undefined') {\n    callback = requestDef;\n    requestDef = undefined;\n  }\n\n  if (typeof requestDef !== 'object') {\n    return callback(new Error('you must provide search parameters to find()'));\n  }\n\n  var find$$1 = isRemote(this) ? find : findAsCallback;\n  find$$1(this, requestDef, callback);\n});\n\nplugin.explain = toPromise(function (requestDef, callback) {\n\n  if (typeof callback === 'undefined') {\n    callback = requestDef;\n    requestDef = undefined;\n  }\n\n  if (typeof requestDef !== 'object') {\n    return callback(new Error('you must provide search parameters to explain()'));\n  }\n\n  var find$$1 = isRemote(this) ? explain : explainAsCallback;\n  find$$1(this, requestDef, callback);\n});\n\nplugin.getIndexes = toPromise(function (callback) {\n\n  var getIndexes$$1 = isRemote(this) ? getIndexes : getIndexesAsCallback;\n  getIndexes$$1(this, callback);\n});\n\nplugin.deleteIndex = toPromise(function (indexDef, callback) {\n\n  if (typeof indexDef !== 'object') {\n    return callback(new Error('you must provide an index to delete'));\n  }\n\n  var deleteIndex$$1 = isRemote(this) ?\n    deleteIndex : deleteIndexAsCallback;\n  deleteIndex$$1(this, indexDef, callback);\n});\n\nexport default plugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}