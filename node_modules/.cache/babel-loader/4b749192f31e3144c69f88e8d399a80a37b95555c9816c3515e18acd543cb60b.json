{"ast":null,"code":"import { useEffect } from 'react';\nimport { useContext } from './context';\nimport useStateMachine from './state-machine';\nimport { useDeepMemo } from './utils';\n/**\n * Get all docs or a slice of all docs and subscribe to their updates.\n * @param options PouchDB's allDocs options.\n */\nexport default function useAllDocs(options) {\n  const {\n    pouchdb: pouch,\n    subscriptionManager\n  } = useContext(options === null || options === void 0 ? void 0 : options.db);\n  const {\n    include_docs,\n    conflicts,\n    attachments,\n    binary,\n    limit,\n    skip,\n    descending,\n    update_seq\n  } = options || {};\n  const {\n    startkey,\n    endkey,\n    inclusive_end\n  } = options || {};\n  const {\n    key\n  } = options || {};\n  const keys = useDeepMemo(options === null || options === void 0 ? void 0 : options.keys);\n  const [state, dispatch, replace] = useStateMachine(() => ({\n    rows: [],\n    total_rows: 0,\n    offset: 0\n  }));\n  useEffect(() => {\n    let isMounted = true;\n    let isFetching = false;\n    let shouldUpdateAfter = false;\n    const opt = {\n      include_docs,\n      conflicts,\n      attachments,\n      binary,\n      limit,\n      skip,\n      descending,\n      update_seq,\n      startkey,\n      endkey,\n      inclusive_end,\n      key,\n      keys\n    };\n    const fetch = async () => {\n      if (isFetching) {\n        shouldUpdateAfter = true;\n        return;\n      }\n      isFetching = true;\n      shouldUpdateAfter = false;\n      dispatch({\n        type: 'loading_started'\n      });\n      try {\n        const result = await pouch.allDocs(opt);\n        if (isMounted) {\n          dispatch({\n            type: 'loading_finished',\n            payload: result\n          });\n        }\n      } catch (err) {\n        if (isMounted) {\n          dispatch({\n            type: 'loading_error',\n            payload: {\n              error: err,\n              setResult: false\n            }\n          });\n        }\n      } finally {\n        // refresh if change did happen while querying\n        isFetching = false;\n        if (shouldUpdateAfter && isMounted) {\n          fetch();\n        }\n      }\n    };\n    fetch();\n    let keysToSubscribe = null;\n    if (key != null) {\n      keysToSubscribe = [key];\n    } else if (keys != null) {\n      keysToSubscribe = keys;\n    }\n    const unsubscribe = subscriptionManager.subscribeToDocs(keysToSubscribe, (deleted, id) => {\n      if (!isMounted || !isInRange(id, startkey, endkey, inclusive_end, descending)) {\n        return;\n      }\n      if (deleted) {\n        replace(result => {\n          const rows = result.rows.filter(row => row.id !== id);\n          return Object.assign(Object.assign({}, result), {\n            rows,\n            total_rows: result.total_rows - (result.rows.length - rows.length)\n          });\n        });\n      } else {\n        fetch();\n      }\n    });\n    return () => {\n      isMounted = false;\n      unsubscribe();\n    };\n  }, [dispatch, replace, pouch, subscriptionManager, include_docs, conflicts, attachments, binary, startkey, endkey, inclusive_end, limit, skip, descending, key, keys, update_seq]);\n  return state;\n}\n/**\n * Check if the updated document is inside of the range.\n * @param id Id of the updated document\n * @param startkey Startkey option.\n * @param endkey Endkey option.\n * @param inclusive_end Is the endkey inclusive?\n * @param descending Which direction should the slice go?\n */\nfunction isInRange(id, startkey, endkey, inclusive_end, descending) {\n  if (startkey && (descending && id > startkey || !descending && id < startkey)) {\n    return false;\n  }\n  if (endkey == null) {\n    return true;\n  }\n  if (inclusive_end) {\n    return descending ? id >= endkey : id <= endkey;\n  } else {\n    return descending ? id > endkey : id < endkey;\n  }\n}","map":{"version":3,"names":["useEffect","useContext","useStateMachine","useDeepMemo","useAllDocs","options","pouchdb","pouch","subscriptionManager","db","include_docs","conflicts","attachments","binary","limit","skip","descending","update_seq","startkey","endkey","inclusive_end","key","keys","state","dispatch","replace","rows","total_rows","offset","isMounted","isFetching","shouldUpdateAfter","opt","fetch","type","result","allDocs","payload","err","error","setResult","keysToSubscribe","unsubscribe","subscribeToDocs","deleted","id","isInRange","filter","row","Object","assign","length"],"sources":["/home/sol/Documentos/AUS/3ro segundo cuatri/ing 2/URV/node_modules/use-pouchdb/lib/useAllDocs.js"],"sourcesContent":["import { useEffect } from 'react';\nimport { useContext } from './context';\nimport useStateMachine from './state-machine';\nimport { useDeepMemo } from './utils';\n/**\n * Get all docs or a slice of all docs and subscribe to their updates.\n * @param options PouchDB's allDocs options.\n */\nexport default function useAllDocs(options) {\n    const { pouchdb: pouch, subscriptionManager } = useContext(options === null || options === void 0 ? void 0 : options.db);\n    const { include_docs, conflicts, attachments, binary, limit, skip, descending, update_seq, } = options || {};\n    const { startkey, endkey, inclusive_end } = options || {};\n    const { key } = options || {};\n    const keys = useDeepMemo(options === null || options === void 0 ? void 0 : options.keys);\n    const [state, dispatch, replace] = useStateMachine(() => ({\n        rows: [],\n        total_rows: 0,\n        offset: 0,\n    }));\n    useEffect(() => {\n        let isMounted = true;\n        let isFetching = false;\n        let shouldUpdateAfter = false;\n        const opt = {\n            include_docs,\n            conflicts,\n            attachments,\n            binary,\n            limit,\n            skip,\n            descending,\n            update_seq,\n            startkey,\n            endkey,\n            inclusive_end,\n            key,\n            keys,\n        };\n        const fetch = async () => {\n            if (isFetching) {\n                shouldUpdateAfter = true;\n                return;\n            }\n            isFetching = true;\n            shouldUpdateAfter = false;\n            dispatch({ type: 'loading_started' });\n            try {\n                const result = await pouch.allDocs(opt);\n                if (isMounted) {\n                    dispatch({\n                        type: 'loading_finished',\n                        payload: result,\n                    });\n                }\n            }\n            catch (err) {\n                if (isMounted) {\n                    dispatch({\n                        type: 'loading_error',\n                        payload: {\n                            error: err,\n                            setResult: false,\n                        },\n                    });\n                }\n            }\n            finally {\n                // refresh if change did happen while querying\n                isFetching = false;\n                if (shouldUpdateAfter && isMounted) {\n                    fetch();\n                }\n            }\n        };\n        fetch();\n        let keysToSubscribe = null;\n        if (key != null) {\n            keysToSubscribe = [key];\n        }\n        else if (keys != null) {\n            keysToSubscribe = keys;\n        }\n        const unsubscribe = subscriptionManager.subscribeToDocs(keysToSubscribe, (deleted, id) => {\n            if (!isMounted ||\n                !isInRange(id, startkey, endkey, inclusive_end, descending)) {\n                return;\n            }\n            if (deleted) {\n                replace(result => {\n                    const rows = result.rows.filter(row => row.id !== id);\n                    return Object.assign(Object.assign({}, result), { rows, total_rows: result.total_rows - (result.rows.length - rows.length) });\n                });\n            }\n            else {\n                fetch();\n            }\n        });\n        return () => {\n            isMounted = false;\n            unsubscribe();\n        };\n    }, [\n        dispatch,\n        replace,\n        pouch,\n        subscriptionManager,\n        include_docs,\n        conflicts,\n        attachments,\n        binary,\n        startkey,\n        endkey,\n        inclusive_end,\n        limit,\n        skip,\n        descending,\n        key,\n        keys,\n        update_seq,\n    ]);\n    return state;\n}\n/**\n * Check if the updated document is inside of the range.\n * @param id Id of the updated document\n * @param startkey Startkey option.\n * @param endkey Endkey option.\n * @param inclusive_end Is the endkey inclusive?\n * @param descending Which direction should the slice go?\n */\nfunction isInRange(id, startkey, endkey, inclusive_end, descending) {\n    if (startkey &&\n        ((descending && id > startkey) || (!descending && id < startkey))) {\n        return false;\n    }\n    if (endkey == null) {\n        return true;\n    }\n    if (inclusive_end) {\n        return descending ? id >= endkey : id <= endkey;\n    }\n    else {\n        return descending ? id > endkey : id < endkey;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}