{"ast":null,"code":"import { Set, Map } from 'pouchdb-collections';\nimport { base64StringToBlobOrBuffer } from 'pouchdb-binary-utils';\nimport { collate, toIndexableString, normalizeKey, parseIndexableString } from 'pouchdb-collate';\nimport { generateErrorFromResponse } from 'pouchdb-errors';\nimport { Headers } from 'pouchdb-fetch';\nimport { upsert, flatten, guardedConsole, nextTick, isRemote } from 'pouchdb-utils';\nimport { stringMd5 } from 'pouchdb-md5';\nimport { callbackify, sequentialize, uniq, fin, promisedCallback, mapToKeysArray, QueryParseError, NotFoundError, BuiltInError } from 'pouchdb-mapreduce-utils';\n\n/*\n * Simple task queue to sequentialize actions. Assumes\n * callbacks will eventually fire (once).\n */\n\nfunction TaskQueue() {\n  this.promise = new Promise(function (fulfill) {\n    fulfill();\n  });\n}\nTaskQueue.prototype.add = function (promiseFactory) {\n  this.promise = this.promise.catch(function () {\n    // just recover\n  }).then(function () {\n    return promiseFactory();\n  });\n  return this.promise;\n};\nTaskQueue.prototype.finish = function () {\n  return this.promise;\n};\nfunction stringify(input) {\n  if (!input) {\n    return 'undefined'; // backwards compat for empty reduce\n  }\n  // for backwards compat with mapreduce, functions/strings are stringified\n  // as-is. everything else is JSON-stringified.\n  switch (typeof input) {\n    case 'function':\n      // e.g. a mapreduce map\n      return input.toString();\n    case 'string':\n      // e.g. a mapreduce built-in _reduce function\n      return input.toString();\n    default:\n      // e.g. a JSON object in the case of mango queries\n      return JSON.stringify(input);\n  }\n}\n\n/* create a string signature for a view so we can cache it and uniq it */\nfunction createViewSignature(mapFun, reduceFun) {\n  // the \"undefined\" part is for backwards compatibility\n  return stringify(mapFun) + stringify(reduceFun) + 'undefined';\n}\nfunction createView(sourceDB, viewName, mapFun, reduceFun, temporary, localDocName) {\n  var viewSignature = createViewSignature(mapFun, reduceFun);\n  var cachedViews;\n  if (!temporary) {\n    // cache this to ensure we don't try to update the same view twice\n    cachedViews = sourceDB._cachedViews = sourceDB._cachedViews || {};\n    if (cachedViews[viewSignature]) {\n      return cachedViews[viewSignature];\n    }\n  }\n  var promiseForView = sourceDB.info().then(function (info) {\n    var depDbName = info.db_name + '-mrview-' + (temporary ? 'temp' : stringMd5(viewSignature));\n\n    // save the view name in the source db so it can be cleaned up if necessary\n    // (e.g. when the _design doc is deleted, remove all associated view data)\n    function diffFunction(doc) {\n      doc.views = doc.views || {};\n      var fullViewName = viewName;\n      if (fullViewName.indexOf('/') === -1) {\n        fullViewName = viewName + '/' + viewName;\n      }\n      var depDbs = doc.views[fullViewName] = doc.views[fullViewName] || {};\n      /* istanbul ignore if */\n      if (depDbs[depDbName]) {\n        return; // no update necessary\n      }\n\n      depDbs[depDbName] = true;\n      return doc;\n    }\n    return upsert(sourceDB, '_local/' + localDocName, diffFunction).then(function () {\n      return sourceDB.registerDependentDatabase(depDbName).then(function (res) {\n        var db = res.db;\n        db.auto_compaction = true;\n        var view = {\n          name: depDbName,\n          db: db,\n          sourceDB: sourceDB,\n          adapter: sourceDB.adapter,\n          mapFun: mapFun,\n          reduceFun: reduceFun\n        };\n        return view.db.get('_local/lastSeq').catch(function (err) {\n          /* istanbul ignore if */\n          if (err.status !== 404) {\n            throw err;\n          }\n        }).then(function (lastSeqDoc) {\n          view.seq = lastSeqDoc ? lastSeqDoc.seq : 0;\n          if (cachedViews) {\n            view.db.once('destroyed', function () {\n              delete cachedViews[viewSignature];\n            });\n          }\n          return view;\n        });\n      });\n    });\n  });\n  if (cachedViews) {\n    cachedViews[viewSignature] = promiseForView;\n  }\n  return promiseForView;\n}\nvar persistentQueues = {};\nvar tempViewQueue = new TaskQueue();\nvar CHANGES_BATCH_SIZE = 50;\nfunction parseViewName(name) {\n  // can be either 'ddocname/viewname' or just 'viewname'\n  // (where the ddoc name is the same)\n  return name.indexOf('/') === -1 ? [name, name] : name.split('/');\n}\nfunction isGenOne(changes) {\n  // only return true if the current change is 1-\n  // and there are no other leafs\n  return changes.length === 1 && /^1-/.test(changes[0].rev);\n}\nfunction emitError(db, e, data) {\n  try {\n    db.emit('error', e);\n  } catch (err) {\n    guardedConsole('error', 'The user\\'s map/reduce function threw an uncaught error.\\n' + 'You can debug this error by doing:\\n' + 'myDatabase.on(\\'error\\', function (err) { debugger; });\\n' + 'Please double-check your map/reduce function.');\n    guardedConsole('error', e, data);\n  }\n}\n\n/**\n * Returns an \"abstract\" mapreduce object of the form:\n *\n *   {\n *     query: queryFun,\n *     viewCleanup: viewCleanupFun\n *   }\n *\n * Arguments are:\n *\n * localDoc: string\n *   This is for the local doc that gets saved in order to track the\n *   \"dependent\" DBs and clean them up for viewCleanup. It should be\n *   unique, so that indexer plugins don't collide with each other.\n * mapper: function (mapFunDef, emit)\n *   Returns a map function based on the mapFunDef, which in the case of\n *   normal map/reduce is just the de-stringified function, but may be\n *   something else, such as an object in the case of pouchdb-find.\n * reducer: function (reduceFunDef)\n *   Ditto, but for reducing. Modules don't have to support reducing\n *   (e.g. pouchdb-find).\n * ddocValidator: function (ddoc, viewName)\n *   Throws an error if the ddoc or viewName is not valid.\n *   This could be a way to communicate to the user that the configuration for the\n *   indexer is invalid.\n */\nfunction createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator) {\n  function tryMap(db, fun, doc) {\n    // emit an event if there was an error thrown by a map function.\n    // putting try/catches in a single function also avoids deoptimizations.\n    try {\n      fun(doc);\n    } catch (e) {\n      emitError(db, e, {\n        fun: fun,\n        doc: doc\n      });\n    }\n  }\n  function tryReduce(db, fun, keys, values, rereduce) {\n    // same as above, but returning the result or an error. there are two separate\n    // functions to avoid extra memory allocations since the tryCode() case is used\n    // for custom map functions (common) vs this function, which is only used for\n    // custom reduce functions (rare)\n    try {\n      return {\n        output: fun(keys, values, rereduce)\n      };\n    } catch (e) {\n      emitError(db, e, {\n        fun: fun,\n        keys: keys,\n        values: values,\n        rereduce: rereduce\n      });\n      return {\n        error: e\n      };\n    }\n  }\n  function sortByKeyThenValue(x, y) {\n    var keyCompare = collate(x.key, y.key);\n    return keyCompare !== 0 ? keyCompare : collate(x.value, y.value);\n  }\n  function sliceResults(results, limit, skip) {\n    skip = skip || 0;\n    if (typeof limit === 'number') {\n      return results.slice(skip, limit + skip);\n    } else if (skip > 0) {\n      return results.slice(skip);\n    }\n    return results;\n  }\n  function rowToDocId(row) {\n    var val = row.value;\n    // Users can explicitly specify a joined doc _id, or it\n    // defaults to the doc _id that emitted the key/value.\n    var docId = val && typeof val === 'object' && val._id || row.id;\n    return docId;\n  }\n  function readAttachmentsAsBlobOrBuffer(res) {\n    res.rows.forEach(function (row) {\n      var atts = row.doc && row.doc._attachments;\n      if (!atts) {\n        return;\n      }\n      Object.keys(atts).forEach(function (filename) {\n        var att = atts[filename];\n        atts[filename].data = base64StringToBlobOrBuffer(att.data, att.content_type);\n      });\n    });\n  }\n  function postprocessAttachments(opts) {\n    return function (res) {\n      if (opts.include_docs && opts.attachments && opts.binary) {\n        readAttachmentsAsBlobOrBuffer(res);\n      }\n      return res;\n    };\n  }\n  function addHttpParam(paramName, opts, params, asJson) {\n    // add an http param from opts to params, optionally json-encoded\n    var val = opts[paramName];\n    if (typeof val !== 'undefined') {\n      if (asJson) {\n        val = encodeURIComponent(JSON.stringify(val));\n      }\n      params.push(paramName + '=' + val);\n    }\n  }\n  function coerceInteger(integerCandidate) {\n    if (typeof integerCandidate !== 'undefined') {\n      var asNumber = Number(integerCandidate);\n      // prevents e.g. '1foo' or '1.1' being coerced to 1\n      if (!isNaN(asNumber) && asNumber === parseInt(integerCandidate, 10)) {\n        return asNumber;\n      } else {\n        return integerCandidate;\n      }\n    }\n  }\n  function coerceOptions(opts) {\n    opts.group_level = coerceInteger(opts.group_level);\n    opts.limit = coerceInteger(opts.limit);\n    opts.skip = coerceInteger(opts.skip);\n    return opts;\n  }\n  function checkPositiveInteger(number) {\n    if (number) {\n      if (typeof number !== 'number') {\n        return new QueryParseError('Invalid value for integer: \"' + number + '\"');\n      }\n      if (number < 0) {\n        return new QueryParseError('Invalid value for positive integer: ' + '\"' + number + '\"');\n      }\n    }\n  }\n  function checkQueryParseError(options, fun) {\n    var startkeyName = options.descending ? 'endkey' : 'startkey';\n    var endkeyName = options.descending ? 'startkey' : 'endkey';\n    if (typeof options[startkeyName] !== 'undefined' && typeof options[endkeyName] !== 'undefined' && collate(options[startkeyName], options[endkeyName]) > 0) {\n      throw new QueryParseError('No rows can match your key range, ' + 'reverse your start_key and end_key or set {descending : true}');\n    } else if (fun.reduce && options.reduce !== false) {\n      if (options.include_docs) {\n        throw new QueryParseError('{include_docs:true} is invalid for reduce');\n      } else if (options.keys && options.keys.length > 1 && !options.group && !options.group_level) {\n        throw new QueryParseError('Multi-key fetches for reduce views must use ' + '{group: true}');\n      }\n    }\n    ['group_level', 'limit', 'skip'].forEach(function (optionName) {\n      var error = checkPositiveInteger(options[optionName]);\n      if (error) {\n        throw error;\n      }\n    });\n  }\n  function httpQuery(db, fun, opts) {\n    // List of parameters to add to the PUT request\n    var params = [];\n    var body;\n    var method = 'GET';\n    var ok, status;\n\n    // If opts.reduce exists and is defined, then add it to the list\n    // of parameters.\n    // If reduce=false then the results are that of only the map function\n    // not the final result of map and reduce.\n    addHttpParam('reduce', opts, params);\n    addHttpParam('include_docs', opts, params);\n    addHttpParam('attachments', opts, params);\n    addHttpParam('limit', opts, params);\n    addHttpParam('descending', opts, params);\n    addHttpParam('group', opts, params);\n    addHttpParam('group_level', opts, params);\n    addHttpParam('skip', opts, params);\n    addHttpParam('stale', opts, params);\n    addHttpParam('conflicts', opts, params);\n    addHttpParam('startkey', opts, params, true);\n    addHttpParam('start_key', opts, params, true);\n    addHttpParam('endkey', opts, params, true);\n    addHttpParam('end_key', opts, params, true);\n    addHttpParam('inclusive_end', opts, params);\n    addHttpParam('key', opts, params, true);\n    addHttpParam('update_seq', opts, params);\n\n    // Format the list of parameters into a valid URI query string\n    params = params.join('&');\n    params = params === '' ? '' : '?' + params;\n\n    // If keys are supplied, issue a POST to circumvent GET query string limits\n    // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options\n    if (typeof opts.keys !== 'undefined') {\n      var MAX_URL_LENGTH = 2000;\n      // according to http://stackoverflow.com/a/417184/680742,\n      // the de facto URL length limit is 2000 characters\n\n      var keysAsString = 'keys=' + encodeURIComponent(JSON.stringify(opts.keys));\n      if (keysAsString.length + params.length + 1 <= MAX_URL_LENGTH) {\n        // If the keys are short enough, do a GET. we do this to work around\n        // Safari not understanding 304s on POSTs (see pouchdb/pouchdb#1239)\n        params += (params[0] === '?' ? '&' : '?') + keysAsString;\n      } else {\n        method = 'POST';\n        if (typeof fun === 'string') {\n          body = {\n            keys: opts.keys\n          };\n        } else {\n          // fun is {map : mapfun}, so append to this\n          fun.keys = opts.keys;\n        }\n      }\n    }\n\n    // We are referencing a query defined in the design doc\n    if (typeof fun === 'string') {\n      var parts = parseViewName(fun);\n      return db.fetch('_design/' + parts[0] + '/_view/' + parts[1] + params, {\n        headers: new Headers({\n          'Content-Type': 'application/json'\n        }),\n        method: method,\n        body: JSON.stringify(body)\n      }).then(function (response) {\n        ok = response.ok;\n        status = response.status;\n        return response.json();\n      }).then(function (result) {\n        if (!ok) {\n          result.status = status;\n          throw generateErrorFromResponse(result);\n        }\n        // fail the entire request if the result contains an error\n        result.rows.forEach(function (row) {\n          /* istanbul ignore if */\n          if (row.value && row.value.error && row.value.error === \"builtin_reduce_error\") {\n            throw new Error(row.reason);\n          }\n        });\n        return result;\n      }).then(postprocessAttachments(opts));\n    }\n\n    // We are using a temporary view, terrible for performance, good for testing\n    body = body || {};\n    Object.keys(fun).forEach(function (key) {\n      if (Array.isArray(fun[key])) {\n        body[key] = fun[key];\n      } else {\n        body[key] = fun[key].toString();\n      }\n    });\n    return db.fetch('_temp_view' + params, {\n      headers: new Headers({\n        'Content-Type': 'application/json'\n      }),\n      method: 'POST',\n      body: JSON.stringify(body)\n    }).then(function (response) {\n      ok = response.ok;\n      status = response.status;\n      return response.json();\n    }).then(function (result) {\n      if (!ok) {\n        result.status = status;\n        throw generateErrorFromResponse(result);\n      }\n      return result;\n    }).then(postprocessAttachments(opts));\n  }\n\n  // custom adapters can define their own api._query\n  // and override the default behavior\n  /* istanbul ignore next */\n  function customQuery(db, fun, opts) {\n    return new Promise(function (resolve, reject) {\n      db._query(fun, opts, function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  // custom adapters can define their own api._viewCleanup\n  // and override the default behavior\n  /* istanbul ignore next */\n  function customViewCleanup(db) {\n    return new Promise(function (resolve, reject) {\n      db._viewCleanup(function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n  function defaultsTo(value) {\n    return function (reason) {\n      /* istanbul ignore else */\n      if (reason.status === 404) {\n        return value;\n      } else {\n        throw reason;\n      }\n    };\n  }\n\n  // returns a promise for a list of docs to update, based on the input docId.\n  // the order doesn't matter, because post-3.2.0, bulkDocs\n  // is an atomic operation in all three adapters.\n  function getDocsToPersist(docId, view, docIdsToChangesAndEmits) {\n    var metaDocId = '_local/doc_' + docId;\n    var defaultMetaDoc = {\n      _id: metaDocId,\n      keys: []\n    };\n    var docData = docIdsToChangesAndEmits.get(docId);\n    var indexableKeysToKeyValues = docData[0];\n    var changes = docData[1];\n    function getMetaDoc() {\n      if (isGenOne(changes)) {\n        // generation 1, so we can safely assume initial state\n        // for performance reasons (avoids unnecessary GETs)\n        return Promise.resolve(defaultMetaDoc);\n      }\n      return view.db.get(metaDocId).catch(defaultsTo(defaultMetaDoc));\n    }\n    function getKeyValueDocs(metaDoc) {\n      if (!metaDoc.keys.length) {\n        // no keys, no need for a lookup\n        return Promise.resolve({\n          rows: []\n        });\n      }\n      return view.db.allDocs({\n        keys: metaDoc.keys,\n        include_docs: true\n      });\n    }\n    function processKeyValueDocs(metaDoc, kvDocsRes) {\n      var kvDocs = [];\n      var oldKeys = new Set();\n      for (var i = 0, len = kvDocsRes.rows.length; i < len; i++) {\n        var row = kvDocsRes.rows[i];\n        var doc = row.doc;\n        if (!doc) {\n          // deleted\n          continue;\n        }\n        kvDocs.push(doc);\n        oldKeys.add(doc._id);\n        doc._deleted = !indexableKeysToKeyValues.has(doc._id);\n        if (!doc._deleted) {\n          var keyValue = indexableKeysToKeyValues.get(doc._id);\n          if ('value' in keyValue) {\n            doc.value = keyValue.value;\n          }\n        }\n      }\n      var newKeys = mapToKeysArray(indexableKeysToKeyValues);\n      newKeys.forEach(function (key) {\n        if (!oldKeys.has(key)) {\n          // new doc\n          var kvDoc = {\n            _id: key\n          };\n          var keyValue = indexableKeysToKeyValues.get(key);\n          if ('value' in keyValue) {\n            kvDoc.value = keyValue.value;\n          }\n          kvDocs.push(kvDoc);\n        }\n      });\n      metaDoc.keys = uniq(newKeys.concat(metaDoc.keys));\n      kvDocs.push(metaDoc);\n      return kvDocs;\n    }\n    return getMetaDoc().then(function (metaDoc) {\n      return getKeyValueDocs(metaDoc).then(function (kvDocsRes) {\n        return processKeyValueDocs(metaDoc, kvDocsRes);\n      });\n    });\n  }\n\n  // updates all emitted key/value docs and metaDocs in the mrview database\n  // for the given batch of documents from the source database\n  function saveKeyValues(view, docIdsToChangesAndEmits, seq) {\n    var seqDocId = '_local/lastSeq';\n    return view.db.get(seqDocId).catch(defaultsTo({\n      _id: seqDocId,\n      seq: 0\n    })).then(function (lastSeqDoc) {\n      var docIds = mapToKeysArray(docIdsToChangesAndEmits);\n      return Promise.all(docIds.map(function (docId) {\n        return getDocsToPersist(docId, view, docIdsToChangesAndEmits);\n      })).then(function (listOfDocsToPersist) {\n        var docsToPersist = flatten(listOfDocsToPersist);\n        lastSeqDoc.seq = seq;\n        docsToPersist.push(lastSeqDoc);\n        // write all docs in a single operation, update the seq once\n        return view.db.bulkDocs({\n          docs: docsToPersist\n        });\n      });\n    });\n  }\n  function getQueue(view) {\n    var viewName = typeof view === 'string' ? view : view.name;\n    var queue = persistentQueues[viewName];\n    if (!queue) {\n      queue = persistentQueues[viewName] = new TaskQueue();\n    }\n    return queue;\n  }\n  function updateView(view, opts) {\n    return sequentialize(getQueue(view), function () {\n      return updateViewInQueue(view, opts);\n    })();\n  }\n  function updateViewInQueue(view, opts) {\n    // bind the emit function once\n    var mapResults;\n    var doc;\n    function emit(key, value) {\n      var output = {\n        id: doc._id,\n        key: normalizeKey(key)\n      };\n      // Don't explicitly store the value unless it's defined and non-null.\n      // This saves on storage space, because often people don't use it.\n      if (typeof value !== 'undefined' && value !== null) {\n        output.value = normalizeKey(value);\n      }\n      mapResults.push(output);\n    }\n    var mapFun = mapper(view.mapFun, emit);\n    var currentSeq = view.seq || 0;\n    function processChange(docIdsToChangesAndEmits, seq) {\n      return function () {\n        return saveKeyValues(view, docIdsToChangesAndEmits, seq);\n      };\n    }\n    let indexed_docs = 0;\n    let progress = {\n      view: view.name,\n      indexed_docs: indexed_docs\n    };\n    view.sourceDB.emit('indexing', progress);\n    var queue = new TaskQueue();\n    function processNextBatch() {\n      return view.sourceDB.changes({\n        return_docs: true,\n        conflicts: true,\n        include_docs: true,\n        style: 'all_docs',\n        since: currentSeq,\n        limit: opts.changes_batch_size\n      }).then(processBatch);\n    }\n    function processBatch(response) {\n      var results = response.results;\n      if (!results.length) {\n        return;\n      }\n      var docIdsToChangesAndEmits = createDocIdsToChangesAndEmits(results);\n      queue.add(processChange(docIdsToChangesAndEmits, currentSeq));\n      indexed_docs = indexed_docs + results.length;\n      let progress = {\n        view: view.name,\n        last_seq: response.last_seq,\n        results_count: results.length,\n        indexed_docs: indexed_docs\n      };\n      view.sourceDB.emit('indexing', progress);\n      if (results.length < opts.changes_batch_size) {\n        return;\n      }\n      return processNextBatch();\n    }\n    function createDocIdsToChangesAndEmits(results) {\n      var docIdsToChangesAndEmits = new Map();\n      for (var i = 0, len = results.length; i < len; i++) {\n        var change = results[i];\n        if (change.doc._id[0] !== '_') {\n          mapResults = [];\n          doc = change.doc;\n          if (!doc._deleted) {\n            tryMap(view.sourceDB, mapFun, doc);\n          }\n          mapResults.sort(sortByKeyThenValue);\n          var indexableKeysToKeyValues = createIndexableKeysToKeyValues(mapResults);\n          docIdsToChangesAndEmits.set(change.doc._id, [indexableKeysToKeyValues, change.changes]);\n        }\n        currentSeq = change.seq;\n      }\n      return docIdsToChangesAndEmits;\n    }\n    function createIndexableKeysToKeyValues(mapResults) {\n      var indexableKeysToKeyValues = new Map();\n      var lastKey;\n      for (var i = 0, len = mapResults.length; i < len; i++) {\n        var emittedKeyValue = mapResults[i];\n        var complexKey = [emittedKeyValue.key, emittedKeyValue.id];\n        if (i > 0 && collate(emittedKeyValue.key, lastKey) === 0) {\n          complexKey.push(i); // dup key+id, so make it unique\n        }\n\n        indexableKeysToKeyValues.set(toIndexableString(complexKey), emittedKeyValue);\n        lastKey = emittedKeyValue.key;\n      }\n      return indexableKeysToKeyValues;\n    }\n    return processNextBatch().then(function () {\n      return queue.finish();\n    }).then(function () {\n      view.seq = currentSeq;\n    });\n  }\n  function reduceView(view, results, options) {\n    if (options.group_level === 0) {\n      delete options.group_level;\n    }\n    var shouldGroup = options.group || options.group_level;\n    var reduceFun = reducer(view.reduceFun);\n    var groups = [];\n    var lvl = isNaN(options.group_level) ? Number.POSITIVE_INFINITY : options.group_level;\n    results.forEach(function (e) {\n      var last = groups[groups.length - 1];\n      var groupKey = shouldGroup ? e.key : null;\n\n      // only set group_level for array keys\n      if (shouldGroup && Array.isArray(groupKey)) {\n        groupKey = groupKey.slice(0, lvl);\n      }\n      if (last && collate(last.groupKey, groupKey) === 0) {\n        last.keys.push([e.key, e.id]);\n        last.values.push(e.value);\n        return;\n      }\n      groups.push({\n        keys: [[e.key, e.id]],\n        values: [e.value],\n        groupKey: groupKey\n      });\n    });\n    results = [];\n    for (var i = 0, len = groups.length; i < len; i++) {\n      var e = groups[i];\n      var reduceTry = tryReduce(view.sourceDB, reduceFun, e.keys, e.values, false);\n      if (reduceTry.error && reduceTry.error instanceof BuiltInError) {\n        // CouchDB returns an error if a built-in errors out\n        throw reduceTry.error;\n      }\n      results.push({\n        // CouchDB just sets the value to null if a non-built-in errors out\n        value: reduceTry.error ? null : reduceTry.output,\n        key: e.groupKey\n      });\n    }\n    // no total_rows/offset when reducing\n    return {\n      rows: sliceResults(results, options.limit, options.skip)\n    };\n  }\n  function queryView(view, opts) {\n    return sequentialize(getQueue(view), function () {\n      return queryViewInQueue(view, opts);\n    })();\n  }\n  function queryViewInQueue(view, opts) {\n    var totalRows;\n    var shouldReduce = view.reduceFun && opts.reduce !== false;\n    var skip = opts.skip || 0;\n    if (typeof opts.keys !== 'undefined' && !opts.keys.length) {\n      // equivalent query\n      opts.limit = 0;\n      delete opts.keys;\n    }\n    function fetchFromView(viewOpts) {\n      viewOpts.include_docs = true;\n      return view.db.allDocs(viewOpts).then(function (res) {\n        totalRows = res.total_rows;\n        return res.rows.map(function (result) {\n          // implicit migration - in older versions of PouchDB,\n          // we explicitly stored the doc as {id: ..., key: ..., value: ...}\n          // this is tested in a migration test\n          /* istanbul ignore next */\n          if ('value' in result.doc && typeof result.doc.value === 'object' && result.doc.value !== null) {\n            var keys = Object.keys(result.doc.value).sort();\n            // this detection method is not perfect, but it's unlikely the user\n            // emitted a value which was an object with these 3 exact keys\n            var expectedKeys = ['id', 'key', 'value'];\n            if (!(keys < expectedKeys || keys > expectedKeys)) {\n              return result.doc.value;\n            }\n          }\n          var parsedKeyAndDocId = parseIndexableString(result.doc._id);\n          return {\n            key: parsedKeyAndDocId[0],\n            id: parsedKeyAndDocId[1],\n            value: 'value' in result.doc ? result.doc.value : null\n          };\n        });\n      });\n    }\n    function onMapResultsReady(rows) {\n      var finalResults;\n      if (shouldReduce) {\n        finalResults = reduceView(view, rows, opts);\n      } else if (typeof opts.keys === 'undefined') {\n        finalResults = {\n          total_rows: totalRows,\n          offset: skip,\n          rows: rows\n        };\n      } else {\n        // support limit, skip for keys query\n        finalResults = {\n          total_rows: totalRows,\n          offset: skip,\n          rows: sliceResults(rows, opts.limit, opts.skip)\n        };\n      }\n      /* istanbul ignore if */\n      if (opts.update_seq) {\n        finalResults.update_seq = view.seq;\n      }\n      if (opts.include_docs) {\n        var docIds = uniq(rows.map(rowToDocId));\n        return view.sourceDB.allDocs({\n          keys: docIds,\n          include_docs: true,\n          conflicts: opts.conflicts,\n          attachments: opts.attachments,\n          binary: opts.binary\n        }).then(function (allDocsRes) {\n          var docIdsToDocs = new Map();\n          allDocsRes.rows.forEach(function (row) {\n            docIdsToDocs.set(row.id, row.doc);\n          });\n          rows.forEach(function (row) {\n            var docId = rowToDocId(row);\n            var doc = docIdsToDocs.get(docId);\n            if (doc) {\n              row.doc = doc;\n            }\n          });\n          return finalResults;\n        });\n      } else {\n        return finalResults;\n      }\n    }\n    if (typeof opts.keys !== 'undefined') {\n      var keys = opts.keys;\n      var fetchPromises = keys.map(function (key) {\n        var viewOpts = {\n          startkey: toIndexableString([key]),\n          endkey: toIndexableString([key, {}])\n        };\n        /* istanbul ignore if */\n        if (opts.update_seq) {\n          viewOpts.update_seq = true;\n        }\n        return fetchFromView(viewOpts);\n      });\n      return Promise.all(fetchPromises).then(flatten).then(onMapResultsReady);\n    } else {\n      // normal query, no 'keys'\n      var viewOpts = {\n        descending: opts.descending\n      };\n      /* istanbul ignore if */\n      if (opts.update_seq) {\n        viewOpts.update_seq = true;\n      }\n      var startkey;\n      var endkey;\n      if ('start_key' in opts) {\n        startkey = opts.start_key;\n      }\n      if ('startkey' in opts) {\n        startkey = opts.startkey;\n      }\n      if ('end_key' in opts) {\n        endkey = opts.end_key;\n      }\n      if ('endkey' in opts) {\n        endkey = opts.endkey;\n      }\n      if (typeof startkey !== 'undefined') {\n        viewOpts.startkey = opts.descending ? toIndexableString([startkey, {}]) : toIndexableString([startkey]);\n      }\n      if (typeof endkey !== 'undefined') {\n        var inclusiveEnd = opts.inclusive_end !== false;\n        if (opts.descending) {\n          inclusiveEnd = !inclusiveEnd;\n        }\n        viewOpts.endkey = toIndexableString(inclusiveEnd ? [endkey, {}] : [endkey]);\n      }\n      if (typeof opts.key !== 'undefined') {\n        var keyStart = toIndexableString([opts.key]);\n        var keyEnd = toIndexableString([opts.key, {}]);\n        if (viewOpts.descending) {\n          viewOpts.endkey = keyStart;\n          viewOpts.startkey = keyEnd;\n        } else {\n          viewOpts.startkey = keyStart;\n          viewOpts.endkey = keyEnd;\n        }\n      }\n      if (!shouldReduce) {\n        if (typeof opts.limit === 'number') {\n          viewOpts.limit = opts.limit;\n        }\n        viewOpts.skip = skip;\n      }\n      return fetchFromView(viewOpts).then(onMapResultsReady);\n    }\n  }\n  function httpViewCleanup(db) {\n    return db.fetch('_view_cleanup', {\n      headers: new Headers({\n        'Content-Type': 'application/json'\n      }),\n      method: 'POST'\n    }).then(function (response) {\n      return response.json();\n    });\n  }\n  function localViewCleanup(db) {\n    return db.get('_local/' + localDocName).then(function (metaDoc) {\n      var docsToViews = new Map();\n      Object.keys(metaDoc.views).forEach(function (fullViewName) {\n        var parts = parseViewName(fullViewName);\n        var designDocName = '_design/' + parts[0];\n        var viewName = parts[1];\n        var views = docsToViews.get(designDocName);\n        if (!views) {\n          views = new Set();\n          docsToViews.set(designDocName, views);\n        }\n        views.add(viewName);\n      });\n      var opts = {\n        keys: mapToKeysArray(docsToViews),\n        include_docs: true\n      };\n      return db.allDocs(opts).then(function (res) {\n        var viewsToStatus = {};\n        res.rows.forEach(function (row) {\n          var ddocName = row.key.substring(8); // cuts off '_design/'\n          docsToViews.get(row.key).forEach(function (viewName) {\n            var fullViewName = ddocName + '/' + viewName;\n            /* istanbul ignore if */\n            if (!metaDoc.views[fullViewName]) {\n              // new format, without slashes, to support PouchDB 2.2.0\n              // migration test in pouchdb's browser.migration.js verifies this\n              fullViewName = viewName;\n            }\n            var viewDBNames = Object.keys(metaDoc.views[fullViewName]);\n            // design doc deleted, or view function nonexistent\n            var statusIsGood = row.doc && row.doc.views && row.doc.views[viewName];\n            viewDBNames.forEach(function (viewDBName) {\n              viewsToStatus[viewDBName] = viewsToStatus[viewDBName] || statusIsGood;\n            });\n          });\n        });\n        var dbsToDelete = Object.keys(viewsToStatus).filter(function (viewDBName) {\n          return !viewsToStatus[viewDBName];\n        });\n        var destroyPromises = dbsToDelete.map(function (viewDBName) {\n          return sequentialize(getQueue(viewDBName), function () {\n            return new db.constructor(viewDBName, db.__opts).destroy();\n          })();\n        });\n        return Promise.all(destroyPromises).then(function () {\n          return {\n            ok: true\n          };\n        });\n      });\n    }, defaultsTo({\n      ok: true\n    }));\n  }\n  function queryPromised(db, fun, opts) {\n    /* istanbul ignore next */\n    if (typeof db._query === 'function') {\n      return customQuery(db, fun, opts);\n    }\n    if (isRemote(db)) {\n      return httpQuery(db, fun, opts);\n    }\n    var updateViewOpts = {\n      changes_batch_size: db.__opts.view_update_changes_batch_size || CHANGES_BATCH_SIZE\n    };\n    if (typeof fun !== 'string') {\n      // temp_view\n      checkQueryParseError(opts, fun);\n      tempViewQueue.add(function () {\n        var createViewPromise = createView( /* sourceDB */db, /* viewName */'temp_view/temp_view', /* mapFun */fun.map, /* reduceFun */fun.reduce, /* temporary */true, /* localDocName */localDocName);\n        return createViewPromise.then(function (view) {\n          return fin(updateView(view, updateViewOpts).then(function () {\n            return queryView(view, opts);\n          }), function () {\n            return view.db.destroy();\n          });\n        });\n      });\n      return tempViewQueue.finish();\n    } else {\n      // persistent view\n      var fullViewName = fun;\n      var parts = parseViewName(fullViewName);\n      var designDocName = parts[0];\n      var viewName = parts[1];\n      return db.get('_design/' + designDocName).then(function (doc) {\n        var fun = doc.views && doc.views[viewName];\n        if (!fun) {\n          // basic validator; it's assumed that every subclass would want this\n          throw new NotFoundError('ddoc ' + doc._id + ' has no view named ' + viewName);\n        }\n        ddocValidator(doc, viewName);\n        checkQueryParseError(opts, fun);\n        var createViewPromise = createView( /* sourceDB */db, /* viewName */fullViewName, /* mapFun */fun.map, /* reduceFun */fun.reduce, /* temporary */false, /* localDocName */localDocName);\n        return createViewPromise.then(function (view) {\n          if (opts.stale === 'ok' || opts.stale === 'update_after') {\n            if (opts.stale === 'update_after') {\n              nextTick(function () {\n                updateView(view, updateViewOpts);\n              });\n            }\n            return queryView(view, opts);\n          } else {\n            // stale not ok\n            return updateView(view, updateViewOpts).then(function () {\n              return queryView(view, opts);\n            });\n          }\n        });\n      });\n    }\n  }\n  function abstractQuery(fun, opts, callback) {\n    var db = this;\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = opts ? coerceOptions(opts) : {};\n    if (typeof fun === 'function') {\n      fun = {\n        map: fun\n      };\n    }\n    var promise = Promise.resolve().then(function () {\n      return queryPromised(db, fun, opts);\n    });\n    promisedCallback(promise, callback);\n    return promise;\n  }\n  var abstractViewCleanup = callbackify(function () {\n    var db = this;\n    /* istanbul ignore next */\n    if (typeof db._viewCleanup === 'function') {\n      return customViewCleanup(db);\n    }\n    if (isRemote(db)) {\n      return httpViewCleanup(db);\n    }\n    return localViewCleanup(db);\n  });\n  return {\n    query: abstractQuery,\n    viewCleanup: abstractViewCleanup\n  };\n}\nexport default createAbstractMapReduce;","map":{"version":3,"names":["Set","Map","base64StringToBlobOrBuffer","collate","toIndexableString","normalizeKey","parseIndexableString","generateErrorFromResponse","Headers","upsert","flatten","guardedConsole","nextTick","isRemote","stringMd5","callbackify","sequentialize","uniq","fin","promisedCallback","mapToKeysArray","QueryParseError","NotFoundError","BuiltInError","TaskQueue","promise","Promise","fulfill","prototype","add","promiseFactory","catch","then","finish","stringify","input","toString","JSON","createViewSignature","mapFun","reduceFun","createView","sourceDB","viewName","temporary","localDocName","viewSignature","cachedViews","_cachedViews","promiseForView","info","depDbName","db_name","diffFunction","doc","views","fullViewName","indexOf","depDbs","registerDependentDatabase","res","db","auto_compaction","view","name","adapter","get","err","status","lastSeqDoc","seq","once","persistentQueues","tempViewQueue","CHANGES_BATCH_SIZE","parseViewName","split","isGenOne","changes","length","test","rev","emitError","e","data","emit","createAbstractMapReduce","mapper","reducer","ddocValidator","tryMap","fun","tryReduce","keys","values","rereduce","output","error","sortByKeyThenValue","x","y","keyCompare","key","value","sliceResults","results","limit","skip","slice","rowToDocId","row","val","docId","_id","id","readAttachmentsAsBlobOrBuffer","rows","forEach","atts","_attachments","Object","filename","att","content_type","postprocessAttachments","opts","include_docs","attachments","binary","addHttpParam","paramName","params","asJson","encodeURIComponent","push","coerceInteger","integerCandidate","asNumber","Number","isNaN","parseInt","coerceOptions","group_level","checkPositiveInteger","number","checkQueryParseError","options","startkeyName","descending","endkeyName","reduce","group","optionName","httpQuery","body","method","ok","join","MAX_URL_LENGTH","keysAsString","parts","fetch","headers","response","json","result","Error","reason","Array","isArray","customQuery","resolve","reject","_query","customViewCleanup","_viewCleanup","defaultsTo","getDocsToPersist","docIdsToChangesAndEmits","metaDocId","defaultMetaDoc","docData","indexableKeysToKeyValues","getMetaDoc","getKeyValueDocs","metaDoc","allDocs","processKeyValueDocs","kvDocsRes","kvDocs","oldKeys","i","len","_deleted","has","keyValue","newKeys","kvDoc","concat","saveKeyValues","seqDocId","docIds","all","map","listOfDocsToPersist","docsToPersist","bulkDocs","docs","getQueue","queue","updateView","updateViewInQueue","mapResults","currentSeq","processChange","indexed_docs","progress","processNextBatch","return_docs","conflicts","style","since","changes_batch_size","processBatch","createDocIdsToChangesAndEmits","last_seq","results_count","change","sort","createIndexableKeysToKeyValues","set","lastKey","emittedKeyValue","complexKey","reduceView","shouldGroup","groups","lvl","POSITIVE_INFINITY","last","groupKey","reduceTry","queryView","queryViewInQueue","totalRows","shouldReduce","fetchFromView","viewOpts","total_rows","expectedKeys","parsedKeyAndDocId","onMapResultsReady","finalResults","offset","update_seq","allDocsRes","docIdsToDocs","fetchPromises","startkey","endkey","start_key","end_key","inclusiveEnd","inclusive_end","keyStart","keyEnd","httpViewCleanup","localViewCleanup","docsToViews","designDocName","viewsToStatus","ddocName","substring","viewDBNames","statusIsGood","viewDBName","dbsToDelete","filter","destroyPromises","constructor","__opts","destroy","queryPromised","updateViewOpts","view_update_changes_batch_size","createViewPromise","stale","abstractQuery","callback","abstractViewCleanup","query","viewCleanup"],"sources":["/home/sol/Documentos/AUS/3ro segundo cuatri/ing 2/URV/node_modules/pouchdb-abstract-mapreduce/lib/index.es.js"],"sourcesContent":["import { Set, Map } from 'pouchdb-collections';\nimport { base64StringToBlobOrBuffer } from 'pouchdb-binary-utils';\nimport { collate, toIndexableString, normalizeKey, parseIndexableString } from 'pouchdb-collate';\nimport { generateErrorFromResponse } from 'pouchdb-errors';\nimport { Headers } from 'pouchdb-fetch';\nimport { upsert, flatten, guardedConsole, nextTick, isRemote } from 'pouchdb-utils';\nimport { stringMd5 } from 'pouchdb-md5';\nimport { callbackify, sequentialize, uniq, fin, promisedCallback, mapToKeysArray, QueryParseError, NotFoundError, BuiltInError } from 'pouchdb-mapreduce-utils';\n\n/*\n * Simple task queue to sequentialize actions. Assumes\n * callbacks will eventually fire (once).\n */\n\n\nfunction TaskQueue() {\n  this.promise = new Promise(function (fulfill) {fulfill(); });\n}\nTaskQueue.prototype.add = function (promiseFactory) {\n  this.promise = this.promise.catch(function () {\n    // just recover\n  }).then(function () {\n    return promiseFactory();\n  });\n  return this.promise;\n};\nTaskQueue.prototype.finish = function () {\n  return this.promise;\n};\n\nfunction stringify(input) {\n  if (!input) {\n    return 'undefined'; // backwards compat for empty reduce\n  }\n  // for backwards compat with mapreduce, functions/strings are stringified\n  // as-is. everything else is JSON-stringified.\n  switch (typeof input) {\n    case 'function':\n      // e.g. a mapreduce map\n      return input.toString();\n    case 'string':\n      // e.g. a mapreduce built-in _reduce function\n      return input.toString();\n    default:\n      // e.g. a JSON object in the case of mango queries\n      return JSON.stringify(input);\n  }\n}\n\n/* create a string signature for a view so we can cache it and uniq it */\nfunction createViewSignature(mapFun, reduceFun) {\n  // the \"undefined\" part is for backwards compatibility\n  return stringify(mapFun) + stringify(reduceFun) + 'undefined';\n}\n\nfunction createView(sourceDB, viewName, mapFun, reduceFun, temporary, localDocName) {\n  var viewSignature = createViewSignature(mapFun, reduceFun);\n\n  var cachedViews;\n  if (!temporary) {\n    // cache this to ensure we don't try to update the same view twice\n    cachedViews = sourceDB._cachedViews = sourceDB._cachedViews || {};\n    if (cachedViews[viewSignature]) {\n      return cachedViews[viewSignature];\n    }\n  }\n\n  var promiseForView = sourceDB.info().then(function (info) {\n\n    var depDbName = info.db_name + '-mrview-' +\n      (temporary ? 'temp' : stringMd5(viewSignature));\n\n    // save the view name in the source db so it can be cleaned up if necessary\n    // (e.g. when the _design doc is deleted, remove all associated view data)\n    function diffFunction(doc) {\n      doc.views = doc.views || {};\n      var fullViewName = viewName;\n      if (fullViewName.indexOf('/') === -1) {\n        fullViewName = viewName + '/' + viewName;\n      }\n      var depDbs = doc.views[fullViewName] = doc.views[fullViewName] || {};\n      /* istanbul ignore if */\n      if (depDbs[depDbName]) {\n        return; // no update necessary\n      }\n      depDbs[depDbName] = true;\n      return doc;\n    }\n    return upsert(sourceDB, '_local/' + localDocName, diffFunction).then(function () {\n      return sourceDB.registerDependentDatabase(depDbName).then(function (res) {\n        var db = res.db;\n        db.auto_compaction = true;\n        var view = {\n          name: depDbName,\n          db: db,\n          sourceDB: sourceDB,\n          adapter: sourceDB.adapter,\n          mapFun: mapFun,\n          reduceFun: reduceFun\n        };\n        return view.db.get('_local/lastSeq').catch(function (err) {\n          /* istanbul ignore if */\n          if (err.status !== 404) {\n            throw err;\n          }\n        }).then(function (lastSeqDoc) {\n          view.seq = lastSeqDoc ? lastSeqDoc.seq : 0;\n          if (cachedViews) {\n            view.db.once('destroyed', function () {\n              delete cachedViews[viewSignature];\n            });\n          }\n          return view;\n        });\n      });\n    });\n  });\n\n  if (cachedViews) {\n    cachedViews[viewSignature] = promiseForView;\n  }\n  return promiseForView;\n}\n\nvar persistentQueues = {};\nvar tempViewQueue = new TaskQueue();\nvar CHANGES_BATCH_SIZE = 50;\n\nfunction parseViewName(name) {\n  // can be either 'ddocname/viewname' or just 'viewname'\n  // (where the ddoc name is the same)\n  return name.indexOf('/') === -1 ? [name, name] : name.split('/');\n}\n\nfunction isGenOne(changes) {\n  // only return true if the current change is 1-\n  // and there are no other leafs\n  return changes.length === 1 && /^1-/.test(changes[0].rev);\n}\n\nfunction emitError(db, e, data) {\n  try {\n    db.emit('error', e);\n  } catch (err) {\n    guardedConsole('error',\n      'The user\\'s map/reduce function threw an uncaught error.\\n' +\n      'You can debug this error by doing:\\n' +\n      'myDatabase.on(\\'error\\', function (err) { debugger; });\\n' +\n      'Please double-check your map/reduce function.');\n    guardedConsole('error', e, data);\n  }\n}\n\n/**\n * Returns an \"abstract\" mapreduce object of the form:\n *\n *   {\n *     query: queryFun,\n *     viewCleanup: viewCleanupFun\n *   }\n *\n * Arguments are:\n *\n * localDoc: string\n *   This is for the local doc that gets saved in order to track the\n *   \"dependent\" DBs and clean them up for viewCleanup. It should be\n *   unique, so that indexer plugins don't collide with each other.\n * mapper: function (mapFunDef, emit)\n *   Returns a map function based on the mapFunDef, which in the case of\n *   normal map/reduce is just the de-stringified function, but may be\n *   something else, such as an object in the case of pouchdb-find.\n * reducer: function (reduceFunDef)\n *   Ditto, but for reducing. Modules don't have to support reducing\n *   (e.g. pouchdb-find).\n * ddocValidator: function (ddoc, viewName)\n *   Throws an error if the ddoc or viewName is not valid.\n *   This could be a way to communicate to the user that the configuration for the\n *   indexer is invalid.\n */\nfunction createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator) {\n\n  function tryMap(db, fun, doc) {\n    // emit an event if there was an error thrown by a map function.\n    // putting try/catches in a single function also avoids deoptimizations.\n    try {\n      fun(doc);\n    } catch (e) {\n      emitError(db, e, {fun: fun, doc: doc});\n    }\n  }\n\n  function tryReduce(db, fun, keys, values, rereduce) {\n    // same as above, but returning the result or an error. there are two separate\n    // functions to avoid extra memory allocations since the tryCode() case is used\n    // for custom map functions (common) vs this function, which is only used for\n    // custom reduce functions (rare)\n    try {\n      return {output : fun(keys, values, rereduce)};\n    } catch (e) {\n      emitError(db, e, {fun: fun, keys: keys, values: values, rereduce: rereduce});\n      return {error: e};\n    }\n  }\n\n  function sortByKeyThenValue(x, y) {\n    var keyCompare = collate(x.key, y.key);\n    return keyCompare !== 0 ? keyCompare : collate(x.value, y.value);\n  }\n\n  function sliceResults(results, limit, skip) {\n    skip = skip || 0;\n    if (typeof limit === 'number') {\n      return results.slice(skip, limit + skip);\n    } else if (skip > 0) {\n      return results.slice(skip);\n    }\n    return results;\n  }\n\n  function rowToDocId(row) {\n    var val = row.value;\n    // Users can explicitly specify a joined doc _id, or it\n    // defaults to the doc _id that emitted the key/value.\n    var docId = (val && typeof val === 'object' && val._id) || row.id;\n    return docId;\n  }\n\n  function readAttachmentsAsBlobOrBuffer(res) {\n    res.rows.forEach(function (row) {\n      var atts = row.doc && row.doc._attachments;\n      if (!atts) {\n        return;\n      }\n      Object.keys(atts).forEach(function (filename) {\n        var att = atts[filename];\n        atts[filename].data = base64StringToBlobOrBuffer(att.data, att.content_type);\n      });\n    });\n  }\n\n  function postprocessAttachments(opts) {\n    return function (res) {\n      if (opts.include_docs && opts.attachments && opts.binary) {\n        readAttachmentsAsBlobOrBuffer(res);\n      }\n      return res;\n    };\n  }\n\n  function addHttpParam(paramName, opts, params, asJson) {\n    // add an http param from opts to params, optionally json-encoded\n    var val = opts[paramName];\n    if (typeof val !== 'undefined') {\n      if (asJson) {\n        val = encodeURIComponent(JSON.stringify(val));\n      }\n      params.push(paramName + '=' + val);\n    }\n  }\n\n  function coerceInteger(integerCandidate) {\n    if (typeof integerCandidate !== 'undefined') {\n      var asNumber = Number(integerCandidate);\n      // prevents e.g. '1foo' or '1.1' being coerced to 1\n      if (!isNaN(asNumber) && asNumber === parseInt(integerCandidate, 10)) {\n        return asNumber;\n      } else {\n        return integerCandidate;\n      }\n    }\n  }\n\n  function coerceOptions(opts) {\n    opts.group_level = coerceInteger(opts.group_level);\n    opts.limit = coerceInteger(opts.limit);\n    opts.skip = coerceInteger(opts.skip);\n    return opts;\n  }\n\n  function checkPositiveInteger(number) {\n    if (number) {\n      if (typeof number !== 'number') {\n        return  new QueryParseError('Invalid value for integer: \"' +\n          number + '\"');\n      }\n      if (number < 0) {\n        return new QueryParseError('Invalid value for positive integer: ' +\n          '\"' + number + '\"');\n      }\n    }\n  }\n\n  function checkQueryParseError(options, fun) {\n    var startkeyName = options.descending ? 'endkey' : 'startkey';\n    var endkeyName = options.descending ? 'startkey' : 'endkey';\n\n    if (typeof options[startkeyName] !== 'undefined' &&\n      typeof options[endkeyName] !== 'undefined' &&\n      collate(options[startkeyName], options[endkeyName]) > 0) {\n      throw new QueryParseError('No rows can match your key range, ' +\n        'reverse your start_key and end_key or set {descending : true}');\n    } else if (fun.reduce && options.reduce !== false) {\n      if (options.include_docs) {\n        throw new QueryParseError('{include_docs:true} is invalid for reduce');\n      } else if (options.keys && options.keys.length > 1 &&\n        !options.group && !options.group_level) {\n        throw new QueryParseError('Multi-key fetches for reduce views must use ' +\n          '{group: true}');\n      }\n    }\n    ['group_level', 'limit', 'skip'].forEach(function (optionName) {\n      var error = checkPositiveInteger(options[optionName]);\n      if (error) {\n        throw error;\n      }\n    });\n  }\n\n  function httpQuery(db, fun, opts) {\n    // List of parameters to add to the PUT request\n    var params = [];\n    var body;\n    var method = 'GET';\n    var ok, status;\n\n    // If opts.reduce exists and is defined, then add it to the list\n    // of parameters.\n    // If reduce=false then the results are that of only the map function\n    // not the final result of map and reduce.\n    addHttpParam('reduce', opts, params);\n    addHttpParam('include_docs', opts, params);\n    addHttpParam('attachments', opts, params);\n    addHttpParam('limit', opts, params);\n    addHttpParam('descending', opts, params);\n    addHttpParam('group', opts, params);\n    addHttpParam('group_level', opts, params);\n    addHttpParam('skip', opts, params);\n    addHttpParam('stale', opts, params);\n    addHttpParam('conflicts', opts, params);\n    addHttpParam('startkey', opts, params, true);\n    addHttpParam('start_key', opts, params, true);\n    addHttpParam('endkey', opts, params, true);\n    addHttpParam('end_key', opts, params, true);\n    addHttpParam('inclusive_end', opts, params);\n    addHttpParam('key', opts, params, true);\n    addHttpParam('update_seq', opts, params);\n\n    // Format the list of parameters into a valid URI query string\n    params = params.join('&');\n    params = params === '' ? '' : '?' + params;\n\n    // If keys are supplied, issue a POST to circumvent GET query string limits\n    // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options\n    if (typeof opts.keys !== 'undefined') {\n      var MAX_URL_LENGTH = 2000;\n      // according to http://stackoverflow.com/a/417184/680742,\n      // the de facto URL length limit is 2000 characters\n\n      var keysAsString =\n        'keys=' + encodeURIComponent(JSON.stringify(opts.keys));\n      if (keysAsString.length + params.length + 1 <= MAX_URL_LENGTH) {\n        // If the keys are short enough, do a GET. we do this to work around\n        // Safari not understanding 304s on POSTs (see pouchdb/pouchdb#1239)\n        params += (params[0] === '?' ? '&' : '?') + keysAsString;\n      } else {\n        method = 'POST';\n        if (typeof fun === 'string') {\n          body = {keys: opts.keys};\n        } else { // fun is {map : mapfun}, so append to this\n          fun.keys = opts.keys;\n        }\n      }\n    }\n\n    // We are referencing a query defined in the design doc\n    if (typeof fun === 'string') {\n      var parts = parseViewName(fun);\n      return db.fetch('_design/' + parts[0] + '/_view/' + parts[1] + params, {\n        headers: new Headers({'Content-Type': 'application/json'}),\n        method: method,\n        body: JSON.stringify(body)\n      }).then(function (response) {\n        ok = response.ok;\n        status = response.status;\n        return response.json();\n      }).then(function (result) {\n        if (!ok) {\n          result.status = status;\n          throw generateErrorFromResponse(result);\n        }\n        // fail the entire request if the result contains an error\n        result.rows.forEach(function (row) {\n          /* istanbul ignore if */\n          if (row.value && row.value.error && row.value.error === \"builtin_reduce_error\") {\n            throw new Error(row.reason);\n          }\n        });\n        return result;\n      }).then(postprocessAttachments(opts));\n    }\n\n    // We are using a temporary view, terrible for performance, good for testing\n    body = body || {};\n    Object.keys(fun).forEach(function (key) {\n      if (Array.isArray(fun[key])) {\n        body[key] = fun[key];\n      } else {\n        body[key] = fun[key].toString();\n      }\n    });\n\n    return db.fetch('_temp_view' + params, {\n      headers: new Headers({'Content-Type': 'application/json'}),\n      method: 'POST',\n      body: JSON.stringify(body)\n    }).then(function (response) {\n        ok = response.ok;\n        status = response.status;\n      return response.json();\n    }).then(function (result) {\n      if (!ok) {\n        result.status = status;\n        throw generateErrorFromResponse(result);\n      }\n      return result;\n    }).then(postprocessAttachments(opts));\n  }\n\n  // custom adapters can define their own api._query\n  // and override the default behavior\n  /* istanbul ignore next */\n  function customQuery(db, fun, opts) {\n    return new Promise(function (resolve, reject) {\n      db._query(fun, opts, function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  // custom adapters can define their own api._viewCleanup\n  // and override the default behavior\n  /* istanbul ignore next */\n  function customViewCleanup(db) {\n    return new Promise(function (resolve, reject) {\n      db._viewCleanup(function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  function defaultsTo(value) {\n    return function (reason) {\n      /* istanbul ignore else */\n      if (reason.status === 404) {\n        return value;\n      } else {\n        throw reason;\n      }\n    };\n  }\n\n  // returns a promise for a list of docs to update, based on the input docId.\n  // the order doesn't matter, because post-3.2.0, bulkDocs\n  // is an atomic operation in all three adapters.\n  function getDocsToPersist(docId, view, docIdsToChangesAndEmits) {\n    var metaDocId = '_local/doc_' + docId;\n    var defaultMetaDoc = {_id: metaDocId, keys: []};\n    var docData = docIdsToChangesAndEmits.get(docId);\n    var indexableKeysToKeyValues = docData[0];\n    var changes = docData[1];\n\n    function getMetaDoc() {\n      if (isGenOne(changes)) {\n        // generation 1, so we can safely assume initial state\n        // for performance reasons (avoids unnecessary GETs)\n        return Promise.resolve(defaultMetaDoc);\n      }\n      return view.db.get(metaDocId).catch(defaultsTo(defaultMetaDoc));\n    }\n\n    function getKeyValueDocs(metaDoc) {\n      if (!metaDoc.keys.length) {\n        // no keys, no need for a lookup\n        return Promise.resolve({rows: []});\n      }\n      return view.db.allDocs({\n        keys: metaDoc.keys,\n        include_docs: true\n      });\n    }\n\n    function processKeyValueDocs(metaDoc, kvDocsRes) {\n      var kvDocs = [];\n      var oldKeys = new Set();\n\n      for (var i = 0, len = kvDocsRes.rows.length; i < len; i++) {\n        var row = kvDocsRes.rows[i];\n        var doc = row.doc;\n        if (!doc) { // deleted\n          continue;\n        }\n        kvDocs.push(doc);\n        oldKeys.add(doc._id);\n        doc._deleted = !indexableKeysToKeyValues.has(doc._id);\n        if (!doc._deleted) {\n          var keyValue = indexableKeysToKeyValues.get(doc._id);\n          if ('value' in keyValue) {\n            doc.value = keyValue.value;\n          }\n        }\n      }\n      var newKeys = mapToKeysArray(indexableKeysToKeyValues);\n      newKeys.forEach(function (key) {\n        if (!oldKeys.has(key)) {\n          // new doc\n          var kvDoc = {\n            _id: key\n          };\n          var keyValue = indexableKeysToKeyValues.get(key);\n          if ('value' in keyValue) {\n            kvDoc.value = keyValue.value;\n          }\n          kvDocs.push(kvDoc);\n        }\n      });\n      metaDoc.keys = uniq(newKeys.concat(metaDoc.keys));\n      kvDocs.push(metaDoc);\n\n      return kvDocs;\n    }\n\n    return getMetaDoc().then(function (metaDoc) {\n      return getKeyValueDocs(metaDoc).then(function (kvDocsRes) {\n        return processKeyValueDocs(metaDoc, kvDocsRes);\n      });\n    });\n  }\n\n  // updates all emitted key/value docs and metaDocs in the mrview database\n  // for the given batch of documents from the source database\n  function saveKeyValues(view, docIdsToChangesAndEmits, seq) {\n    var seqDocId = '_local/lastSeq';\n    return view.db.get(seqDocId)\n      .catch(defaultsTo({_id: seqDocId, seq: 0}))\n      .then(function (lastSeqDoc) {\n        var docIds = mapToKeysArray(docIdsToChangesAndEmits);\n        return Promise.all(docIds.map(function (docId) {\n          return getDocsToPersist(docId, view, docIdsToChangesAndEmits);\n        })).then(function (listOfDocsToPersist) {\n          var docsToPersist = flatten(listOfDocsToPersist);\n          lastSeqDoc.seq = seq;\n          docsToPersist.push(lastSeqDoc);\n          // write all docs in a single operation, update the seq once\n          return view.db.bulkDocs({docs : docsToPersist});\n        });\n      });\n  }\n\n  function getQueue(view) {\n    var viewName = typeof view === 'string' ? view : view.name;\n    var queue = persistentQueues[viewName];\n    if (!queue) {\n      queue = persistentQueues[viewName] = new TaskQueue();\n    }\n    return queue;\n  }\n\n  function updateView(view, opts) {\n    return sequentialize(getQueue(view), function () {\n      return updateViewInQueue(view, opts);\n    })();\n  }\n\n  function updateViewInQueue(view, opts) {\n    // bind the emit function once\n    var mapResults;\n    var doc;\n\n    function emit(key, value) {\n      var output = {id: doc._id, key: normalizeKey(key)};\n      // Don't explicitly store the value unless it's defined and non-null.\n      // This saves on storage space, because often people don't use it.\n      if (typeof value !== 'undefined' && value !== null) {\n        output.value = normalizeKey(value);\n      }\n      mapResults.push(output);\n    }\n\n    var mapFun = mapper(view.mapFun, emit);\n\n    var currentSeq = view.seq || 0;\n\n    function processChange(docIdsToChangesAndEmits, seq) {\n      return function () {\n        return saveKeyValues(view, docIdsToChangesAndEmits, seq);\n      };\n    }\n\n    let indexed_docs = 0;\n    let progress = {\n      view: view.name,\n      indexed_docs: indexed_docs\n    };\n    view.sourceDB.emit('indexing', progress);\n\n    var queue = new TaskQueue();\n\n    function processNextBatch() {\n      return view.sourceDB.changes({\n        return_docs: true,\n        conflicts: true,\n        include_docs: true,\n        style: 'all_docs',\n        since: currentSeq,\n        limit: opts.changes_batch_size\n      }).then(processBatch);\n    }\n\n    function processBatch(response) {\n      var results = response.results;\n      if (!results.length) {\n        return;\n      }\n      var docIdsToChangesAndEmits = createDocIdsToChangesAndEmits(results);\n      queue.add(processChange(docIdsToChangesAndEmits, currentSeq));\n\n      indexed_docs = indexed_docs + results.length;\n      let progress = {\n        view: view.name,\n        last_seq: response.last_seq,\n        results_count: results.length,\n        indexed_docs: indexed_docs\n      };\n      view.sourceDB.emit('indexing', progress);\n      \n      if (results.length < opts.changes_batch_size) {\n        return;\n      }\n      return processNextBatch();\n    }\n\n    function createDocIdsToChangesAndEmits(results) {\n      var docIdsToChangesAndEmits = new Map();\n      for (var i = 0, len = results.length; i < len; i++) {\n        var change = results[i];\n        if (change.doc._id[0] !== '_') {\n          mapResults = [];\n          doc = change.doc;\n\n          if (!doc._deleted) {\n            tryMap(view.sourceDB, mapFun, doc);\n          }\n          mapResults.sort(sortByKeyThenValue);\n\n          var indexableKeysToKeyValues = createIndexableKeysToKeyValues(mapResults);\n          docIdsToChangesAndEmits.set(change.doc._id, [\n            indexableKeysToKeyValues,\n            change.changes\n          ]);\n        }\n        currentSeq = change.seq;\n      }\n      return docIdsToChangesAndEmits;\n    }\n\n    function createIndexableKeysToKeyValues(mapResults) {\n      var indexableKeysToKeyValues = new Map();\n      var lastKey;\n      for (var i = 0, len = mapResults.length; i < len; i++) {\n        var emittedKeyValue = mapResults[i];\n        var complexKey = [emittedKeyValue.key, emittedKeyValue.id];\n        if (i > 0 && collate(emittedKeyValue.key, lastKey) === 0) {\n          complexKey.push(i); // dup key+id, so make it unique\n        }\n        indexableKeysToKeyValues.set(toIndexableString(complexKey), emittedKeyValue);\n        lastKey = emittedKeyValue.key;\n      }\n      return indexableKeysToKeyValues;\n    }\n\n    return processNextBatch().then(function () {\n      return queue.finish();\n    }).then(function () {\n      view.seq = currentSeq;\n    });\n  }\n\n  function reduceView(view, results, options) {\n    if (options.group_level === 0) {\n      delete options.group_level;\n    }\n\n    var shouldGroup = options.group || options.group_level;\n\n    var reduceFun = reducer(view.reduceFun);\n\n    var groups = [];\n    var lvl = isNaN(options.group_level) ? Number.POSITIVE_INFINITY :\n      options.group_level;\n    results.forEach(function (e) {\n      var last = groups[groups.length - 1];\n      var groupKey = shouldGroup ? e.key : null;\n\n      // only set group_level for array keys\n      if (shouldGroup && Array.isArray(groupKey)) {\n        groupKey = groupKey.slice(0, lvl);\n      }\n\n      if (last && collate(last.groupKey, groupKey) === 0) {\n        last.keys.push([e.key, e.id]);\n        last.values.push(e.value);\n        return;\n      }\n      groups.push({\n        keys: [[e.key, e.id]],\n        values: [e.value],\n        groupKey: groupKey\n      });\n    });\n    results = [];\n    for (var i = 0, len = groups.length; i < len; i++) {\n      var e = groups[i];\n      var reduceTry = tryReduce(view.sourceDB, reduceFun, e.keys, e.values, false);\n      if (reduceTry.error && reduceTry.error instanceof BuiltInError) {\n        // CouchDB returns an error if a built-in errors out\n        throw reduceTry.error;\n      }\n      results.push({\n        // CouchDB just sets the value to null if a non-built-in errors out\n        value: reduceTry.error ? null : reduceTry.output,\n        key: e.groupKey\n      });\n    }\n    // no total_rows/offset when reducing\n    return {rows: sliceResults(results, options.limit, options.skip)};\n  }\n\n  function queryView(view, opts) {\n    return sequentialize(getQueue(view), function () {\n      return queryViewInQueue(view, opts);\n    })();\n  }\n\n  function queryViewInQueue(view, opts) {\n    var totalRows;\n    var shouldReduce = view.reduceFun && opts.reduce !== false;\n    var skip = opts.skip || 0;\n    if (typeof opts.keys !== 'undefined' && !opts.keys.length) {\n      // equivalent query\n      opts.limit = 0;\n      delete opts.keys;\n    }\n\n    function fetchFromView(viewOpts) {\n      viewOpts.include_docs = true;\n      return view.db.allDocs(viewOpts).then(function (res) {\n        totalRows = res.total_rows;\n        return res.rows.map(function (result) {\n\n          // implicit migration - in older versions of PouchDB,\n          // we explicitly stored the doc as {id: ..., key: ..., value: ...}\n          // this is tested in a migration test\n          /* istanbul ignore next */\n          if ('value' in result.doc && typeof result.doc.value === 'object' &&\n            result.doc.value !== null) {\n            var keys = Object.keys(result.doc.value).sort();\n            // this detection method is not perfect, but it's unlikely the user\n            // emitted a value which was an object with these 3 exact keys\n            var expectedKeys = ['id', 'key', 'value'];\n            if (!(keys < expectedKeys || keys > expectedKeys)) {\n              return result.doc.value;\n            }\n          }\n\n          var parsedKeyAndDocId = parseIndexableString(result.doc._id);\n          return {\n            key: parsedKeyAndDocId[0],\n            id: parsedKeyAndDocId[1],\n            value: ('value' in result.doc ? result.doc.value : null)\n          };\n        });\n      });\n    }\n\n    function onMapResultsReady(rows) {\n      var finalResults;\n      if (shouldReduce) {\n        finalResults = reduceView(view, rows, opts);\n      } else if (typeof opts.keys === 'undefined') {\n        finalResults = {\n          total_rows: totalRows,\n          offset: skip,\n          rows: rows\n        };\n      } else {\n        // support limit, skip for keys query\n        finalResults = {\n          total_rows: totalRows,\n          offset: skip,\n          rows: sliceResults(rows,opts.limit,opts.skip)\n        };\n      }\n      /* istanbul ignore if */\n      if (opts.update_seq) {\n        finalResults.update_seq = view.seq;\n      }\n      if (opts.include_docs) {\n        var docIds = uniq(rows.map(rowToDocId));\n\n        return view.sourceDB.allDocs({\n          keys: docIds,\n          include_docs: true,\n          conflicts: opts.conflicts,\n          attachments: opts.attachments,\n          binary: opts.binary\n        }).then(function (allDocsRes) {\n          var docIdsToDocs = new Map();\n          allDocsRes.rows.forEach(function (row) {\n            docIdsToDocs.set(row.id, row.doc);\n          });\n          rows.forEach(function (row) {\n            var docId = rowToDocId(row);\n            var doc = docIdsToDocs.get(docId);\n            if (doc) {\n              row.doc = doc;\n            }\n          });\n          return finalResults;\n        });\n      } else {\n        return finalResults;\n      }\n    }\n\n    if (typeof opts.keys !== 'undefined') {\n      var keys = opts.keys;\n      var fetchPromises = keys.map(function (key) {\n        var viewOpts = {\n          startkey : toIndexableString([key]),\n          endkey   : toIndexableString([key, {}])\n        };\n        /* istanbul ignore if */\n        if (opts.update_seq) {\n          viewOpts.update_seq = true;\n        }\n        return fetchFromView(viewOpts);\n      });\n      return Promise.all(fetchPromises).then(flatten).then(onMapResultsReady);\n    } else { // normal query, no 'keys'\n      var viewOpts = {\n        descending : opts.descending\n      };\n      /* istanbul ignore if */\n      if (opts.update_seq) {\n        viewOpts.update_seq = true;\n      }\n      var startkey;\n      var endkey;\n      if ('start_key' in opts) {\n        startkey = opts.start_key;\n      }\n      if ('startkey' in opts) {\n        startkey = opts.startkey;\n      }\n      if ('end_key' in opts) {\n        endkey = opts.end_key;\n      }\n      if ('endkey' in opts) {\n        endkey = opts.endkey;\n      }\n      if (typeof startkey !== 'undefined') {\n        viewOpts.startkey = opts.descending ?\n          toIndexableString([startkey, {}]) :\n          toIndexableString([startkey]);\n      }\n      if (typeof endkey !== 'undefined') {\n        var inclusiveEnd = opts.inclusive_end !== false;\n        if (opts.descending) {\n          inclusiveEnd = !inclusiveEnd;\n        }\n\n        viewOpts.endkey = toIndexableString(\n          inclusiveEnd ? [endkey, {}] : [endkey]);\n      }\n      if (typeof opts.key !== 'undefined') {\n        var keyStart = toIndexableString([opts.key]);\n        var keyEnd = toIndexableString([opts.key, {}]);\n        if (viewOpts.descending) {\n          viewOpts.endkey = keyStart;\n          viewOpts.startkey = keyEnd;\n        } else {\n          viewOpts.startkey = keyStart;\n          viewOpts.endkey = keyEnd;\n        }\n      }\n      if (!shouldReduce) {\n        if (typeof opts.limit === 'number') {\n          viewOpts.limit = opts.limit;\n        }\n        viewOpts.skip = skip;\n      }\n      return fetchFromView(viewOpts).then(onMapResultsReady);\n    }\n  }\n\n  function httpViewCleanup(db) {\n    return db.fetch('_view_cleanup', {\n      headers: new Headers({'Content-Type': 'application/json'}),\n      method: 'POST'\n    }).then(function (response) {\n      return response.json();\n    });\n  }\n\n  function localViewCleanup(db) {\n    return db.get('_local/' + localDocName).then(function (metaDoc) {\n      var docsToViews = new Map();\n      Object.keys(metaDoc.views).forEach(function (fullViewName) {\n        var parts = parseViewName(fullViewName);\n        var designDocName = '_design/' + parts[0];\n        var viewName = parts[1];\n        var views = docsToViews.get(designDocName);\n        if (!views) {\n          views = new Set();\n          docsToViews.set(designDocName, views);\n        }\n        views.add(viewName);\n      });\n      var opts = {\n        keys : mapToKeysArray(docsToViews),\n        include_docs : true\n      };\n      return db.allDocs(opts).then(function (res) {\n        var viewsToStatus = {};\n        res.rows.forEach(function (row) {\n          var ddocName = row.key.substring(8); // cuts off '_design/'\n          docsToViews.get(row.key).forEach(function (viewName) {\n            var fullViewName = ddocName + '/' + viewName;\n            /* istanbul ignore if */\n            if (!metaDoc.views[fullViewName]) {\n              // new format, without slashes, to support PouchDB 2.2.0\n              // migration test in pouchdb's browser.migration.js verifies this\n              fullViewName = viewName;\n            }\n            var viewDBNames = Object.keys(metaDoc.views[fullViewName]);\n            // design doc deleted, or view function nonexistent\n            var statusIsGood = row.doc && row.doc.views &&\n              row.doc.views[viewName];\n            viewDBNames.forEach(function (viewDBName) {\n              viewsToStatus[viewDBName] =\n                viewsToStatus[viewDBName] || statusIsGood;\n            });\n          });\n        });\n        var dbsToDelete = Object.keys(viewsToStatus).filter(\n          function (viewDBName) { return !viewsToStatus[viewDBName]; });\n        var destroyPromises = dbsToDelete.map(function (viewDBName) {\n          return sequentialize(getQueue(viewDBName), function () {\n            return new db.constructor(viewDBName, db.__opts).destroy();\n          })();\n        });\n        return Promise.all(destroyPromises).then(function () {\n          return {ok: true};\n        });\n      });\n    }, defaultsTo({ok: true}));\n  }\n\n  function queryPromised(db, fun, opts) {\n    /* istanbul ignore next */\n    if (typeof db._query === 'function') {\n      return customQuery(db, fun, opts);\n    }\n    if (isRemote(db)) {\n      return httpQuery(db, fun, opts);\n    }\n\n    var updateViewOpts = {\n      changes_batch_size: db.__opts.view_update_changes_batch_size || CHANGES_BATCH_SIZE\n    };\n\n    if (typeof fun !== 'string') {\n      // temp_view\n      checkQueryParseError(opts, fun);\n\n      tempViewQueue.add(function () {\n        var createViewPromise = createView(\n          /* sourceDB */ db,\n          /* viewName */ 'temp_view/temp_view',\n          /* mapFun */ fun.map,\n          /* reduceFun */ fun.reduce,\n          /* temporary */ true,\n          /* localDocName */ localDocName);\n        return createViewPromise.then(function (view) {\n          return fin(updateView(view, updateViewOpts).then(function () {\n            return queryView(view, opts);\n          }), function () {\n            return view.db.destroy();\n          });\n        });\n      });\n      return tempViewQueue.finish();\n    } else {\n      // persistent view\n      var fullViewName = fun;\n      var parts = parseViewName(fullViewName);\n      var designDocName = parts[0];\n      var viewName = parts[1];\n      return db.get('_design/' + designDocName).then(function (doc) {\n        var fun = doc.views && doc.views[viewName];\n\n        if (!fun) {\n          // basic validator; it's assumed that every subclass would want this\n          throw new NotFoundError('ddoc ' + doc._id + ' has no view named ' +\n            viewName);\n        }\n\n        ddocValidator(doc, viewName);\n        checkQueryParseError(opts, fun);\n\n        var createViewPromise = createView(\n          /* sourceDB */ db,\n          /* viewName */ fullViewName,\n          /* mapFun */ fun.map,\n          /* reduceFun */ fun.reduce,\n          /* temporary */ false,\n          /* localDocName */ localDocName);\n        return createViewPromise.then(function (view) {\n          if (opts.stale === 'ok' || opts.stale === 'update_after') {\n            if (opts.stale === 'update_after') {\n              nextTick(function () {\n                updateView(view, updateViewOpts);\n              });\n            }\n            return queryView(view, opts);\n          } else { // stale not ok\n            return updateView(view, updateViewOpts).then(function () {\n              return queryView(view, opts);\n            });\n          }\n        });\n      });\n    }\n  }\n\n  function abstractQuery(fun, opts, callback) {\n    var db = this;\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = opts ? coerceOptions(opts) : {};\n\n    if (typeof fun === 'function') {\n      fun = {map : fun};\n    }\n\n    var promise = Promise.resolve().then(function () {\n      return queryPromised(db, fun, opts);\n    });\n    promisedCallback(promise, callback);\n    return promise;\n  }\n\n  var abstractViewCleanup = callbackify(function () {\n    var db = this;\n    /* istanbul ignore next */\n    if (typeof db._viewCleanup === 'function') {\n      return customViewCleanup(db);\n    }\n    if (isRemote(db)) {\n      return httpViewCleanup(db);\n    }\n    return localViewCleanup(db);\n  });\n\n  return {\n    query: abstractQuery,\n    viewCleanup: abstractViewCleanup\n  };\n}\n\nexport default createAbstractMapReduce;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}