{"ast":null,"code":"import { useEffect } from 'react';\nimport { matchesSelector } from 'pouchdb-selector-core';\nimport { useContext } from './context';\nimport useStateMachine from './state-machine';\nimport { useDeepMemo } from './utils';\n/**\n * Query, and optionally create, a Mango index and subscribe to its updates.\n * @param {object} [opts] A combination of PouchDB's find options and create index options.\n */\nexport default function useFind(options) {\n  const {\n    pouchdb: pouch,\n    subscriptionManager\n  } = useContext(options.db);\n  if (typeof (pouch === null || pouch === void 0 ? void 0 : pouch.createIndex) !== 'function' || typeof (pouch === null || pouch === void 0 ? void 0 : pouch.find) !== 'function') {\n    throw new TypeError('db.createIndex() or/and db.find() are not defined. Please install \"pouchdb-find\"');\n  }\n  const index = useDeepMemo(options.index);\n  const selector = useDeepMemo(options.selector);\n  const fields = useDeepMemo(options.fields);\n  const sort = useDeepMemo(options.sort);\n  const limit = options.limit;\n  const skip = options.skip;\n  const [state, dispatch] = useStateMachine(() => ({\n    docs: []\n  }));\n  useEffect(() => {\n    let isActive = true;\n    let isFetching = false;\n    let shouldUpdateAfter = false;\n    // if _id isn't in the fields array it will be added internally\n    const didAddIdToFields = Array.isArray(fields) && fields.length > 0 && !fields.includes('_id');\n    // internal fields-array. Ensure to always fetch _id\n    const fieldsToFetch = didAddIdToFields ? fields === null || fields === void 0 ? void 0 : fields.concat(['_id']) : fields;\n    // Container for the ids in the result. It is in a object to be used as a ref.\n    const idsInResult = {\n      ids: new Set()\n    };\n    let name = undefined;\n    let ddoc = undefined;\n    // Query a mango query and update the state.\n    const query = async () => {\n      if (isFetching) {\n        shouldUpdateAfter = true;\n        return;\n      }\n      isFetching = true;\n      dispatch({\n        type: 'loading_started'\n      });\n      try {\n        let indexToUse = undefined;\n        if (ddoc && name) {\n          indexToUse = [ddoc, name];\n        } else if (ddoc) {\n          indexToUse = ddoc;\n        }\n        const result = await pouch.find({\n          selector,\n          fields: fieldsToFetch,\n          sort,\n          limit,\n          skip,\n          use_index: indexToUse\n        });\n        if (isActive) {\n          idsInResult.ids = new Set();\n          for (const doc of result.docs) {\n            idsInResult.ids.add(doc._id);\n            // if _id was added to the fields array, remove it,\n            // so that the user only gets what they want.\n            if (didAddIdToFields) {\n              const removeDoc = doc;\n              delete removeDoc._id;\n            }\n          }\n          dispatch({\n            type: 'loading_finished',\n            payload: result\n          });\n        }\n      } catch (error) {\n        if (isActive) {\n          dispatch({\n            type: 'loading_error',\n            payload: {\n              error: error,\n              setResult: false\n            }\n          });\n        }\n      } finally {\n        isFetching = false;\n        // Re-query if a change did happen while querying\n        if (isActive && shouldUpdateAfter) {\n          shouldUpdateAfter = false;\n          query();\n        }\n      }\n    };\n    let unsubscribe = undefined;\n    dispatch({\n      type: 'loading_started'\n    });\n    // Create an index or get the index that will be used.\n    getIndex(pouch, index, {\n      selector\n    }).then(_ref => {\n      let [ddocId, indexName] = _ref;\n      if (!isActive) return;\n      if (ddocId) {\n        ddoc = ddocId;\n      }\n      name = indexName;\n      query();\n      unsubscribe = subscribe(subscriptionManager, selector, query, ddocId, idsInResult);\n    }).catch(error => {\n      if (isActive) {\n        dispatch({\n          type: 'loading_error',\n          payload: {\n            error,\n            setResult: false\n          }\n        });\n        query();\n        unsubscribe = subscribe(subscriptionManager, selector, query, null, idsInResult);\n      }\n    });\n    return () => {\n      isActive = false;\n      unsubscribe === null || unsubscribe === void 0 ? void 0 : unsubscribe();\n    };\n  }, [pouch, subscriptionManager, dispatch, index, selector, fields, sort, limit, skip]);\n  return state;\n}\n/**\n * Get the ddoc & name of an index. Create it if the index doesn't exist.\n * @param db        - The PouchDB database.\n * @param index     - Name or Create Index options.\n * @param selector  - The selector used.\n */\nfunction getIndex(db, index, selector) {\n  if (index && typeof index === 'string') {\n    return findIndex(db, selector);\n  } else if (index && Array.isArray(index)) {\n    return Promise.resolve(index);\n  } else if (index && typeof index === 'object') {\n    return createIndex(db, {\n      index\n    });\n  } else {\n    return findIndex(db, selector);\n  }\n}\n/**\n * Create an index. Returns the ddoc & name.\n * @param db - The PouchDB database.\n * @param index - Options for db.createIndex\n */\nasync function createIndex(db, index) {\n  const result = await db.createIndex(index);\n  return [result.id, result.name];\n}\n/**\n * Find a index for the given selector. Returns ddoc & name.\n * @param db - The PouchDB database.\n * @param selector - The selector used.\n */\nasync function findIndex(db, selector) {\n  const database = db;\n  const result = await database.explain(selector);\n  return [result.index.ddoc, result.index.name];\n}\n/**\n * Subscribes to updates in the database and re-query\n * when a document did change that matches the selector.\n * @param subscriptionManager - The current subscription manager.\n * @param selector - Selector, to filter out changes.\n * @param query - Function to run a query.\n * @param id - Id of the ddoc where the index is stored.\n * @param idsInResult - Object containing a Set of ids in the last result.\n */\nfunction subscribe(subscriptionManager, selector, query, id, idsInResult) {\n  const ddocName = id ? '_design/' + id.replace(/^_design\\//, '') // normalize, user can add a ddoc name\n  : undefined;\n  return subscriptionManager.subscribeToDocs(null, (_del, id, doc) => {\n    if (idsInResult.ids.has(id)) {\n      query();\n    } else if (id === ddocName) {\n      query();\n    } else if (doc && typeof matchesSelector !== 'function') {\n      // because pouchdb-selector-core is semver-free zone\n      // If matchesSelector doesn't exist, just query every time\n      query();\n    } else if (doc && matchesSelector(doc, selector)) {\n      query();\n    }\n  });\n}","map":{"version":3,"names":["useEffect","matchesSelector","useContext","useStateMachine","useDeepMemo","useFind","options","pouchdb","pouch","subscriptionManager","db","createIndex","find","TypeError","index","selector","fields","sort","limit","skip","state","dispatch","docs","isActive","isFetching","shouldUpdateAfter","didAddIdToFields","Array","isArray","length","includes","fieldsToFetch","concat","idsInResult","ids","Set","name","undefined","ddoc","query","type","indexToUse","result","use_index","doc","add","_id","removeDoc","payload","error","setResult","unsubscribe","getIndex","then","ddocId","indexName","subscribe","catch","findIndex","Promise","resolve","id","database","explain","ddocName","replace","subscribeToDocs","_del","has"],"sources":["/home/sol/Documentos/AUS/3ro segundo cuatri/ing 2/URV/node_modules/use-pouchdb/lib/useFind.js"],"sourcesContent":["import { useEffect } from 'react';\nimport { matchesSelector } from 'pouchdb-selector-core';\nimport { useContext } from './context';\nimport useStateMachine from './state-machine';\nimport { useDeepMemo } from './utils';\n/**\n * Query, and optionally create, a Mango index and subscribe to its updates.\n * @param {object} [opts] A combination of PouchDB's find options and create index options.\n */\nexport default function useFind(options) {\n    const { pouchdb: pouch, subscriptionManager } = useContext(options.db);\n    if (typeof (pouch === null || pouch === void 0 ? void 0 : pouch.createIndex) !== 'function' ||\n        typeof (pouch === null || pouch === void 0 ? void 0 : pouch.find) !== 'function') {\n        throw new TypeError('db.createIndex() or/and db.find() are not defined. Please install \"pouchdb-find\"');\n    }\n    const index = useDeepMemo(options.index);\n    const selector = useDeepMemo(options.selector);\n    const fields = useDeepMemo(options.fields);\n    const sort = useDeepMemo(options.sort);\n    const limit = options.limit;\n    const skip = options.skip;\n    const [state, dispatch] = useStateMachine(() => ({\n        docs: [],\n    }));\n    useEffect(() => {\n        let isActive = true;\n        let isFetching = false;\n        let shouldUpdateAfter = false;\n        // if _id isn't in the fields array it will be added internally\n        const didAddIdToFields = Array.isArray(fields) && fields.length > 0 && !fields.includes('_id');\n        // internal fields-array. Ensure to always fetch _id\n        const fieldsToFetch = didAddIdToFields ? fields === null || fields === void 0 ? void 0 : fields.concat(['_id']) : fields;\n        // Container for the ids in the result. It is in a object to be used as a ref.\n        const idsInResult = {\n            ids: new Set(),\n        };\n        let name = undefined;\n        let ddoc = undefined;\n        // Query a mango query and update the state.\n        const query = async () => {\n            if (isFetching) {\n                shouldUpdateAfter = true;\n                return;\n            }\n            isFetching = true;\n            dispatch({ type: 'loading_started' });\n            try {\n                let indexToUse = undefined;\n                if (ddoc && name) {\n                    indexToUse = [ddoc, name];\n                }\n                else if (ddoc) {\n                    indexToUse = ddoc;\n                }\n                const result = (await pouch.find({\n                    selector,\n                    fields: fieldsToFetch,\n                    sort,\n                    limit,\n                    skip,\n                    use_index: indexToUse,\n                }));\n                if (isActive) {\n                    idsInResult.ids = new Set();\n                    for (const doc of result.docs) {\n                        idsInResult.ids.add(doc._id);\n                        // if _id was added to the fields array, remove it,\n                        // so that the user only gets what they want.\n                        if (didAddIdToFields) {\n                            const removeDoc = doc;\n                            delete removeDoc._id;\n                        }\n                    }\n                    dispatch({ type: 'loading_finished', payload: result });\n                }\n            }\n            catch (error) {\n                if (isActive) {\n                    dispatch({\n                        type: 'loading_error',\n                        payload: { error: error, setResult: false },\n                    });\n                }\n            }\n            finally {\n                isFetching = false;\n                // Re-query if a change did happen while querying\n                if (isActive && shouldUpdateAfter) {\n                    shouldUpdateAfter = false;\n                    query();\n                }\n            }\n        };\n        let unsubscribe = undefined;\n        dispatch({ type: 'loading_started' });\n        // Create an index or get the index that will be used.\n        getIndex(pouch, index, { selector })\n            .then(([ddocId, indexName]) => {\n            if (!isActive)\n                return;\n            if (ddocId) {\n                ddoc = ddocId;\n            }\n            name = indexName;\n            query();\n            unsubscribe = subscribe(subscriptionManager, selector, query, ddocId, idsInResult);\n        })\n            .catch(error => {\n            if (isActive) {\n                dispatch({\n                    type: 'loading_error',\n                    payload: { error, setResult: false },\n                });\n                query();\n                unsubscribe = subscribe(subscriptionManager, selector, query, null, idsInResult);\n            }\n        });\n        return () => {\n            isActive = false;\n            unsubscribe === null || unsubscribe === void 0 ? void 0 : unsubscribe();\n        };\n    }, [\n        pouch,\n        subscriptionManager,\n        dispatch,\n        index,\n        selector,\n        fields,\n        sort,\n        limit,\n        skip,\n    ]);\n    return state;\n}\n/**\n * Get the ddoc & name of an index. Create it if the index doesn't exist.\n * @param db        - The PouchDB database.\n * @param index     - Name or Create Index options.\n * @param selector  - The selector used.\n */\nfunction getIndex(db, index, selector) {\n    if (index && typeof index === 'string') {\n        return findIndex(db, selector);\n    }\n    else if (index && Array.isArray(index)) {\n        return Promise.resolve(index);\n    }\n    else if (index && typeof index === 'object') {\n        return createIndex(db, { index });\n    }\n    else {\n        return findIndex(db, selector);\n    }\n}\n/**\n * Create an index. Returns the ddoc & name.\n * @param db - The PouchDB database.\n * @param index - Options for db.createIndex\n */\nasync function createIndex(db, index) {\n    const result = (await db.createIndex(index));\n    return [result.id, result.name];\n}\n/**\n * Find a index for the given selector. Returns ddoc & name.\n * @param db - The PouchDB database.\n * @param selector - The selector used.\n */\nasync function findIndex(db, selector) {\n    const database = db;\n    const result = await database.explain(selector);\n    return [result.index.ddoc, result.index.name];\n}\n/**\n * Subscribes to updates in the database and re-query\n * when a document did change that matches the selector.\n * @param subscriptionManager - The current subscription manager.\n * @param selector - Selector, to filter out changes.\n * @param query - Function to run a query.\n * @param id - Id of the ddoc where the index is stored.\n * @param idsInResult - Object containing a Set of ids in the last result.\n */\nfunction subscribe(subscriptionManager, selector, query, id, idsInResult) {\n    const ddocName = id\n        ? '_design/' + id.replace(/^_design\\//, '') // normalize, user can add a ddoc name\n        : undefined;\n    return subscriptionManager.subscribeToDocs(null, (_del, id, doc) => {\n        if (idsInResult.ids.has(id)) {\n            query();\n        }\n        else if (id === ddocName) {\n            query();\n        }\n        else if (doc && typeof matchesSelector !== 'function') {\n            // because pouchdb-selector-core is semver-free zone\n            // If matchesSelector doesn't exist, just query every time\n            query();\n        }\n        else if (doc && matchesSelector(doc, selector)) {\n            query();\n        }\n    });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}