{"ast":null,"code":"function pad(str, padWith, upToLength) {\n  var padding = '';\n  var targetLength = upToLength - str.length;\n  /* istanbul ignore next */\n  while (padding.length < targetLength) {\n    padding += padWith;\n  }\n  return padding;\n}\nfunction padLeft(str, padWith, upToLength) {\n  var padding = pad(str, padWith, upToLength);\n  return padding + str;\n}\nvar MIN_MAGNITUDE = -324; // verified by -Number.MIN_VALUE\nvar MAGNITUDE_DIGITS = 3; // ditto\nvar SEP = ''; // set to '_' for easier debugging\n\nfunction collate(a, b) {\n  if (a === b) {\n    return 0;\n  }\n  a = normalizeKey(a);\n  b = normalizeKey(b);\n  var ai = collationIndex(a);\n  var bi = collationIndex(b);\n  if (ai - bi !== 0) {\n    return ai - bi;\n  }\n  switch (typeof a) {\n    case 'number':\n      return a - b;\n    case 'boolean':\n      return a < b ? -1 : 1;\n    case 'string':\n      return stringCollate(a, b);\n  }\n  return Array.isArray(a) ? arrayCollate(a, b) : objectCollate(a, b);\n}\n\n// couch considers null/NaN/Infinity/-Infinity === undefined,\n// for the purposes of mapreduce indexes. also, dates get stringified.\nfunction normalizeKey(key) {\n  switch (typeof key) {\n    case 'undefined':\n      return null;\n    case 'number':\n      if (key === Infinity || key === -Infinity || isNaN(key)) {\n        return null;\n      }\n      return key;\n    case 'object':\n      var origKey = key;\n      if (Array.isArray(key)) {\n        var len = key.length;\n        key = new Array(len);\n        for (var i = 0; i < len; i++) {\n          key[i] = normalizeKey(origKey[i]);\n        }\n        /* istanbul ignore next */\n      } else if (key instanceof Date) {\n        return key.toJSON();\n      } else if (key !== null) {\n        // generic object\n        key = {};\n        for (var k in origKey) {\n          if (Object.prototype.hasOwnProperty.call(origKey, k)) {\n            var val = origKey[k];\n            if (typeof val !== 'undefined') {\n              key[k] = normalizeKey(val);\n            }\n          }\n        }\n      }\n  }\n  return key;\n}\nfunction indexify(key) {\n  if (key !== null) {\n    switch (typeof key) {\n      case 'boolean':\n        return key ? 1 : 0;\n      case 'number':\n        return numToIndexableString(key);\n      case 'string':\n        // We've to be sure that key does not contain \\u0000\n        // Do order-preserving replacements:\n        // 0 -> 1, 1\n        // 1 -> 1, 2\n        // 2 -> 2, 2\n        /* eslint-disable no-control-regex */\n        return key.replace(/\\u0002/g, '\\u0002\\u0002').replace(/\\u0001/g, '\\u0001\\u0002').replace(/\\u0000/g, '\\u0001\\u0001');\n      /* eslint-enable no-control-regex */\n      case 'object':\n        var isArray = Array.isArray(key);\n        var arr = isArray ? key : Object.keys(key);\n        var i = -1;\n        var len = arr.length;\n        var result = '';\n        if (isArray) {\n          while (++i < len) {\n            result += toIndexableString(arr[i]);\n          }\n        } else {\n          while (++i < len) {\n            var objKey = arr[i];\n            result += toIndexableString(objKey) + toIndexableString(key[objKey]);\n          }\n        }\n        return result;\n    }\n  }\n  return '';\n}\n\n// convert the given key to a string that would be appropriate\n// for lexical sorting, e.g. within a database, where the\n// sorting is the same given by the collate() function.\nfunction toIndexableString(key) {\n  var zero = '\\u0000';\n  key = normalizeKey(key);\n  return collationIndex(key) + SEP + indexify(key) + zero;\n}\nfunction parseNumber(str, i) {\n  var originalIdx = i;\n  var num;\n  var zero = str[i] === '1';\n  if (zero) {\n    num = 0;\n    i++;\n  } else {\n    var neg = str[i] === '0';\n    i++;\n    var numAsString = '';\n    var magAsString = str.substring(i, i + MAGNITUDE_DIGITS);\n    var magnitude = parseInt(magAsString, 10) + MIN_MAGNITUDE;\n    /* istanbul ignore next */\n    if (neg) {\n      magnitude = -magnitude;\n    }\n    i += MAGNITUDE_DIGITS;\n    while (true) {\n      var ch = str[i];\n      if (ch === '\\u0000') {\n        break;\n      } else {\n        numAsString += ch;\n      }\n      i++;\n    }\n    numAsString = numAsString.split('.');\n    if (numAsString.length === 1) {\n      num = parseInt(numAsString, 10);\n    } else {\n      /* istanbul ignore next */\n      num = parseFloat(numAsString[0] + '.' + numAsString[1]);\n    }\n    /* istanbul ignore next */\n    if (neg) {\n      num = num - 10;\n    }\n    /* istanbul ignore next */\n    if (magnitude !== 0) {\n      // parseFloat is more reliable than pow due to rounding errors\n      // e.g. Number.MAX_VALUE would return Infinity if we did\n      // num * Math.pow(10, magnitude);\n      num = parseFloat(num + 'e' + magnitude);\n    }\n  }\n  return {\n    num: num,\n    length: i - originalIdx\n  };\n}\n\n// move up the stack while parsing\n// this function moved outside of parseIndexableString for performance\nfunction pop(stack, metaStack) {\n  var obj = stack.pop();\n  if (metaStack.length) {\n    var lastMetaElement = metaStack[metaStack.length - 1];\n    if (obj === lastMetaElement.element) {\n      // popping a meta-element, e.g. an object whose value is another object\n      metaStack.pop();\n      lastMetaElement = metaStack[metaStack.length - 1];\n    }\n    var element = lastMetaElement.element;\n    var lastElementIndex = lastMetaElement.index;\n    if (Array.isArray(element)) {\n      element.push(obj);\n    } else if (lastElementIndex === stack.length - 2) {\n      // obj with key+value\n      var key = stack.pop();\n      element[key] = obj;\n    } else {\n      stack.push(obj); // obj with key only\n    }\n  }\n}\n\nfunction parseIndexableString(str) {\n  var stack = [];\n  var metaStack = []; // stack for arrays and objects\n  var i = 0;\n\n  /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n  while (true) {\n    var collationIndex = str[i++];\n    if (collationIndex === '\\u0000') {\n      if (stack.length === 1) {\n        return stack.pop();\n      } else {\n        pop(stack, metaStack);\n        continue;\n      }\n    }\n    switch (collationIndex) {\n      case '1':\n        stack.push(null);\n        break;\n      case '2':\n        stack.push(str[i] === '1');\n        i++;\n        break;\n      case '3':\n        var parsedNum = parseNumber(str, i);\n        stack.push(parsedNum.num);\n        i += parsedNum.length;\n        break;\n      case '4':\n        var parsedStr = '';\n        /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n        while (true) {\n          var ch = str[i];\n          if (ch === '\\u0000') {\n            break;\n          }\n          parsedStr += ch;\n          i++;\n        }\n        // perform the reverse of the order-preserving replacement\n        // algorithm (see above)\n        /* eslint-disable no-control-regex */\n        parsedStr = parsedStr.replace(/\\u0001\\u0001/g, '\\u0000').replace(/\\u0001\\u0002/g, '\\u0001').replace(/\\u0002\\u0002/g, '\\u0002');\n        /* eslint-enable no-control-regex */\n        stack.push(parsedStr);\n        break;\n      case '5':\n        var arrayElement = {\n          element: [],\n          index: stack.length\n        };\n        stack.push(arrayElement.element);\n        metaStack.push(arrayElement);\n        break;\n      case '6':\n        var objElement = {\n          element: {},\n          index: stack.length\n        };\n        stack.push(objElement.element);\n        metaStack.push(objElement);\n        break;\n      /* istanbul ignore next */\n      default:\n        throw new Error('bad collationIndex or unexpectedly reached end of input: ' + collationIndex);\n    }\n  }\n}\nfunction arrayCollate(a, b) {\n  var len = Math.min(a.length, b.length);\n  for (var i = 0; i < len; i++) {\n    var sort = collate(a[i], b[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n  }\n  return a.length === b.length ? 0 : a.length > b.length ? 1 : -1;\n}\nfunction stringCollate(a, b) {\n  // See: https://github.com/daleharvey/pouchdb/issues/40\n  // This is incompatible with the CouchDB implementation, but its the\n  // best we can do for now\n  return a === b ? 0 : a > b ? 1 : -1;\n}\nfunction objectCollate(a, b) {\n  var ak = Object.keys(a),\n    bk = Object.keys(b);\n  var len = Math.min(ak.length, bk.length);\n  for (var i = 0; i < len; i++) {\n    // First sort the keys\n    var sort = collate(ak[i], bk[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n    // if the keys are equal sort the values\n    sort = collate(a[ak[i]], b[bk[i]]);\n    if (sort !== 0) {\n      return sort;\n    }\n  }\n  return ak.length === bk.length ? 0 : ak.length > bk.length ? 1 : -1;\n}\n// The collation is defined by erlangs ordered terms\n// the atoms null, true, false come first, then numbers, strings,\n// arrays, then objects\n// null/undefined/NaN/Infinity/-Infinity are all considered null\nfunction collationIndex(x) {\n  var id = ['boolean', 'number', 'string', 'object'];\n  var idx = id.indexOf(typeof x);\n  //false if -1 otherwise true, but fast!!!!1\n  if (~idx) {\n    if (x === null) {\n      return 1;\n    }\n    if (Array.isArray(x)) {\n      return 5;\n    }\n    return idx < 3 ? idx + 2 : idx + 3;\n  }\n  /* istanbul ignore next */\n  if (Array.isArray(x)) {\n    return 5;\n  }\n}\n\n// conversion:\n// x yyy zz...zz\n// x = 0 for negative, 1 for 0, 2 for positive\n// y = exponent (for negative numbers negated) moved so that it's >= 0\n// z = mantisse\nfunction numToIndexableString(num) {\n  if (num === 0) {\n    return '1';\n  }\n\n  // convert number to exponential format for easier and\n  // more succinct string sorting\n  var expFormat = num.toExponential().split(/e\\+?/);\n  var magnitude = parseInt(expFormat[1], 10);\n  var neg = num < 0;\n  var result = neg ? '0' : '2';\n\n  // first sort by magnitude\n  // it's easier if all magnitudes are positive\n  var magForComparison = (neg ? -magnitude : magnitude) - MIN_MAGNITUDE;\n  var magString = padLeft(magForComparison.toString(), '0', MAGNITUDE_DIGITS);\n  result += SEP + magString;\n\n  // then sort by the factor\n  var factor = Math.abs(parseFloat(expFormat[0])); // [1..10)\n  /* istanbul ignore next */\n  if (neg) {\n    // for negative reverse ordering\n    factor = 10 - factor;\n  }\n  var factorStr = factor.toFixed(20);\n\n  // strip zeros from the end\n  factorStr = factorStr.replace(/\\.?0+$/, '');\n  result += SEP + factorStr;\n  return result;\n}\nexport { collate, normalizeKey, toIndexableString, parseIndexableString };","map":{"version":3,"names":["pad","str","padWith","upToLength","padding","targetLength","length","padLeft","MIN_MAGNITUDE","MAGNITUDE_DIGITS","SEP","collate","a","b","normalizeKey","ai","collationIndex","bi","stringCollate","Array","isArray","arrayCollate","objectCollate","key","Infinity","isNaN","origKey","len","i","Date","toJSON","k","Object","prototype","hasOwnProperty","call","val","indexify","numToIndexableString","replace","arr","keys","result","toIndexableString","objKey","zero","parseNumber","originalIdx","num","neg","numAsString","magAsString","substring","magnitude","parseInt","ch","split","parseFloat","pop","stack","metaStack","obj","lastMetaElement","element","lastElementIndex","index","push","parseIndexableString","parsedNum","parsedStr","arrayElement","objElement","Error","Math","min","sort","ak","bk","x","id","idx","indexOf","expFormat","toExponential","magForComparison","magString","toString","factor","abs","factorStr","toFixed"],"sources":["/home/sol/Documentos/AUS/3ro segundo cuatri/ing 2/URV/node_modules/pouchdb-collate/lib/index.es.js"],"sourcesContent":["function pad(str, padWith, upToLength) {\n  var padding = '';\n  var targetLength = upToLength - str.length;\n  /* istanbul ignore next */\n  while (padding.length < targetLength) {\n    padding += padWith;\n  }\n  return padding;\n}\n\nfunction padLeft(str, padWith, upToLength) {\n  var padding = pad(str, padWith, upToLength);\n  return padding + str;\n}\n\nvar MIN_MAGNITUDE = -324; // verified by -Number.MIN_VALUE\nvar MAGNITUDE_DIGITS = 3; // ditto\nvar SEP = ''; // set to '_' for easier debugging\n\nfunction collate(a, b) {\n\n  if (a === b) {\n    return 0;\n  }\n\n  a = normalizeKey(a);\n  b = normalizeKey(b);\n\n  var ai = collationIndex(a);\n  var bi = collationIndex(b);\n  if ((ai - bi) !== 0) {\n    return ai - bi;\n  }\n  switch (typeof a) {\n    case 'number':\n      return a - b;\n    case 'boolean':\n      return a < b ? -1 : 1;\n    case 'string':\n      return stringCollate(a, b);\n  }\n  return Array.isArray(a) ? arrayCollate(a, b) : objectCollate(a, b);\n}\n\n// couch considers null/NaN/Infinity/-Infinity === undefined,\n// for the purposes of mapreduce indexes. also, dates get stringified.\nfunction normalizeKey(key) {\n  switch (typeof key) {\n    case 'undefined':\n      return null;\n    case 'number':\n      if (key === Infinity || key === -Infinity || isNaN(key)) {\n        return null;\n      }\n      return key;\n    case 'object':\n      var origKey = key;\n      if (Array.isArray(key)) {\n        var len = key.length;\n        key = new Array(len);\n        for (var i = 0; i < len; i++) {\n          key[i] = normalizeKey(origKey[i]);\n        }\n      /* istanbul ignore next */\n      } else if (key instanceof Date) {\n        return key.toJSON();\n      } else if (key !== null) { // generic object\n        key = {};\n        for (var k in origKey) {\n          if (Object.prototype.hasOwnProperty.call(origKey, k)) {\n            var val = origKey[k];\n            if (typeof val !== 'undefined') {\n              key[k] = normalizeKey(val);\n            }\n          }\n        }\n      }\n  }\n  return key;\n}\n\nfunction indexify(key) {\n  if (key !== null) {\n    switch (typeof key) {\n      case 'boolean':\n        return key ? 1 : 0;\n      case 'number':\n        return numToIndexableString(key);\n      case 'string':\n        // We've to be sure that key does not contain \\u0000\n        // Do order-preserving replacements:\n        // 0 -> 1, 1\n        // 1 -> 1, 2\n        // 2 -> 2, 2\n        /* eslint-disable no-control-regex */\n        return key\n          .replace(/\\u0002/g, '\\u0002\\u0002')\n          .replace(/\\u0001/g, '\\u0001\\u0002')\n          .replace(/\\u0000/g, '\\u0001\\u0001');\n        /* eslint-enable no-control-regex */\n      case 'object':\n        var isArray = Array.isArray(key);\n        var arr = isArray ? key : Object.keys(key);\n        var i = -1;\n        var len = arr.length;\n        var result = '';\n        if (isArray) {\n          while (++i < len) {\n            result += toIndexableString(arr[i]);\n          }\n        } else {\n          while (++i < len) {\n            var objKey = arr[i];\n            result += toIndexableString(objKey) +\n                toIndexableString(key[objKey]);\n          }\n        }\n        return result;\n    }\n  }\n  return '';\n}\n\n// convert the given key to a string that would be appropriate\n// for lexical sorting, e.g. within a database, where the\n// sorting is the same given by the collate() function.\nfunction toIndexableString(key) {\n  var zero = '\\u0000';\n  key = normalizeKey(key);\n  return collationIndex(key) + SEP + indexify(key) + zero;\n}\n\nfunction parseNumber(str, i) {\n  var originalIdx = i;\n  var num;\n  var zero = str[i] === '1';\n  if (zero) {\n    num = 0;\n    i++;\n  } else {\n    var neg = str[i] === '0';\n    i++;\n    var numAsString = '';\n    var magAsString = str.substring(i, i + MAGNITUDE_DIGITS);\n    var magnitude = parseInt(magAsString, 10) + MIN_MAGNITUDE;\n    /* istanbul ignore next */\n    if (neg) {\n      magnitude = -magnitude;\n    }\n    i += MAGNITUDE_DIGITS;\n    while (true) {\n      var ch = str[i];\n      if (ch === '\\u0000') {\n        break;\n      } else {\n        numAsString += ch;\n      }\n      i++;\n    }\n    numAsString = numAsString.split('.');\n    if (numAsString.length === 1) {\n      num = parseInt(numAsString, 10);\n    } else {\n      /* istanbul ignore next */\n      num = parseFloat(numAsString[0] + '.' + numAsString[1]);\n    }\n    /* istanbul ignore next */\n    if (neg) {\n      num = num - 10;\n    }\n    /* istanbul ignore next */\n    if (magnitude !== 0) {\n      // parseFloat is more reliable than pow due to rounding errors\n      // e.g. Number.MAX_VALUE would return Infinity if we did\n      // num * Math.pow(10, magnitude);\n      num = parseFloat(num + 'e' + magnitude);\n    }\n  }\n  return {num: num, length : i - originalIdx};\n}\n\n// move up the stack while parsing\n// this function moved outside of parseIndexableString for performance\nfunction pop(stack, metaStack) {\n  var obj = stack.pop();\n\n  if (metaStack.length) {\n    var lastMetaElement = metaStack[metaStack.length - 1];\n    if (obj === lastMetaElement.element) {\n      // popping a meta-element, e.g. an object whose value is another object\n      metaStack.pop();\n      lastMetaElement = metaStack[metaStack.length - 1];\n    }\n    var element = lastMetaElement.element;\n    var lastElementIndex = lastMetaElement.index;\n    if (Array.isArray(element)) {\n      element.push(obj);\n    } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n      var key = stack.pop();\n      element[key] = obj;\n    } else {\n      stack.push(obj); // obj with key only\n    }\n  }\n}\n\nfunction parseIndexableString(str) {\n  var stack = [];\n  var metaStack = []; // stack for arrays and objects\n  var i = 0;\n\n  /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n  while (true) {\n    var collationIndex = str[i++];\n    if (collationIndex === '\\u0000') {\n      if (stack.length === 1) {\n        return stack.pop();\n      } else {\n        pop(stack, metaStack);\n        continue;\n      }\n    }\n    switch (collationIndex) {\n      case '1':\n        stack.push(null);\n        break;\n      case '2':\n        stack.push(str[i] === '1');\n        i++;\n        break;\n      case '3':\n        var parsedNum = parseNumber(str, i);\n        stack.push(parsedNum.num);\n        i += parsedNum.length;\n        break;\n      case '4':\n        var parsedStr = '';\n        /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n        while (true) {\n          var ch = str[i];\n          if (ch === '\\u0000') {\n            break;\n          }\n          parsedStr += ch;\n          i++;\n        }\n        // perform the reverse of the order-preserving replacement\n        // algorithm (see above)\n        /* eslint-disable no-control-regex */\n        parsedStr = parsedStr.replace(/\\u0001\\u0001/g, '\\u0000')\n          .replace(/\\u0001\\u0002/g, '\\u0001')\n          .replace(/\\u0002\\u0002/g, '\\u0002');\n        /* eslint-enable no-control-regex */\n        stack.push(parsedStr);\n        break;\n      case '5':\n        var arrayElement = { element: [], index: stack.length };\n        stack.push(arrayElement.element);\n        metaStack.push(arrayElement);\n        break;\n      case '6':\n        var objElement = { element: {}, index: stack.length };\n        stack.push(objElement.element);\n        metaStack.push(objElement);\n        break;\n      /* istanbul ignore next */\n      default:\n        throw new Error(\n          'bad collationIndex or unexpectedly reached end of input: ' +\n            collationIndex);\n    }\n  }\n}\n\nfunction arrayCollate(a, b) {\n  var len = Math.min(a.length, b.length);\n  for (var i = 0; i < len; i++) {\n    var sort = collate(a[i], b[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n  }\n  return (a.length === b.length) ? 0 :\n    (a.length > b.length) ? 1 : -1;\n}\nfunction stringCollate(a, b) {\n  // See: https://github.com/daleharvey/pouchdb/issues/40\n  // This is incompatible with the CouchDB implementation, but its the\n  // best we can do for now\n  return (a === b) ? 0 : ((a > b) ? 1 : -1);\n}\nfunction objectCollate(a, b) {\n  var ak = Object.keys(a), bk = Object.keys(b);\n  var len = Math.min(ak.length, bk.length);\n  for (var i = 0; i < len; i++) {\n    // First sort the keys\n    var sort = collate(ak[i], bk[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n    // if the keys are equal sort the values\n    sort = collate(a[ak[i]], b[bk[i]]);\n    if (sort !== 0) {\n      return sort;\n    }\n\n  }\n  return (ak.length === bk.length) ? 0 :\n    (ak.length > bk.length) ? 1 : -1;\n}\n// The collation is defined by erlangs ordered terms\n// the atoms null, true, false come first, then numbers, strings,\n// arrays, then objects\n// null/undefined/NaN/Infinity/-Infinity are all considered null\nfunction collationIndex(x) {\n  var id = ['boolean', 'number', 'string', 'object'];\n  var idx = id.indexOf(typeof x);\n  //false if -1 otherwise true, but fast!!!!1\n  if (~idx) {\n    if (x === null) {\n      return 1;\n    }\n    if (Array.isArray(x)) {\n      return 5;\n    }\n    return idx < 3 ? (idx + 2) : (idx + 3);\n  }\n  /* istanbul ignore next */\n  if (Array.isArray(x)) {\n    return 5;\n  }\n}\n\n// conversion:\n// x yyy zz...zz\n// x = 0 for negative, 1 for 0, 2 for positive\n// y = exponent (for negative numbers negated) moved so that it's >= 0\n// z = mantisse\nfunction numToIndexableString(num) {\n\n  if (num === 0) {\n    return '1';\n  }\n\n  // convert number to exponential format for easier and\n  // more succinct string sorting\n  var expFormat = num.toExponential().split(/e\\+?/);\n  var magnitude = parseInt(expFormat[1], 10);\n\n  var neg = num < 0;\n\n  var result = neg ? '0' : '2';\n\n  // first sort by magnitude\n  // it's easier if all magnitudes are positive\n  var magForComparison = ((neg ? -magnitude : magnitude) - MIN_MAGNITUDE);\n  var magString = padLeft((magForComparison).toString(), '0', MAGNITUDE_DIGITS);\n\n  result += SEP + magString;\n\n  // then sort by the factor\n  var factor = Math.abs(parseFloat(expFormat[0])); // [1..10)\n  /* istanbul ignore next */\n  if (neg) { // for negative reverse ordering\n    factor = 10 - factor;\n  }\n\n  var factorStr = factor.toFixed(20);\n\n  // strip zeros from the end\n  factorStr = factorStr.replace(/\\.?0+$/, '');\n\n  result += SEP + factorStr;\n\n  return result;\n}\n\nexport { collate, normalizeKey, toIndexableString, parseIndexableString };\n"],"mappings":"AAAA,SAASA,GAAG,CAACC,GAAG,EAAEC,OAAO,EAAEC,UAAU,EAAE;EACrC,IAAIC,OAAO,GAAG,EAAE;EAChB,IAAIC,YAAY,GAAGF,UAAU,GAAGF,GAAG,CAACK,MAAM;EAC1C;EACA,OAAOF,OAAO,CAACE,MAAM,GAAGD,YAAY,EAAE;IACpCD,OAAO,IAAIF,OAAO;EACpB;EACA,OAAOE,OAAO;AAChB;AAEA,SAASG,OAAO,CAACN,GAAG,EAAEC,OAAO,EAAEC,UAAU,EAAE;EACzC,IAAIC,OAAO,GAAGJ,GAAG,CAACC,GAAG,EAAEC,OAAO,EAAEC,UAAU,CAAC;EAC3C,OAAOC,OAAO,GAAGH,GAAG;AACtB;AAEA,IAAIO,aAAa,GAAG,CAAC,GAAG,CAAC,CAAC;AAC1B,IAAIC,gBAAgB,GAAG,CAAC,CAAC,CAAC;AAC1B,IAAIC,GAAG,GAAG,EAAE,CAAC,CAAC;;AAEd,SAASC,OAAO,CAACC,CAAC,EAAEC,CAAC,EAAE;EAErB,IAAID,CAAC,KAAKC,CAAC,EAAE;IACX,OAAO,CAAC;EACV;EAEAD,CAAC,GAAGE,YAAY,CAACF,CAAC,CAAC;EACnBC,CAAC,GAAGC,YAAY,CAACD,CAAC,CAAC;EAEnB,IAAIE,EAAE,GAAGC,cAAc,CAACJ,CAAC,CAAC;EAC1B,IAAIK,EAAE,GAAGD,cAAc,CAACH,CAAC,CAAC;EAC1B,IAAKE,EAAE,GAAGE,EAAE,KAAM,CAAC,EAAE;IACnB,OAAOF,EAAE,GAAGE,EAAE;EAChB;EACA,QAAQ,OAAOL,CAAC;IACd,KAAK,QAAQ;MACX,OAAOA,CAAC,GAAGC,CAAC;IACd,KAAK,SAAS;MACZ,OAAOD,CAAC,GAAGC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;IACvB,KAAK,QAAQ;MACX,OAAOK,aAAa,CAACN,CAAC,EAAEC,CAAC,CAAC;EAAC;EAE/B,OAAOM,KAAK,CAACC,OAAO,CAACR,CAAC,CAAC,GAAGS,YAAY,CAACT,CAAC,EAAEC,CAAC,CAAC,GAAGS,aAAa,CAACV,CAAC,EAAEC,CAAC,CAAC;AACpE;;AAEA;AACA;AACA,SAASC,YAAY,CAACS,GAAG,EAAE;EACzB,QAAQ,OAAOA,GAAG;IAChB,KAAK,WAAW;MACd,OAAO,IAAI;IACb,KAAK,QAAQ;MACX,IAAIA,GAAG,KAAKC,QAAQ,IAAID,GAAG,KAAK,CAACC,QAAQ,IAAIC,KAAK,CAACF,GAAG,CAAC,EAAE;QACvD,OAAO,IAAI;MACb;MACA,OAAOA,GAAG;IACZ,KAAK,QAAQ;MACX,IAAIG,OAAO,GAAGH,GAAG;MACjB,IAAIJ,KAAK,CAACC,OAAO,CAACG,GAAG,CAAC,EAAE;QACtB,IAAII,GAAG,GAAGJ,GAAG,CAACjB,MAAM;QACpBiB,GAAG,GAAG,IAAIJ,KAAK,CAACQ,GAAG,CAAC;QACpB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,GAAG,EAAEC,CAAC,EAAE,EAAE;UAC5BL,GAAG,CAACK,CAAC,CAAC,GAAGd,YAAY,CAACY,OAAO,CAACE,CAAC,CAAC,CAAC;QACnC;QACF;MACA,CAAC,MAAM,IAAIL,GAAG,YAAYM,IAAI,EAAE;QAC9B,OAAON,GAAG,CAACO,MAAM,EAAE;MACrB,CAAC,MAAM,IAAIP,GAAG,KAAK,IAAI,EAAE;QAAE;QACzBA,GAAG,GAAG,CAAC,CAAC;QACR,KAAK,IAAIQ,CAAC,IAAIL,OAAO,EAAE;UACrB,IAAIM,MAAM,CAACC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACT,OAAO,EAAEK,CAAC,CAAC,EAAE;YACpD,IAAIK,GAAG,GAAGV,OAAO,CAACK,CAAC,CAAC;YACpB,IAAI,OAAOK,GAAG,KAAK,WAAW,EAAE;cAC9Bb,GAAG,CAACQ,CAAC,CAAC,GAAGjB,YAAY,CAACsB,GAAG,CAAC;YAC5B;UACF;QACF;MACF;EAAC;EAEL,OAAOb,GAAG;AACZ;AAEA,SAASc,QAAQ,CAACd,GAAG,EAAE;EACrB,IAAIA,GAAG,KAAK,IAAI,EAAE;IAChB,QAAQ,OAAOA,GAAG;MAChB,KAAK,SAAS;QACZ,OAAOA,GAAG,GAAG,CAAC,GAAG,CAAC;MACpB,KAAK,QAAQ;QACX,OAAOe,oBAAoB,CAACf,GAAG,CAAC;MAClC,KAAK,QAAQ;QACX;QACA;QACA;QACA;QACA;QACA;QACA,OAAOA,GAAG,CACPgB,OAAO,CAAC,SAAS,EAAE,cAAc,CAAC,CAClCA,OAAO,CAAC,SAAS,EAAE,cAAc,CAAC,CAClCA,OAAO,CAAC,SAAS,EAAE,cAAc,CAAC;MACrC;MACF,KAAK,QAAQ;QACX,IAAInB,OAAO,GAAGD,KAAK,CAACC,OAAO,CAACG,GAAG,CAAC;QAChC,IAAIiB,GAAG,GAAGpB,OAAO,GAAGG,GAAG,GAAGS,MAAM,CAACS,IAAI,CAAClB,GAAG,CAAC;QAC1C,IAAIK,CAAC,GAAG,CAAC,CAAC;QACV,IAAID,GAAG,GAAGa,GAAG,CAAClC,MAAM;QACpB,IAAIoC,MAAM,GAAG,EAAE;QACf,IAAItB,OAAO,EAAE;UACX,OAAO,EAAEQ,CAAC,GAAGD,GAAG,EAAE;YAChBe,MAAM,IAAIC,iBAAiB,CAACH,GAAG,CAACZ,CAAC,CAAC,CAAC;UACrC;QACF,CAAC,MAAM;UACL,OAAO,EAAEA,CAAC,GAAGD,GAAG,EAAE;YAChB,IAAIiB,MAAM,GAAGJ,GAAG,CAACZ,CAAC,CAAC;YACnBc,MAAM,IAAIC,iBAAiB,CAACC,MAAM,CAAC,GAC/BD,iBAAiB,CAACpB,GAAG,CAACqB,MAAM,CAAC,CAAC;UACpC;QACF;QACA,OAAOF,MAAM;IAAC;EAEpB;EACA,OAAO,EAAE;AACX;;AAEA;AACA;AACA;AACA,SAASC,iBAAiB,CAACpB,GAAG,EAAE;EAC9B,IAAIsB,IAAI,GAAG,QAAQ;EACnBtB,GAAG,GAAGT,YAAY,CAACS,GAAG,CAAC;EACvB,OAAOP,cAAc,CAACO,GAAG,CAAC,GAAGb,GAAG,GAAG2B,QAAQ,CAACd,GAAG,CAAC,GAAGsB,IAAI;AACzD;AAEA,SAASC,WAAW,CAAC7C,GAAG,EAAE2B,CAAC,EAAE;EAC3B,IAAImB,WAAW,GAAGnB,CAAC;EACnB,IAAIoB,GAAG;EACP,IAAIH,IAAI,GAAG5C,GAAG,CAAC2B,CAAC,CAAC,KAAK,GAAG;EACzB,IAAIiB,IAAI,EAAE;IACRG,GAAG,GAAG,CAAC;IACPpB,CAAC,EAAE;EACL,CAAC,MAAM;IACL,IAAIqB,GAAG,GAAGhD,GAAG,CAAC2B,CAAC,CAAC,KAAK,GAAG;IACxBA,CAAC,EAAE;IACH,IAAIsB,WAAW,GAAG,EAAE;IACpB,IAAIC,WAAW,GAAGlD,GAAG,CAACmD,SAAS,CAACxB,CAAC,EAAEA,CAAC,GAAGnB,gBAAgB,CAAC;IACxD,IAAI4C,SAAS,GAAGC,QAAQ,CAACH,WAAW,EAAE,EAAE,CAAC,GAAG3C,aAAa;IACzD;IACA,IAAIyC,GAAG,EAAE;MACPI,SAAS,GAAG,CAACA,SAAS;IACxB;IACAzB,CAAC,IAAInB,gBAAgB;IACrB,OAAO,IAAI,EAAE;MACX,IAAI8C,EAAE,GAAGtD,GAAG,CAAC2B,CAAC,CAAC;MACf,IAAI2B,EAAE,KAAK,QAAQ,EAAE;QACnB;MACF,CAAC,MAAM;QACLL,WAAW,IAAIK,EAAE;MACnB;MACA3B,CAAC,EAAE;IACL;IACAsB,WAAW,GAAGA,WAAW,CAACM,KAAK,CAAC,GAAG,CAAC;IACpC,IAAIN,WAAW,CAAC5C,MAAM,KAAK,CAAC,EAAE;MAC5B0C,GAAG,GAAGM,QAAQ,CAACJ,WAAW,EAAE,EAAE,CAAC;IACjC,CAAC,MAAM;MACL;MACAF,GAAG,GAAGS,UAAU,CAACP,WAAW,CAAC,CAAC,CAAC,GAAG,GAAG,GAAGA,WAAW,CAAC,CAAC,CAAC,CAAC;IACzD;IACA;IACA,IAAID,GAAG,EAAE;MACPD,GAAG,GAAGA,GAAG,GAAG,EAAE;IAChB;IACA;IACA,IAAIK,SAAS,KAAK,CAAC,EAAE;MACnB;MACA;MACA;MACAL,GAAG,GAAGS,UAAU,CAACT,GAAG,GAAG,GAAG,GAAGK,SAAS,CAAC;IACzC;EACF;EACA,OAAO;IAACL,GAAG,EAAEA,GAAG;IAAE1C,MAAM,EAAGsB,CAAC,GAAGmB;EAAW,CAAC;AAC7C;;AAEA;AACA;AACA,SAASW,GAAG,CAACC,KAAK,EAAEC,SAAS,EAAE;EAC7B,IAAIC,GAAG,GAAGF,KAAK,CAACD,GAAG,EAAE;EAErB,IAAIE,SAAS,CAACtD,MAAM,EAAE;IACpB,IAAIwD,eAAe,GAAGF,SAAS,CAACA,SAAS,CAACtD,MAAM,GAAG,CAAC,CAAC;IACrD,IAAIuD,GAAG,KAAKC,eAAe,CAACC,OAAO,EAAE;MACnC;MACAH,SAAS,CAACF,GAAG,EAAE;MACfI,eAAe,GAAGF,SAAS,CAACA,SAAS,CAACtD,MAAM,GAAG,CAAC,CAAC;IACnD;IACA,IAAIyD,OAAO,GAAGD,eAAe,CAACC,OAAO;IACrC,IAAIC,gBAAgB,GAAGF,eAAe,CAACG,KAAK;IAC5C,IAAI9C,KAAK,CAACC,OAAO,CAAC2C,OAAO,CAAC,EAAE;MAC1BA,OAAO,CAACG,IAAI,CAACL,GAAG,CAAC;IACnB,CAAC,MAAM,IAAIG,gBAAgB,KAAKL,KAAK,CAACrD,MAAM,GAAG,CAAC,EAAE;MAAE;MAClD,IAAIiB,GAAG,GAAGoC,KAAK,CAACD,GAAG,EAAE;MACrBK,OAAO,CAACxC,GAAG,CAAC,GAAGsC,GAAG;IACpB,CAAC,MAAM;MACLF,KAAK,CAACO,IAAI,CAACL,GAAG,CAAC,CAAC,CAAC;IACnB;EACF;AACF;;AAEA,SAASM,oBAAoB,CAAClE,GAAG,EAAE;EACjC,IAAI0D,KAAK,GAAG,EAAE;EACd,IAAIC,SAAS,GAAG,EAAE,CAAC,CAAC;EACpB,IAAIhC,CAAC,GAAG,CAAC;;EAET;EACA,OAAO,IAAI,EAAE;IACX,IAAIZ,cAAc,GAAGf,GAAG,CAAC2B,CAAC,EAAE,CAAC;IAC7B,IAAIZ,cAAc,KAAK,QAAQ,EAAE;MAC/B,IAAI2C,KAAK,CAACrD,MAAM,KAAK,CAAC,EAAE;QACtB,OAAOqD,KAAK,CAACD,GAAG,EAAE;MACpB,CAAC,MAAM;QACLA,GAAG,CAACC,KAAK,EAAEC,SAAS,CAAC;QACrB;MACF;IACF;IACA,QAAQ5C,cAAc;MACpB,KAAK,GAAG;QACN2C,KAAK,CAACO,IAAI,CAAC,IAAI,CAAC;QAChB;MACF,KAAK,GAAG;QACNP,KAAK,CAACO,IAAI,CAACjE,GAAG,CAAC2B,CAAC,CAAC,KAAK,GAAG,CAAC;QAC1BA,CAAC,EAAE;QACH;MACF,KAAK,GAAG;QACN,IAAIwC,SAAS,GAAGtB,WAAW,CAAC7C,GAAG,EAAE2B,CAAC,CAAC;QACnC+B,KAAK,CAACO,IAAI,CAACE,SAAS,CAACpB,GAAG,CAAC;QACzBpB,CAAC,IAAIwC,SAAS,CAAC9D,MAAM;QACrB;MACF,KAAK,GAAG;QACN,IAAI+D,SAAS,GAAG,EAAE;QAClB;QACA,OAAO,IAAI,EAAE;UACX,IAAId,EAAE,GAAGtD,GAAG,CAAC2B,CAAC,CAAC;UACf,IAAI2B,EAAE,KAAK,QAAQ,EAAE;YACnB;UACF;UACAc,SAAS,IAAId,EAAE;UACf3B,CAAC,EAAE;QACL;QACA;QACA;QACA;QACAyC,SAAS,GAAGA,SAAS,CAAC9B,OAAO,CAAC,eAAe,EAAE,QAAQ,CAAC,CACrDA,OAAO,CAAC,eAAe,EAAE,QAAQ,CAAC,CAClCA,OAAO,CAAC,eAAe,EAAE,QAAQ,CAAC;QACrC;QACAoB,KAAK,CAACO,IAAI,CAACG,SAAS,CAAC;QACrB;MACF,KAAK,GAAG;QACN,IAAIC,YAAY,GAAG;UAAEP,OAAO,EAAE,EAAE;UAAEE,KAAK,EAAEN,KAAK,CAACrD;QAAO,CAAC;QACvDqD,KAAK,CAACO,IAAI,CAACI,YAAY,CAACP,OAAO,CAAC;QAChCH,SAAS,CAACM,IAAI,CAACI,YAAY,CAAC;QAC5B;MACF,KAAK,GAAG;QACN,IAAIC,UAAU,GAAG;UAAER,OAAO,EAAE,CAAC,CAAC;UAAEE,KAAK,EAAEN,KAAK,CAACrD;QAAO,CAAC;QACrDqD,KAAK,CAACO,IAAI,CAACK,UAAU,CAACR,OAAO,CAAC;QAC9BH,SAAS,CAACM,IAAI,CAACK,UAAU,CAAC;QAC1B;MACF;MACA;QACE,MAAM,IAAIC,KAAK,CACb,2DAA2D,GACzDxD,cAAc,CAAC;IAAC;EAE1B;AACF;AAEA,SAASK,YAAY,CAACT,CAAC,EAAEC,CAAC,EAAE;EAC1B,IAAIc,GAAG,GAAG8C,IAAI,CAACC,GAAG,CAAC9D,CAAC,CAACN,MAAM,EAAEO,CAAC,CAACP,MAAM,CAAC;EACtC,KAAK,IAAIsB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,GAAG,EAAEC,CAAC,EAAE,EAAE;IAC5B,IAAI+C,IAAI,GAAGhE,OAAO,CAACC,CAAC,CAACgB,CAAC,CAAC,EAAEf,CAAC,CAACe,CAAC,CAAC,CAAC;IAC9B,IAAI+C,IAAI,KAAK,CAAC,EAAE;MACd,OAAOA,IAAI;IACb;EACF;EACA,OAAQ/D,CAAC,CAACN,MAAM,KAAKO,CAAC,CAACP,MAAM,GAAI,CAAC,GAC/BM,CAAC,CAACN,MAAM,GAAGO,CAAC,CAACP,MAAM,GAAI,CAAC,GAAG,CAAC,CAAC;AAClC;AACA,SAASY,aAAa,CAACN,CAAC,EAAEC,CAAC,EAAE;EAC3B;EACA;EACA;EACA,OAAQD,CAAC,KAAKC,CAAC,GAAI,CAAC,GAAKD,CAAC,GAAGC,CAAC,GAAI,CAAC,GAAG,CAAC,CAAE;AAC3C;AACA,SAASS,aAAa,CAACV,CAAC,EAAEC,CAAC,EAAE;EAC3B,IAAI+D,EAAE,GAAG5C,MAAM,CAACS,IAAI,CAAC7B,CAAC,CAAC;IAAEiE,EAAE,GAAG7C,MAAM,CAACS,IAAI,CAAC5B,CAAC,CAAC;EAC5C,IAAIc,GAAG,GAAG8C,IAAI,CAACC,GAAG,CAACE,EAAE,CAACtE,MAAM,EAAEuE,EAAE,CAACvE,MAAM,CAAC;EACxC,KAAK,IAAIsB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,GAAG,EAAEC,CAAC,EAAE,EAAE;IAC5B;IACA,IAAI+C,IAAI,GAAGhE,OAAO,CAACiE,EAAE,CAAChD,CAAC,CAAC,EAAEiD,EAAE,CAACjD,CAAC,CAAC,CAAC;IAChC,IAAI+C,IAAI,KAAK,CAAC,EAAE;MACd,OAAOA,IAAI;IACb;IACA;IACAA,IAAI,GAAGhE,OAAO,CAACC,CAAC,CAACgE,EAAE,CAAChD,CAAC,CAAC,CAAC,EAAEf,CAAC,CAACgE,EAAE,CAACjD,CAAC,CAAC,CAAC,CAAC;IAClC,IAAI+C,IAAI,KAAK,CAAC,EAAE;MACd,OAAOA,IAAI;IACb;EAEF;EACA,OAAQC,EAAE,CAACtE,MAAM,KAAKuE,EAAE,CAACvE,MAAM,GAAI,CAAC,GACjCsE,EAAE,CAACtE,MAAM,GAAGuE,EAAE,CAACvE,MAAM,GAAI,CAAC,GAAG,CAAC,CAAC;AACpC;AACA;AACA;AACA;AACA;AACA,SAASU,cAAc,CAAC8D,CAAC,EAAE;EACzB,IAAIC,EAAE,GAAG,CAAC,SAAS,EAAE,QAAQ,EAAE,QAAQ,EAAE,QAAQ,CAAC;EAClD,IAAIC,GAAG,GAAGD,EAAE,CAACE,OAAO,CAAC,OAAOH,CAAC,CAAC;EAC9B;EACA,IAAI,CAACE,GAAG,EAAE;IACR,IAAIF,CAAC,KAAK,IAAI,EAAE;MACd,OAAO,CAAC;IACV;IACA,IAAI3D,KAAK,CAACC,OAAO,CAAC0D,CAAC,CAAC,EAAE;MACpB,OAAO,CAAC;IACV;IACA,OAAOE,GAAG,GAAG,CAAC,GAAIA,GAAG,GAAG,CAAC,GAAKA,GAAG,GAAG,CAAE;EACxC;EACA;EACA,IAAI7D,KAAK,CAACC,OAAO,CAAC0D,CAAC,CAAC,EAAE;IACpB,OAAO,CAAC;EACV;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASxC,oBAAoB,CAACU,GAAG,EAAE;EAEjC,IAAIA,GAAG,KAAK,CAAC,EAAE;IACb,OAAO,GAAG;EACZ;;EAEA;EACA;EACA,IAAIkC,SAAS,GAAGlC,GAAG,CAACmC,aAAa,EAAE,CAAC3B,KAAK,CAAC,MAAM,CAAC;EACjD,IAAIH,SAAS,GAAGC,QAAQ,CAAC4B,SAAS,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;EAE1C,IAAIjC,GAAG,GAAGD,GAAG,GAAG,CAAC;EAEjB,IAAIN,MAAM,GAAGO,GAAG,GAAG,GAAG,GAAG,GAAG;;EAE5B;EACA;EACA,IAAImC,gBAAgB,GAAI,CAACnC,GAAG,GAAG,CAACI,SAAS,GAAGA,SAAS,IAAI7C,aAAc;EACvE,IAAI6E,SAAS,GAAG9E,OAAO,CAAE6E,gBAAgB,CAAEE,QAAQ,EAAE,EAAE,GAAG,EAAE7E,gBAAgB,CAAC;EAE7EiC,MAAM,IAAIhC,GAAG,GAAG2E,SAAS;;EAEzB;EACA,IAAIE,MAAM,GAAGd,IAAI,CAACe,GAAG,CAAC/B,UAAU,CAACyB,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;EACjD;EACA,IAAIjC,GAAG,EAAE;IAAE;IACTsC,MAAM,GAAG,EAAE,GAAGA,MAAM;EACtB;EAEA,IAAIE,SAAS,GAAGF,MAAM,CAACG,OAAO,CAAC,EAAE,CAAC;;EAElC;EACAD,SAAS,GAAGA,SAAS,CAAClD,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC;EAE3CG,MAAM,IAAIhC,GAAG,GAAG+E,SAAS;EAEzB,OAAO/C,MAAM;AACf;AAEA,SAAS/B,OAAO,EAAEG,YAAY,EAAE6B,iBAAiB,EAAEwB,oBAAoB"},"metadata":{},"sourceType":"module","externalDependencies":[]}