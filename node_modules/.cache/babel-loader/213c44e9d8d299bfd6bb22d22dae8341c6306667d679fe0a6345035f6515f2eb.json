{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  _setPrototypeOf(subClass, superClass);\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n  return _construct.apply(null, arguments);\n}\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n      _cache.set(Class, Wrapper);\n    }\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n  return _wrapNativeSuper(Class);\n}\n\n/**\n * Ported from https://github.com/sunnylqm/react-native-storage\n * Credit: Sunny Luo /sunnylqm\n */\n\n/**\n * Created by sunny on 9/1/16.\n */\nvar NotFoundError = /*#__PURE__*/function (_Error) {\n  _inheritsLoose(NotFoundError, _Error);\n  function NotFoundError(message) {\n    var _this;\n    _this = _Error.call(this, \"Not Found! Params: \" + message) || this;\n    _this.name = 'NotFoundError';\n    _this.stack = new Error().stack; // Optional\n\n    return _this;\n  }\n  return NotFoundError;\n}( /*#__PURE__*/_wrapNativeSuper(Error)); // NotFoundError.prototype = Object.create(Error.prototype);\n\nvar ExpiredError = /*#__PURE__*/function (_Error2) {\n  _inheritsLoose(ExpiredError, _Error2);\n  function ExpiredError(message) {\n    var _this2;\n    _this2 = _Error2.call(this, \"Expired! Params: \" + message) || this;\n    _this2.name = 'ExpiredError';\n    _this2.stack = new Error().stack; // Optional\n\n    return _this2;\n  }\n  return ExpiredError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nvar Storage = /*#__PURE__*/function () {\n  function Storage(options) {\n    var _this = this;\n    if (options === void 0) {\n      options = {};\n    }\n    this._SIZE = options.size || 1000; // maximum key-ids capacity\n\n    this.sync = options.sync || {}; // remote sync method\n\n    this.defaultExpires = options.defaultExpires !== undefined ? options.defaultExpires : 1000 * 3600 * 24;\n    this.enableCache = options.enableCache !== false;\n    this._s = options.storageBackend || null;\n    this._innerVersion = 11;\n    this.cache = {};\n    if (this._s && this._s.setItem) {\n      try {\n        var promiseTest = this._s.setItem('__react_native_storage_test', 'test');\n        this.isPromise = !!(promiseTest && promiseTest.then);\n      } catch (e) {\n        console.warn(e);\n        delete this._s;\n        throw e;\n      }\n    } else {\n      console.warn(\"Data would be lost after reload cause there is no storageBackend specified!\\n      \\nEither use localStorage(for web) or AsyncStorage(for React Native) as a storageBackend.\");\n    }\n    this._mapPromise = this.getItem('map').then(function (map) {\n      _this._m = _this._checkMap(map && JSON.parse(map) || {});\n    });\n  }\n  var _proto = Storage.prototype;\n  _proto.getItem = function getItem(key) {\n    return this._s ? this.isPromise ? this._s.getItem(key) : Promise.resolve(this._s.getItem(key)) : Promise.resolve();\n  };\n  _proto.setItem = function setItem(key, value) {\n    return this._s ? this.isPromise ? this._s.setItem(key, value) : Promise.resolve(this._s.setItem(key, value)) : Promise.resolve();\n  };\n  _proto.removeItem = function removeItem(key) {\n    return this._s ? this.isPromise ? this._s.removeItem(key) : Promise.resolve(this._s.removeItem(key)) : Promise.resolve();\n  };\n  _proto._initMap = function _initMap() {\n    return {\n      innerVersion: this._innerVersion,\n      index: 0,\n      __keys__: {}\n    };\n  };\n  _proto._checkMap = function _checkMap(map) {\n    if (map && map.innerVersion && map.innerVersion === this._innerVersion) {\n      return map;\n    } else {\n      return this._initMap();\n    }\n  };\n  _proto._getId = function _getId(key, id) {\n    return key + '_' + id;\n  };\n  _proto._saveToMap = function _saveToMap(params) {\n    var key = params.key,\n      id = params.id,\n      data = params.data,\n      newId = this._getId(key, id),\n      m = this._m;\n    if (m[newId] !== undefined) {\n      // update existing data\n      if (this.enableCache) this.cache[newId] = JSON.parse(data);\n      return this.setItem('map_' + m[newId], data);\n    }\n    if (m[m.index] !== undefined) {\n      // loop over, delete old data\n      var oldId = m[m.index];\n      var splitOldId = oldId.split('_');\n      delete m[oldId];\n      this._removeIdInKey(splitOldId[0], splitOldId[1]);\n      if (this.enableCache) {\n        delete this.cache[oldId];\n      }\n    }\n    m[newId] = m.index;\n    m[m.index] = newId;\n    m.__keys__[key] = m.__keys__[key] || [];\n    m.__keys__[key].push(id);\n    if (this.enableCache) {\n      var cacheData = JSON.parse(data);\n      this.cache[newId] = cacheData;\n    }\n    var currentIndex = m.index;\n    if (++m.index === this._SIZE) {\n      m.index = 0;\n    }\n    this.setItem('map_' + currentIndex, data);\n    this.setItem('map', JSON.stringify(m));\n  };\n  _proto.save = function save(params) {\n    var _this2 = this;\n    var key = params.key,\n      id = params.id,\n      data = params.data,\n      rawData = params.rawData,\n      _params$expires = params.expires,\n      expires = _params$expires === void 0 ? this.defaultExpires : _params$expires;\n    if (key.toString().indexOf('_') !== -1) {\n      console.error('Please do not use \"_\" in key!');\n    }\n    var dataToSave = {\n      rawData: data\n    };\n    if (data === undefined) {\n      if (rawData !== undefined) {\n        console.warn('\"rawData\" is deprecated, please use \"data\" instead!');\n        dataToSave.rawData = rawData;\n      } else {\n        console.error('\"data\" is required in save()!');\n        return;\n      }\n    }\n    var now = Date.now();\n    if (expires !== null) {\n      dataToSave.expires = now + expires;\n    }\n    dataToSave = JSON.stringify(dataToSave);\n    if (id === undefined) {\n      if (this.enableCache) {\n        var cacheData = JSON.parse(dataToSave);\n        this.cache[key] = cacheData;\n      }\n      return this.setItem(key, dataToSave);\n    } else {\n      if (id.toString().indexOf('_') !== -1) {\n        console.error('Please do not use \"_\" in id!');\n      }\n      return this._mapPromise.then(function () {\n        return _this2._saveToMap({\n          key: key,\n          id: id,\n          data: dataToSave\n        });\n      });\n    }\n  };\n  _proto.getBatchData = function getBatchData(querys) {\n    var _this3 = this;\n    return Promise.all(querys.map(function (query) {\n      return _this3.load(query);\n    }));\n  };\n  _proto.getBatchDataWithIds = function getBatchDataWithIds(params) {\n    try {\n      var _this5 = this;\n      var key = params.key,\n        ids = params.ids,\n        syncInBackground = params.syncInBackground,\n        syncParams = params.syncParams;\n      var tasks = ids.map(function (id) {\n        return _this5.load({\n          key: key,\n          id: id,\n          syncInBackground: syncInBackground,\n          autoSync: false,\n          batched: true\n        });\n      });\n      return Promise.resolve(Promise.all(tasks)).then(function (results) {\n        var missingIds = [];\n        results.forEach(function (value) {\n          if (value.syncId !== undefined) {\n            missingIds.push(value.syncId);\n          }\n        });\n        if (missingIds.length) {\n          return Promise.resolve(_this5.sync[key]({\n            id: missingIds,\n            syncParams: syncParams\n          })).then(function (syncData) {\n            return results.map(function (value) {\n              return value.syncId ? syncData.shift() : value;\n            });\n          });\n        } else {\n          return results;\n        }\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n  _proto._lookupGlobalItem = function _lookupGlobalItem(params) {\n    var _this6 = this;\n    var key = params.key;\n    if (this.enableCache && this.cache[key] !== undefined) {\n      return this._loadGlobalItem(_extends({\n        ret: this.cache[key]\n      }, params));\n    }\n    return this.getItem(key).then(function (ret) {\n      return _this6._loadGlobalItem(_extends({\n        ret: ret\n      }, params));\n    });\n  };\n  _proto._loadGlobalItem = function _loadGlobalItem(params) {\n    var key = params.key,\n      ret = params.ret,\n      autoSync = params.autoSync,\n      syncInBackground = params.syncInBackground,\n      syncParams = params.syncParams;\n    if (ret === null || ret === undefined) {\n      if (autoSync && this.sync[key]) {\n        return this.sync[key]({\n          syncParams: syncParams\n        });\n      }\n      throw new NotFoundError(JSON.stringify(params));\n    }\n    if (typeof ret === 'string') {\n      ret = JSON.parse(ret);\n      if (this.enableCache) {\n        this.cache[key] = ret;\n      }\n    }\n    var now = Date.now();\n    if (ret.expires < now) {\n      if (autoSync && this.sync[key]) {\n        if (syncInBackground) {\n          try {\n            this.sync[key]({\n              syncParams: syncParams,\n              syncInBackground: syncInBackground\n            });\n          } catch (e) {// avoid uncaught exception\n          }\n          return ret.rawData;\n        }\n        return this.sync[key]({\n          syncParams: syncParams,\n          syncInBackground: syncInBackground\n        });\n      }\n      throw new ExpiredError(JSON.stringify(params));\n    }\n    return ret.rawData;\n  };\n  _proto._noItemFound = function _noItemFound(params) {\n    var key = params.key,\n      id = params.id,\n      autoSync = params.autoSync,\n      syncParams = params.syncParams;\n    if (this.sync[key]) {\n      if (autoSync) {\n        return this.sync[key]({\n          id: id,\n          syncParams: syncParams\n        });\n      }\n      return {\n        syncId: id\n      };\n    }\n    throw new NotFoundError(JSON.stringify(params));\n  };\n  _proto._loadMapItem = function _loadMapItem(params) {\n    var ret = params.ret,\n      key = params.key,\n      id = params.id,\n      autoSync = params.autoSync,\n      batched = params.batched,\n      syncInBackground = params.syncInBackground,\n      syncParams = params.syncParams;\n    if (ret === null || ret === undefined) {\n      return this._noItemFound(params);\n    }\n    if (typeof ret === 'string') {\n      ret = JSON.parse(ret);\n      var _key = params.key,\n        _id = params.id;\n      var newId = this._getId(_key, _id);\n      if (this.enableCache) {\n        this.cache[newId] = ret;\n      }\n    }\n    var now = Date.now();\n    if (ret.expires < now) {\n      if (autoSync && this.sync[key]) {\n        if (syncInBackground) {\n          try {\n            this.sync[key]({\n              id: id,\n              syncParams: syncParams,\n              syncInBackground: syncInBackground\n            });\n          } catch (e) {// avoid uncaught exception\n          }\n          return ret.rawData;\n        }\n        return this.sync[key]({\n          id: id,\n          syncParams: syncParams,\n          syncInBackground: syncInBackground\n        });\n      }\n      if (batched) {\n        return {\n          syncId: id\n        };\n      }\n      throw new ExpiredError(JSON.stringify(params));\n    }\n    return ret.rawData;\n  };\n  _proto._lookUpInMap = function _lookUpInMap(params) {\n    var _this7 = this;\n    var ret;\n    var m = this._m;\n    var key = params.key,\n      id = params.id;\n    var newId = this._getId(key, id);\n    if (this.enableCache && this.cache[newId]) {\n      ret = this.cache[newId];\n      return this._loadMapItem(_extends({\n        ret: ret\n      }, params));\n    }\n    if (m[newId] !== undefined) {\n      return this.getItem('map_' + m[newId]).then(function (ret) {\n        return _this7._loadMapItem(_extends({\n          ret: ret\n        }, params));\n      });\n    }\n    return this._noItemFound(_extends({\n      ret: ret\n    }, params));\n  };\n  _proto.remove = function remove(params) {\n    var _this8 = this;\n    return this._mapPromise.then(function () {\n      var m = _this8._m;\n      var key = params.key,\n        id = params.id;\n      if (id === undefined) {\n        if (_this8.enableCache && _this8.cache[key]) {\n          delete _this8.cache[key];\n        }\n        return _this8.removeItem(key);\n      }\n      var newId = _this8._getId(key, id); // remove existing data\n\n      if (m[newId] !== undefined) {\n        if (_this8.enableCache && _this8.cache[newId]) {\n          delete _this8.cache[newId];\n        }\n        _this8._removeIdInKey(key, id);\n        var idTobeDeleted = m[newId];\n        delete m[newId];\n        _this8.setItem('map', JSON.stringify(m));\n        return _this8.removeItem('map_' + idTobeDeleted);\n      }\n    });\n  };\n  _proto._removeIdInKey = function _removeIdInKey(key, id) {\n    var indexTobeRemoved = (this._m.__keys__[key] || []).indexOf(id);\n    if (indexTobeRemoved !== -1) {\n      this._m.__keys__[key].splice(indexTobeRemoved, 1);\n    }\n  };\n  _proto.load = function load(params) {\n    var _this9 = this;\n    var key = params.key,\n      id = params.id,\n      _params$autoSync = params.autoSync,\n      autoSync = _params$autoSync === void 0 ? true : _params$autoSync,\n      _params$syncInBackgro = params.syncInBackground,\n      syncInBackground = _params$syncInBackgro === void 0 ? true : _params$syncInBackgro,\n      syncParams = params.syncParams,\n      batched = params.batched;\n    return this._mapPromise.then(function () {\n      if (id === undefined) {\n        return _this9._lookupGlobalItem({\n          key: key,\n          autoSync: autoSync,\n          syncInBackground: syncInBackground,\n          syncParams: syncParams\n        });\n      } else {\n        return _this9._lookUpInMap({\n          key: key,\n          id: id,\n          autoSync: autoSync,\n          syncInBackground: syncInBackground,\n          batched: batched,\n          syncParams: syncParams\n        });\n      }\n    });\n  };\n  _proto.clearAll = function clearAll() {\n    this._s.clear && this._s.clear();\n    this._m = this._initMap();\n  };\n  _proto.clearMap = function clearMap() {\n    var _this10 = this;\n    return this.removeItem('map').then(function () {\n      _this10.cache = {};\n      _this10._m = _this10._initMap();\n    });\n  };\n  _proto.clearMapForKey = function clearMapForKey(key) {\n    var _this11 = this;\n    return this._mapPromise.then(function () {\n      var tasks = (_this11._m.__keys__[key] || []).map(function (id) {\n        return _this11.remove({\n          key: key,\n          id: id\n        });\n      });\n      return Promise.all(tasks);\n    });\n  };\n  _proto.getIdsForKey = function getIdsForKey(key) {\n    var _this12 = this;\n    return this._mapPromise.then(function () {\n      return _this12._m.__keys__[key] || [];\n    });\n  };\n  _proto.getAllDataForKey = function getAllDataForKey(key, options) {\n    var _this13 = this;\n    options = Object.assign({\n      syncInBackground: true\n    }, options);\n    return this.getIdsForKey(key).then(function (ids) {\n      var querys = ids.map(function (id) {\n        return {\n          key: key,\n          id: id,\n          syncInBackground: options.syncInBackground\n        };\n      });\n      return _this13.getBatchData(querys);\n    });\n  };\n  return Storage;\n}();\n\n// https://github.com/sunnylqm/react-native-storage\nfunction _catch(body, recover) {\n  try {\n    var result = body();\n  } catch (e) {\n    return recover(e);\n  }\n  if (result && result.then) {\n    return result.then(void 0, recover);\n  }\n  return result;\n}\nvar setCacheTokens = function setCacheTokens(g, cookieName) {\n  try {\n    var _temp15 = function () {\n      if (storage) {\n        return Promise.resolve(storage.save({\n          key: cookieName + \"token\",\n          data: g.token,\n          expires: 3600 * 1000 * 24\n        })).then(function () {\n          return Promise.resolve(storage.save({\n            key: cookieName + \"refreshToken\",\n            data: g.refreshToken,\n            expires: 3600 * 1000 * 24\n          })).then(function () {\n            return Promise.resolve(storage.save({\n              key: cookieName + \"session\",\n              data: g.session,\n              expires: null\n            })).then(function () {});\n          });\n        });\n      }\n    }();\n    return Promise.resolve(_temp15 && _temp15.then ? _temp15.then(function () {}) : void 0);\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\nvar clearCacheTokens = function clearCacheTokens(cookieName) {\n  try {\n    var _temp13 = function () {\n      if (storage) {\n        return Promise.resolve(storage.remove({\n          key: cookieName + \"token\"\n        })).then(function () {\n          return Promise.resolve(storage.remove({\n            key: cookieName + \"refreshToken\"\n          })).then(function () {\n            return Promise.resolve(storage.remove({\n              key: cookieName + \"session\"\n            })).then(function () {});\n          });\n        });\n      }\n    }();\n    return Promise.resolve(_temp13 && _temp13.then ? _temp13.then(function () {}) : void 0);\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\nvar getCacheTokens = function getCacheTokens(cookieName) {\n  try {\n    var _temp8 = function _temp8() {\n      return {\n        cacheToken: cacheToken,\n        cacheRefreshToken: cacheRefreshToken,\n        cacheSession: cacheSession\n      };\n    };\n    var cacheToken = false;\n    var cacheRefreshToken = false;\n    var cacheSession = false;\n    var _temp9 = function () {\n      if (storage) {\n        var _temp10 = function _temp10() {\n          function _temp3() {\n            var _temp = _catch(function () {\n              return Promise.resolve(storage.load({\n                key: cookieName + \"session\"\n              })).then(function (_storage$load3) {\n                cacheSession = _storage$load3;\n              });\n            }, function () {});\n            if (_temp && _temp.then) return _temp.then(function () {});\n          }\n          var _temp2 = _catch(function () {\n            return Promise.resolve(storage.load({\n              key: cookieName + \"refreshToken\"\n            })).then(function (_storage$load2) {\n              cacheRefreshToken = _storage$load2;\n            });\n          }, function () {});\n          return _temp2 && _temp2.then ? _temp2.then(_temp3) : _temp3(_temp2);\n        };\n        var _temp11 = _catch(function () {\n          return Promise.resolve(storage.load({\n            key: cookieName + \"token\"\n          })).then(function (_storage$load) {\n            cacheToken = _storage$load;\n          });\n        }, function () {});\n        return _temp11 && _temp11.then ? _temp11.then(_temp10) : _temp10(_temp11);\n      }\n    }();\n    return Promise.resolve(_temp9 && _temp9.then ? _temp9.then(_temp8) : _temp8(_temp9));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\nvar storage = typeof window !== 'undefined' ? new Storage({\n  storageBackend: window.localStorage\n}) : undefined;\nexports.clearCacheTokens = clearCacheTokens;\nexports.getCacheTokens = getCacheTokens;\nexports.setCacheTokens = setCacheTokens;","map":{"version":3,"mappings":"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","names":["NotFoundError","_inheritsLoose","message","_this","name","stack","Error","ExpiredError","_this2","Storage","options","_SIZE","size","sync","defaultExpires","undefined","enableCache","_s","storageBackend","_innerVersion","cache","setItem","promiseTest","isPromise","then","e","console","warn","_mapPromise","getItem","_m","_checkMap","map","JSON","parse","key","Promise","resolve","value","removeItem","_initMap","innerVersion","index","__keys__","_getId","id","_saveToMap","params","data","newId","m","oldId","splitOldId","split","_removeIdInKey","push","cacheData","currentIndex","stringify","save","rawData","_params$expires","expires","toString","indexOf","error","dataToSave","now","Date","getBatchData","querys","all","_this3","load","query","getBatchDataWithIds","ids","syncInBackground","syncParams","tasks","_this5","autoSync","batched","results","missingIds","forEach","syncId","length","syncData","shift","_lookupGlobalItem","_loadGlobalItem","ret","_this6","_noItemFound","_loadMapItem","_lookUpInMap","_this7","remove","_this8","idTobeDeleted","indexTobeRemoved","splice","_params$autoSync","_params$syncInBackgro","_this9","clearAll","clear","clearMap","_this10","clearMapForKey","_this11","getIdsForKey","_this12","getAllDataForKey","Object","assign","_this13","setCacheTokens","g","cookieName","storage","token","refreshToken","session","clearCacheTokens","getCacheTokens","cacheToken","cacheRefreshToken","cacheSession","window","localStorage"],"sources":["/home/sol/Documentos/AUS/3ro segundo cuatri/ing 2/URV/front/node_modules/easybase-react/src/storage/error.js","/home/sol/Documentos/AUS/3ro segundo cuatri/ing 2/URV/front/node_modules/easybase-react/src/storage/index.js","/home/sol/Documentos/AUS/3ro segundo cuatri/ing 2/URV/front/node_modules/easybase-react/src/cache.ts"],"sourcesContent":["/**\n * Ported from https://github.com/sunnylqm/react-native-storage\n * Credit: Sunny Luo /sunnylqm\n */\n\n/**\n * Created by sunny on 9/1/16.\n */\n\nexport class NotFoundError extends Error {\n    constructor(message) {\n        super(`Not Found! Params: ${message}`);\n        this.name = 'NotFoundError';\n        this.stack = new Error().stack; // Optional\n    }\n}\n// NotFoundError.prototype = Object.create(Error.prototype);\n\nexport class ExpiredError extends Error {\n    constructor(message) {\n        super(`Expired! Params: ${message}`);\n        this.name = 'ExpiredError';\n        this.stack = new Error().stack; // Optional\n    }\n}\n","/* eslint-disable */\n\n/**\n * Ported from https://github.com/sunnylqm/react-native-storage\n * Credit: Sunny Luo /sunnylqm\n */\n\n/*\n *  local storage(web/react native) wrapper\n *  sunnylqm\n */\nimport { NotFoundError, ExpiredError } from './error';\n\nexport { NotFoundError, ExpiredError };\n\nexport default class Storage {\n    constructor(options = {}) {\n        this._SIZE = options.size || 1000; // maximum key-ids capacity\n        this.sync = options.sync || {}; // remote sync method\n        this.defaultExpires = options.defaultExpires !== undefined ? options.defaultExpires : 1000 * 3600 * 24;\n        this.enableCache = options.enableCache !== false;\n        this._s = options.storageBackend || null;\n        this._innerVersion = 11;\n        this.cache = {};\n\n        if (this._s && this._s.setItem) {\n            try {\n                var promiseTest = this._s.setItem('__react_native_storage_test', 'test');\n                this.isPromise = !!(promiseTest && promiseTest.then);\n            } catch (e) {\n                console.warn(e);\n                delete this._s;\n                throw e;\n            }\n        } else {\n            console.warn(`Data would be lost after reload cause there is no storageBackend specified!\n      \\nEither use localStorage(for web) or AsyncStorage(for React Native) as a storageBackend.`);\n        }\n\n        this._mapPromise = this.getItem('map').then(map => {\n            this._m = this._checkMap((map && JSON.parse(map)) || {});\n        });\n    }\n    getItem(key) {\n        return this._s\n            ? this.isPromise\n                ? this._s.getItem(key)\n                : Promise.resolve(this._s.getItem(key))\n            : Promise.resolve();\n    }\n    setItem(key, value) {\n        return this._s\n            ? this.isPromise\n                ? this._s.setItem(key, value)\n                : Promise.resolve(this._s.setItem(key, value))\n            : Promise.resolve();\n    }\n    removeItem(key) {\n        return this._s\n            ? this.isPromise\n                ? this._s.removeItem(key)\n                : Promise.resolve(this._s.removeItem(key))\n            : Promise.resolve();\n    }\n    _initMap() {\n        return {\n            innerVersion: this._innerVersion,\n            index: 0,\n            __keys__: {},\n        };\n    }\n    _checkMap(map) {\n        if (map && map.innerVersion && map.innerVersion === this._innerVersion) {\n            return map;\n        } else {\n            return this._initMap();\n        }\n    }\n    _getId(key, id) {\n        return key + '_' + id;\n    }\n    _saveToMap(params) {\n        let { key, id, data } = params,\n            newId = this._getId(key, id),\n            m = this._m;\n        if (m[newId] !== undefined) {\n            // update existing data\n            if (this.enableCache) this.cache[newId] = JSON.parse(data);\n            return this.setItem('map_' + m[newId], data);\n        }\n        if (m[m.index] !== undefined) {\n            // loop over, delete old data\n            let oldId = m[m.index];\n            let splitOldId = oldId.split('_');\n            delete m[oldId];\n            this._removeIdInKey(splitOldId[0], splitOldId[1]);\n            if (this.enableCache) {\n                delete this.cache[oldId];\n            }\n        }\n        m[newId] = m.index;\n        m[m.index] = newId;\n\n        m.__keys__[key] = m.__keys__[key] || [];\n        m.__keys__[key].push(id);\n\n        if (this.enableCache) {\n            const cacheData = JSON.parse(data);\n            this.cache[newId] = cacheData;\n        }\n        let currentIndex = m.index;\n        if (++m.index === this._SIZE) {\n            m.index = 0;\n        }\n        this.setItem('map_' + currentIndex, data);\n        this.setItem('map', JSON.stringify(m));\n    }\n    save(params) {\n        const { key, id, data, rawData, expires = this.defaultExpires } = params;\n        if (key.toString().indexOf('_') !== -1) {\n            console.error('Please do not use \"_\" in key!');\n        }\n        let dataToSave = { rawData: data };\n        if (data === undefined) {\n            if (rawData !== undefined) {\n                console.warn('\"rawData\" is deprecated, please use \"data\" instead!');\n                dataToSave.rawData = rawData;\n            } else {\n                console.error('\"data\" is required in save()!');\n                return;\n            }\n        }\n        let now = Date.now();\n        if (expires !== null) {\n            dataToSave.expires = now + expires;\n        }\n        dataToSave = JSON.stringify(dataToSave);\n        if (id === undefined) {\n            if (this.enableCache) {\n                const cacheData = JSON.parse(dataToSave);\n                this.cache[key] = cacheData;\n            }\n            return this.setItem(key, dataToSave);\n        } else {\n            if (id.toString().indexOf('_') !== -1) {\n                console.error('Please do not use \"_\" in id!');\n            }\n            return this._mapPromise.then(() =>\n                this._saveToMap({\n                    key,\n                    id,\n                    data: dataToSave,\n                }),\n            );\n        }\n    }\n    getBatchData(querys) {\n        return Promise.all(querys.map(query => this.load(query)));\n    }\n    async getBatchDataWithIds(params) {\n        let { key, ids, syncInBackground, syncParams } = params;\n        const tasks = ids.map(id =>\n            this.load({\n                key,\n                id,\n                syncInBackground,\n                autoSync: false,\n                batched: true,\n            }),\n        );\n        const results = await Promise.all(tasks);\n        const missingIds = [];\n        results.forEach(value => {\n            if (value.syncId !== undefined) {\n                missingIds.push(value.syncId);\n            }\n        });\n        if (missingIds.length) {\n            const syncData = await this.sync[key]({\n                id: missingIds,\n                syncParams,\n            });\n            return results.map(value => {\n                return value.syncId ? syncData.shift() : value;\n            });\n        } else {\n            return results;\n        }\n    }\n    _lookupGlobalItem(params) {\n        const { key } = params;\n        if (this.enableCache && this.cache[key] !== undefined) {\n            return this._loadGlobalItem({ ret: this.cache[key], ...params });\n        }\n        return this.getItem(key).then(ret => this._loadGlobalItem({ ret, ...params }));\n    }\n    _loadGlobalItem(params) {\n        let { key, ret, autoSync, syncInBackground, syncParams } = params;\n        if (ret === null || ret === undefined) {\n            if (autoSync && this.sync[key]) {\n                return this.sync[key]({ syncParams });\n            }\n            throw new NotFoundError(JSON.stringify(params));\n        }\n        if (typeof ret === 'string') {\n            ret = JSON.parse(ret);\n            if (this.enableCache) {\n                this.cache[key] = ret;\n            }\n        }\n        let now = Date.now();\n        if (ret.expires < now) {\n            if (autoSync && this.sync[key]) {\n                if (syncInBackground) {\n                    try {\n                        this.sync[key]({ syncParams, syncInBackground });\n                    } catch (e) {\n                        // avoid uncaught exception\n                    }\n                    return ret.rawData;\n                }\n                return this.sync[key]({ syncParams, syncInBackground });\n            }\n            throw new ExpiredError(JSON.stringify(params));\n        }\n        return ret.rawData;\n    }\n    _noItemFound(params) {\n        let { key, id, autoSync, syncParams } = params;\n        if (this.sync[key]) {\n            if (autoSync) {\n                return this.sync[key]({ id, syncParams });\n            }\n            return { syncId: id };\n        }\n        throw new NotFoundError(JSON.stringify(params));\n    }\n    _loadMapItem(params) {\n        let { ret, key, id, autoSync, batched, syncInBackground, syncParams } = params;\n        if (ret === null || ret === undefined) {\n            return this._noItemFound(params);\n        }\n        if (typeof ret === 'string') {\n            ret = JSON.parse(ret);\n            const { key, id } = params;\n            const newId = this._getId(key, id);\n            if (this.enableCache) {\n                this.cache[newId] = ret;\n            }\n        }\n        let now = Date.now();\n        if (ret.expires < now) {\n            if (autoSync && this.sync[key]) {\n                if (syncInBackground) {\n                    try {\n                        this.sync[key]({ id, syncParams, syncInBackground });\n                    } catch (e) {\n                        // avoid uncaught exception\n                    }\n                    return ret.rawData;\n                }\n                return this.sync[key]({ id, syncParams, syncInBackground });\n            }\n            if (batched) {\n                return { syncId: id };\n            }\n            throw new ExpiredError(JSON.stringify(params));\n        }\n        return ret.rawData;\n    }\n    _lookUpInMap(params) {\n        let ret;\n        const m = this._m;\n        const { key, id } = params;\n        const newId = this._getId(key, id);\n        if (this.enableCache && this.cache[newId]) {\n            ret = this.cache[newId];\n            return this._loadMapItem({ ret, ...params });\n        }\n        if (m[newId] !== undefined) {\n            return this.getItem('map_' + m[newId]).then(ret => this._loadMapItem({ ret, ...params }));\n        }\n        return this._noItemFound({ ret, ...params });\n    }\n    remove(params) {\n        return this._mapPromise.then(() => {\n            let m = this._m;\n            let { key, id } = params;\n\n            if (id === undefined) {\n                if (this.enableCache && this.cache[key]) {\n                    delete this.cache[key];\n                }\n                return this.removeItem(key);\n            }\n            let newId = this._getId(key, id);\n\n            // remove existing data\n            if (m[newId] !== undefined) {\n                if (this.enableCache && this.cache[newId]) {\n                    delete this.cache[newId];\n                }\n                this._removeIdInKey(key, id);\n                let idTobeDeleted = m[newId];\n                delete m[newId];\n                this.setItem('map', JSON.stringify(m));\n                return this.removeItem('map_' + idTobeDeleted);\n            }\n        });\n    }\n    _removeIdInKey(key, id) {\n        const indexTobeRemoved = (this._m.__keys__[key] || []).indexOf(id);\n        if (indexTobeRemoved !== -1) {\n            this._m.__keys__[key].splice(indexTobeRemoved, 1);\n        }\n    }\n    load(params) {\n        const { key, id, autoSync = true, syncInBackground = true, syncParams, batched } = params;\n        return this._mapPromise.then(() => {\n            if (id === undefined) {\n                return this._lookupGlobalItem({\n                    key,\n                    autoSync,\n                    syncInBackground,\n                    syncParams,\n                });\n            } else {\n                return this._lookUpInMap({\n                    key,\n                    id,\n                    autoSync,\n                    syncInBackground,\n                    batched,\n                    syncParams,\n                });\n            }\n        });\n    }\n    clearAll() {\n        this._s.clear && this._s.clear();\n        this._m = this._initMap();\n    }\n    clearMap() {\n        return this.removeItem('map').then(() => {\n            this.cache = {};\n            this._m = this._initMap();\n        });\n    }\n    clearMapForKey(key) {\n        return this._mapPromise.then(() => {\n            let tasks = (this._m.__keys__[key] || []).map(id => this.remove({ key, id }));\n            return Promise.all(tasks);\n        });\n    }\n    getIdsForKey(key) {\n        return this._mapPromise.then(() => {\n            return this._m.__keys__[key] || [];\n        });\n    }\n    getAllDataForKey(key, options) {\n        options = Object.assign({ syncInBackground: true }, options);\n        return this.getIdsForKey(key).then(ids => {\n            const querys = ids.map(id => ({ key, id, syncInBackground: options.syncInBackground }));\n            return this.getBatchData(querys);\n        });\n    }\n}\n","import Storage from './storage';\n\nconst storage = typeof window !== 'undefined' ? new Storage({ storageBackend: window.localStorage }) : undefined;\n\n// https://github.com/sunnylqm/react-native-storage\nexport async function getCacheTokens(cookieName: string): Promise<Record<string, any>> {\n    let cacheToken = false;\n    let cacheRefreshToken = false;\n    let cacheSession = false;\n\n    if (storage) {\n        try {\n            cacheToken = await storage.load({ key: cookieName + \"token\" });\n        } catch (_) { }\n\n        try {\n            cacheRefreshToken = await storage.load({ key: cookieName + \"refreshToken\" });\n        } catch (_) { }\n\n        try {\n            cacheSession = await storage.load({ key: cookieName + \"session\" });\n        } catch (_) { }\n    }\n\n    return {\n        cacheToken,\n        cacheRefreshToken,\n        cacheSession\n    }\n}\n\nexport async function clearCacheTokens(cookieName: string) {\n    if (storage) {\n        await storage.remove({ key: cookieName + \"token\" });\n        await storage.remove({ key: cookieName + \"refreshToken\" });\n        await storage.remove({ key: cookieName + \"session\" });\n    }\n}\n\nexport async function setCacheTokens(g: any, cookieName: string) {\n    if (storage) {\n        await storage.save({\n            key: cookieName + \"token\",\n            data: g.token,\n            expires: 3600 * 1000 * 24\n        });\n\n        await storage.save({\n            key: cookieName + \"refreshToken\",\n            data: g.refreshToken,\n            expires: 3600 * 1000 * 24\n        });\n\n        await storage.save({\n            key: cookieName + \"session\",\n            data: g.session,\n            expires: null\n        });\n    }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}