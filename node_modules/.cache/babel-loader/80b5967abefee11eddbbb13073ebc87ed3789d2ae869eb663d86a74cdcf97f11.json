{"ast":null,"code":"import { useEffect, useRef, useCallback } from 'react';\nimport { useContext } from './context';\nimport useStateMachine from './state-machine';\n/**\n * Retrieves a document and subscribes to it's changes.\n * @param {string} id - Document ID of the document that should be fetched.\n * @param {object} [options] - PouchDB get options. Excluding 'open_revs'.\n * @param {object|function} [initialValue] - Value that should be returned while fetching the doc.\n */\nexport default function useDoc(id, options, initialValue) {\n  const {\n    pouchdb: pouch,\n    subscriptionManager\n  } = useContext(options === null || options === void 0 ? void 0 : options.db);\n  const {\n    rev,\n    revs,\n    revs_info,\n    conflicts,\n    attachments,\n    binary,\n    latest\n  } = options || {};\n  const getInitialValue = useCallback(() => {\n    let doc = null;\n    if (typeof initialValue === 'function') {\n      doc = initialValue();\n    } else if (initialValue && typeof initialValue === 'object') {\n      doc = initialValue;\n    }\n    const resultDoc = doc;\n    // Add _id and _rev to the initial value (if they aren't set)\n    if (resultDoc && resultDoc._id == null) {\n      resultDoc._id = id;\n    }\n    if (resultDoc && resultDoc._rev == null) {\n      resultDoc._rev = '';\n    }\n    return {\n      doc: resultDoc\n    };\n  }, [id, initialValue]);\n  const [state, dispatch] = useStateMachine(getInitialValue);\n  // Reset the document if the id did change and a initial value is set.\n  const lastId = useRef(id);\n  useEffect(() => {\n    if (id === lastId.current) return;\n    lastId.current = id;\n    if (initialValue != null) {\n      dispatch({\n        type: 'loading_finished',\n        payload: getInitialValue()\n      });\n    }\n  }, [id, initialValue, getInitialValue, dispatch]);\n  // Workaround, that initial value can change on every render, without re-run the query effect.\n  // eslint-plugin-react-hooks missing dependency for all other dependency, but getInitialValue.\n  const getInitialValueRef = useRef(getInitialValue);\n  getInitialValueRef.current = getInitialValue;\n  useEffect(() => {\n    // Is this instance still current?\n    let isMounted = true;\n    const fetchDoc = async () => {\n      dispatch({\n        type: 'loading_started'\n      });\n      try {\n        const doc = await pouch.get(id, {\n          rev,\n          revs,\n          revs_info,\n          conflicts,\n          attachments,\n          binary,\n          latest\n        });\n        if (isMounted) {\n          dispatch({\n            type: 'loading_finished',\n            payload: {\n              doc\n            }\n          });\n        }\n      } catch (err) {\n        if (isMounted) {\n          dispatch({\n            type: 'loading_error',\n            payload: {\n              error: err,\n              setResult: true,\n              result: getInitialValueRef.current()\n            }\n          });\n        }\n      }\n    };\n    fetchDoc();\n    // Use the changes feed to get updates to the document\n    const unsubscribe = rev && !latest // but don't subscribe if a specific rev is requested.\n    ? () => {\n      return;\n    } : subscriptionManager.subscribeToDocs([id], (deleted, _id, doc) => {\n      if (!isMounted) return;\n      // If the document got deleted it should change to an 404 error state\n      // or if there is a conflicting version, then it should show the new winning one.\n      if (deleted || revs || revs_info || conflicts || attachments) {\n        fetchDoc();\n      } else {\n        dispatch({\n          type: 'loading_finished',\n          payload: {\n            doc: doc\n          }\n        });\n      }\n    });\n    return () => {\n      isMounted = false;\n      unsubscribe();\n    };\n  }, [dispatch, pouch, subscriptionManager, id, rev, revs, revs_info, conflicts, attachments, binary, latest]);\n  return state;\n}","map":{"version":3,"names":["useEffect","useRef","useCallback","useContext","useStateMachine","useDoc","id","options","initialValue","pouchdb","pouch","subscriptionManager","db","rev","revs","revs_info","conflicts","attachments","binary","latest","getInitialValue","doc","resultDoc","_id","_rev","state","dispatch","lastId","current","type","payload","getInitialValueRef","isMounted","fetchDoc","get","err","error","setResult","result","unsubscribe","subscribeToDocs","deleted"],"sources":["/home/sol/Documentos/AUS/3ro segundo cuatri/ing 2/URV/node_modules/use-pouchdb/lib/useDoc.js"],"sourcesContent":["import { useEffect, useRef, useCallback } from 'react';\nimport { useContext } from './context';\nimport useStateMachine from './state-machine';\n/**\n * Retrieves a document and subscribes to it's changes.\n * @param {string} id - Document ID of the document that should be fetched.\n * @param {object} [options] - PouchDB get options. Excluding 'open_revs'.\n * @param {object|function} [initialValue] - Value that should be returned while fetching the doc.\n */\nexport default function useDoc(id, options, initialValue) {\n    const { pouchdb: pouch, subscriptionManager } = useContext(options === null || options === void 0 ? void 0 : options.db);\n    const { rev, revs, revs_info, conflicts, attachments, binary, latest } = options || {};\n    const getInitialValue = useCallback(() => {\n        let doc = null;\n        if (typeof initialValue === 'function') {\n            doc = initialValue();\n        }\n        else if (initialValue && typeof initialValue === 'object') {\n            doc = initialValue;\n        }\n        const resultDoc = doc;\n        // Add _id and _rev to the initial value (if they aren't set)\n        if (resultDoc && resultDoc._id == null) {\n            resultDoc._id = id;\n        }\n        if (resultDoc && resultDoc._rev == null) {\n            resultDoc._rev = '';\n        }\n        return { doc: resultDoc };\n    }, [id, initialValue]);\n    const [state, dispatch] = useStateMachine(getInitialValue);\n    // Reset the document if the id did change and a initial value is set.\n    const lastId = useRef(id);\n    useEffect(() => {\n        if (id === lastId.current)\n            return;\n        lastId.current = id;\n        if (initialValue != null) {\n            dispatch({\n                type: 'loading_finished',\n                payload: getInitialValue(),\n            });\n        }\n    }, [id, initialValue, getInitialValue, dispatch]);\n    // Workaround, that initial value can change on every render, without re-run the query effect.\n    // eslint-plugin-react-hooks missing dependency for all other dependency, but getInitialValue.\n    const getInitialValueRef = useRef(getInitialValue);\n    getInitialValueRef.current = getInitialValue;\n    useEffect(() => {\n        // Is this instance still current?\n        let isMounted = true;\n        const fetchDoc = async () => {\n            dispatch({ type: 'loading_started' });\n            try {\n                const doc = await pouch.get(id, {\n                    rev,\n                    revs,\n                    revs_info,\n                    conflicts,\n                    attachments,\n                    binary,\n                    latest,\n                });\n                if (isMounted) {\n                    dispatch({\n                        type: 'loading_finished',\n                        payload: { doc },\n                    });\n                }\n            }\n            catch (err) {\n                if (isMounted) {\n                    dispatch({\n                        type: 'loading_error',\n                        payload: {\n                            error: err,\n                            setResult: true,\n                            result: getInitialValueRef.current(),\n                        },\n                    });\n                }\n            }\n        };\n        fetchDoc();\n        // Use the changes feed to get updates to the document\n        const unsubscribe = rev && !latest // but don't subscribe if a specific rev is requested.\n            ? () => {\n                return;\n            }\n            : subscriptionManager.subscribeToDocs([id], (deleted, _id, doc) => {\n                if (!isMounted)\n                    return;\n                // If the document got deleted it should change to an 404 error state\n                // or if there is a conflicting version, then it should show the new winning one.\n                if (deleted || revs || revs_info || conflicts || attachments) {\n                    fetchDoc();\n                }\n                else {\n                    dispatch({\n                        type: 'loading_finished',\n                        payload: {\n                            doc: doc,\n                        },\n                    });\n                }\n            });\n        return () => {\n            isMounted = false;\n            unsubscribe();\n        };\n    }, [\n        dispatch,\n        pouch,\n        subscriptionManager,\n        id,\n        rev,\n        revs,\n        revs_info,\n        conflicts,\n        attachments,\n        binary,\n        latest,\n    ]);\n    return state;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}