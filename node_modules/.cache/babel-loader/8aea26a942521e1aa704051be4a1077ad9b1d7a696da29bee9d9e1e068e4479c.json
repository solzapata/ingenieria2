{"ast":null,"code":"import { clone } from 'pouchdb-utils';\nimport { collate } from 'pouchdb-collate';\n\n// this would just be \"return doc[field]\", but fields\n// can be \"deep\" due to dot notation\nfunction getFieldFromDoc(doc, parsedField) {\n  var value = doc;\n  for (var i = 0, len = parsedField.length; i < len; i++) {\n    var key = parsedField[i];\n    value = value[key];\n    if (!value) {\n      break;\n    }\n  }\n  return value;\n}\nfunction setFieldInDoc(doc, parsedField, value) {\n  for (var i = 0, len = parsedField.length; i < len - 1; i++) {\n    var elem = parsedField[i];\n    doc = doc[elem] = doc[elem] || {};\n  }\n  doc[parsedField[len - 1]] = value;\n}\nfunction compare(left, right) {\n  return left < right ? -1 : left > right ? 1 : 0;\n}\n\n// Converts a string in dot notation to an array of its components, with backslash escaping\nfunction parseField(fieldName) {\n  // fields may be deep (e.g. \"foo.bar.baz\"), so parse\n  var fields = [];\n  var current = '';\n  for (var i = 0, len = fieldName.length; i < len; i++) {\n    var ch = fieldName[i];\n    if (i > 0 && fieldName[i - 1] === '\\\\' && (ch === '$' || ch === '.')) {\n      // escaped delimiter\n      current = current.substring(0, current.length - 1) + ch;\n    } else if (ch === '.') {\n      // When `.` is not escaped (above), it is a field delimiter\n      fields.push(current);\n      current = '';\n    } else {\n      // normal character\n      current += ch;\n    }\n  }\n  fields.push(current);\n  return fields;\n}\nvar combinationFields = ['$or', '$nor', '$not'];\nfunction isCombinationalField(field) {\n  return combinationFields.indexOf(field) > -1;\n}\nfunction getKey(obj) {\n  return Object.keys(obj)[0];\n}\nfunction getValue(obj) {\n  return obj[getKey(obj)];\n}\n\n// flatten an array of selectors joined by an $and operator\nfunction mergeAndedSelectors(selectors) {\n  // sort to ensure that e.g. if the user specified\n  // $and: [{$gt: 'a'}, {$gt: 'b'}], then it's collapsed into\n  // just {$gt: 'b'}\n  var res = {};\n  var first = {\n    $or: true,\n    $nor: true\n  };\n  selectors.forEach(function (selector) {\n    Object.keys(selector).forEach(function (field) {\n      var matcher = selector[field];\n      if (typeof matcher !== 'object') {\n        matcher = {\n          $eq: matcher\n        };\n      }\n      if (isCombinationalField(field)) {\n        // or, nor\n        if (matcher instanceof Array) {\n          if (first[field]) {\n            first[field] = false;\n            res[field] = matcher;\n            return;\n          }\n          var entries = [];\n          res[field].forEach(function (existing) {\n            Object.keys(matcher).forEach(function (key) {\n              var m = matcher[key];\n              var longest = Math.max(Object.keys(existing).length, Object.keys(m).length);\n              var merged = mergeAndedSelectors([existing, m]);\n              if (Object.keys(merged).length <= longest) {\n                // we have a situation like: (a :{$eq :1} || ...) && (a {$eq: 2} || ...)\n                // merging would produce a $eq 2 when actually we shouldn't ever match against these merged conditions\n                // merged should always contain more values to be valid\n                return;\n              }\n              entries.push(merged);\n            });\n          });\n          res[field] = entries;\n        } else {\n          // not\n          res[field] = mergeAndedSelectors([matcher]);\n        }\n      } else {\n        var fieldMatchers = res[field] = res[field] || {};\n        Object.keys(matcher).forEach(function (operator) {\n          var value = matcher[operator];\n          if (operator === '$gt' || operator === '$gte') {\n            return mergeGtGte(operator, value, fieldMatchers);\n          } else if (operator === '$lt' || operator === '$lte') {\n            return mergeLtLte(operator, value, fieldMatchers);\n          } else if (operator === '$ne') {\n            return mergeNe(value, fieldMatchers);\n          } else if (operator === '$eq') {\n            return mergeEq(value, fieldMatchers);\n          } else if (operator === \"$regex\") {\n            return mergeRegex(value, fieldMatchers);\n          }\n          fieldMatchers[operator] = value;\n        });\n      }\n    });\n  });\n  return res;\n}\n\n// collapse logically equivalent gt/gte values\nfunction mergeGtGte(operator, value, fieldMatchers) {\n  if (typeof fieldMatchers.$eq !== 'undefined') {\n    return; // do nothing\n  }\n\n  if (typeof fieldMatchers.$gte !== 'undefined') {\n    if (operator === '$gte') {\n      if (value > fieldMatchers.$gte) {\n        // more specificity\n        fieldMatchers.$gte = value;\n      }\n    } else {\n      // operator === '$gt'\n      if (value >= fieldMatchers.$gte) {\n        // more specificity\n        delete fieldMatchers.$gte;\n        fieldMatchers.$gt = value;\n      }\n    }\n  } else if (typeof fieldMatchers.$gt !== 'undefined') {\n    if (operator === '$gte') {\n      if (value > fieldMatchers.$gt) {\n        // more specificity\n        delete fieldMatchers.$gt;\n        fieldMatchers.$gte = value;\n      }\n    } else {\n      // operator === '$gt'\n      if (value > fieldMatchers.$gt) {\n        // more specificity\n        fieldMatchers.$gt = value;\n      }\n    }\n  } else {\n    fieldMatchers[operator] = value;\n  }\n}\n\n// collapse logically equivalent lt/lte values\nfunction mergeLtLte(operator, value, fieldMatchers) {\n  if (typeof fieldMatchers.$eq !== 'undefined') {\n    return; // do nothing\n  }\n\n  if (typeof fieldMatchers.$lte !== 'undefined') {\n    if (operator === '$lte') {\n      if (value < fieldMatchers.$lte) {\n        // more specificity\n        fieldMatchers.$lte = value;\n      }\n    } else {\n      // operator === '$gt'\n      if (value <= fieldMatchers.$lte) {\n        // more specificity\n        delete fieldMatchers.$lte;\n        fieldMatchers.$lt = value;\n      }\n    }\n  } else if (typeof fieldMatchers.$lt !== 'undefined') {\n    if (operator === '$lte') {\n      if (value < fieldMatchers.$lt) {\n        // more specificity\n        delete fieldMatchers.$lt;\n        fieldMatchers.$lte = value;\n      }\n    } else {\n      // operator === '$gt'\n      if (value < fieldMatchers.$lt) {\n        // more specificity\n        fieldMatchers.$lt = value;\n      }\n    }\n  } else {\n    fieldMatchers[operator] = value;\n  }\n}\n\n// combine $ne values into one array\nfunction mergeNe(value, fieldMatchers) {\n  if ('$ne' in fieldMatchers) {\n    // there are many things this could \"not\" be\n    fieldMatchers.$ne.push(value);\n  } else {\n    // doesn't exist yet\n    fieldMatchers.$ne = [value];\n  }\n}\n\n// add $eq into the mix\nfunction mergeEq(value, fieldMatchers) {\n  // these all have less specificity than the $eq\n  // TODO: check for user errors here\n  delete fieldMatchers.$gt;\n  delete fieldMatchers.$gte;\n  delete fieldMatchers.$lt;\n  delete fieldMatchers.$lte;\n  delete fieldMatchers.$ne;\n  fieldMatchers.$eq = value;\n}\n\n// combine $regex values into one array\nfunction mergeRegex(value, fieldMatchers) {\n  if ('$regex' in fieldMatchers) {\n    // a value could match multiple regexes\n    fieldMatchers.$regex.push(value);\n  } else {\n    // doesn't exist yet\n    fieldMatchers.$regex = [value];\n  }\n}\n\n//#7458: execute function mergeAndedSelectors on nested $and\nfunction mergeAndedSelectorsNested(obj) {\n  for (var prop in obj) {\n    if (Array.isArray(obj)) {\n      for (var i in obj) {\n        if (obj[i]['$and']) {\n          obj[i] = mergeAndedSelectors(obj[i]['$and']);\n        }\n      }\n    }\n    var value = obj[prop];\n    if (typeof value === 'object') {\n      mergeAndedSelectorsNested(value); // <- recursive call\n    }\n  }\n\n  return obj;\n}\n\n//#7458: determine id $and is present in selector (at any level)\nfunction isAndInSelector(obj, isAnd) {\n  for (var prop in obj) {\n    if (prop === '$and') {\n      isAnd = true;\n    }\n    var value = obj[prop];\n    if (typeof value === 'object') {\n      isAnd = isAndInSelector(value, isAnd); // <- recursive call\n    }\n  }\n\n  return isAnd;\n}\n\n//\n// normalize the selector\n//\nfunction massageSelector(input) {\n  var result = clone(input);\n  var wasAnded = false;\n  //#7458: if $and is present in selector (at any level) merge nested $and\n  if (isAndInSelector(result, false)) {\n    result = mergeAndedSelectorsNested(result);\n    if ('$and' in result) {\n      result = mergeAndedSelectors(result['$and']);\n    }\n    wasAnded = true;\n  }\n  ['$or', '$nor'].forEach(function (orOrNor) {\n    if (orOrNor in result) {\n      // message each individual selector\n      // e.g. {foo: 'bar'} becomes {foo: {$eq: 'bar'}}\n      result[orOrNor].forEach(function (subSelector) {\n        var fields = Object.keys(subSelector);\n        for (var i = 0; i < fields.length; i++) {\n          var field = fields[i];\n          var matcher = subSelector[field];\n          if (typeof matcher !== 'object' || matcher === null) {\n            subSelector[field] = {\n              $eq: matcher\n            };\n          }\n        }\n      });\n    }\n  });\n  if ('$not' in result) {\n    //This feels a little like forcing, but it will work for now,\n    //I would like to come back to this and make the merging of selectors a little more generic\n    result['$not'] = mergeAndedSelectors([result['$not']]);\n  }\n  var fields = Object.keys(result);\n  for (var i = 0; i < fields.length; i++) {\n    var field = fields[i];\n    var matcher = result[field];\n    if (typeof matcher !== 'object' || matcher === null) {\n      matcher = {\n        $eq: matcher\n      };\n    } else if (!wasAnded) {\n      // These values must be placed in an array because these operators can be used multiple times on the same field\n      // when $and is used, mergeAndedSelectors takes care of putting them into arrays, otherwise it's done here:\n      if ('$ne' in matcher) {\n        matcher.$ne = [matcher.$ne];\n      }\n      if ('$regex' in matcher) {\n        matcher.$regex = [matcher.$regex];\n      }\n    }\n    result[field] = matcher;\n  }\n  return result;\n}\n\n// create a comparator based on the sort object\nfunction createFieldSorter(sort) {\n  function getFieldValuesAsArray(doc) {\n    return sort.map(function (sorting) {\n      var fieldName = getKey(sorting);\n      var parsedField = parseField(fieldName);\n      var docFieldValue = getFieldFromDoc(doc, parsedField);\n      return docFieldValue;\n    });\n  }\n  return function (aRow, bRow) {\n    var aFieldValues = getFieldValuesAsArray(aRow.doc);\n    var bFieldValues = getFieldValuesAsArray(bRow.doc);\n    var collation = collate(aFieldValues, bFieldValues);\n    if (collation !== 0) {\n      return collation;\n    }\n    // this is what mango seems to do\n    return compare(aRow.doc._id, bRow.doc._id);\n  };\n}\nfunction filterInMemoryFields(rows, requestDef, inMemoryFields) {\n  rows = rows.filter(function (row) {\n    return rowFilter(row.doc, requestDef.selector, inMemoryFields);\n  });\n  if (requestDef.sort) {\n    // in-memory sort\n    var fieldSorter = createFieldSorter(requestDef.sort);\n    rows = rows.sort(fieldSorter);\n    if (typeof requestDef.sort[0] !== 'string' && getValue(requestDef.sort[0]) === 'desc') {\n      rows = rows.reverse();\n    }\n  }\n  if ('limit' in requestDef || 'skip' in requestDef) {\n    // have to do the limit in-memory\n    var skip = requestDef.skip || 0;\n    var limit = ('limit' in requestDef ? requestDef.limit : rows.length) + skip;\n    rows = rows.slice(skip, limit);\n  }\n  return rows;\n}\nfunction rowFilter(doc, selector, inMemoryFields) {\n  return inMemoryFields.every(function (field) {\n    var matcher = selector[field];\n    var parsedField = parseField(field);\n    var docFieldValue = getFieldFromDoc(doc, parsedField);\n    if (isCombinationalField(field)) {\n      return matchCominationalSelector(field, matcher, doc);\n    }\n    return matchSelector(matcher, doc, parsedField, docFieldValue);\n  });\n}\nfunction matchSelector(matcher, doc, parsedField, docFieldValue) {\n  if (!matcher) {\n    // no filtering necessary; this field is just needed for sorting\n    return true;\n  }\n\n  // is matcher an object, if so continue recursion\n  if (typeof matcher === 'object') {\n    return Object.keys(matcher).every(function (maybeUserOperator) {\n      var userValue = matcher[maybeUserOperator];\n      // explicit operator\n      if (maybeUserOperator.indexOf(\"$\") === 0) {\n        return match(maybeUserOperator, doc, userValue, parsedField, docFieldValue);\n      } else {\n        var subParsedField = parseField(maybeUserOperator);\n        if (docFieldValue === undefined && typeof userValue !== \"object\" && subParsedField.length > 0) {\n          // the field does not exist, return or getFieldFromDoc will throw\n          return false;\n        }\n        var subDocFieldValue = getFieldFromDoc(docFieldValue, subParsedField);\n        if (typeof userValue === \"object\") {\n          // field value is an object that might contain more operators\n          return matchSelector(userValue, doc, parsedField, subDocFieldValue);\n        }\n\n        // implicit operator\n        return match(\"$eq\", doc, userValue, subParsedField, subDocFieldValue);\n      }\n    });\n  }\n\n  // no more depth, No need to recurse further\n  return matcher === docFieldValue;\n}\nfunction matchCominationalSelector(field, matcher, doc) {\n  if (field === '$or') {\n    return matcher.some(function (orMatchers) {\n      return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n    });\n  }\n  if (field === '$not') {\n    return !rowFilter(doc, matcher, Object.keys(matcher));\n  }\n\n  //`$nor`\n  return !matcher.find(function (orMatchers) {\n    return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n  });\n}\nfunction match(userOperator, doc, userValue, parsedField, docFieldValue) {\n  if (!matchers[userOperator]) {\n    /* istanbul ignore next */\n    throw new Error('unknown operator \"' + userOperator + '\" - should be one of $eq, $lte, $lt, $gt, $gte, $exists, $ne, $in, ' + '$nin, $size, $mod, $regex, $elemMatch, $type, $allMatch or $all');\n  }\n  return matchers[userOperator](doc, userValue, parsedField, docFieldValue);\n}\nfunction fieldExists(docFieldValue) {\n  return typeof docFieldValue !== 'undefined' && docFieldValue !== null;\n}\nfunction fieldIsNotUndefined(docFieldValue) {\n  return typeof docFieldValue !== 'undefined';\n}\nfunction modField(docFieldValue, userValue) {\n  if (typeof docFieldValue !== \"number\" || parseInt(docFieldValue, 10) !== docFieldValue) {\n    return false;\n  }\n  var divisor = userValue[0];\n  var mod = userValue[1];\n  return docFieldValue % divisor === mod;\n}\nfunction arrayContainsValue(docFieldValue, userValue) {\n  return userValue.some(function (val) {\n    if (docFieldValue instanceof Array) {\n      return docFieldValue.some(function (docFieldValueItem) {\n        return collate(val, docFieldValueItem) === 0;\n      });\n    }\n    return collate(val, docFieldValue) === 0;\n  });\n}\nfunction arrayContainsAllValues(docFieldValue, userValue) {\n  return userValue.every(function (val) {\n    return docFieldValue.some(function (docFieldValueItem) {\n      return collate(val, docFieldValueItem) === 0;\n    });\n  });\n}\nfunction arraySize(docFieldValue, userValue) {\n  return docFieldValue.length === userValue;\n}\nfunction regexMatch(docFieldValue, userValue) {\n  var re = new RegExp(userValue);\n  return re.test(docFieldValue);\n}\nfunction typeMatch(docFieldValue, userValue) {\n  switch (userValue) {\n    case 'null':\n      return docFieldValue === null;\n    case 'boolean':\n      return typeof docFieldValue === 'boolean';\n    case 'number':\n      return typeof docFieldValue === 'number';\n    case 'string':\n      return typeof docFieldValue === 'string';\n    case 'array':\n      return docFieldValue instanceof Array;\n    case 'object':\n      return {}.toString.call(docFieldValue) === '[object Object]';\n  }\n}\nvar matchers = {\n  '$elemMatch': function (doc, userValue, parsedField, docFieldValue) {\n    if (!Array.isArray(docFieldValue)) {\n      return false;\n    }\n    if (docFieldValue.length === 0) {\n      return false;\n    }\n    if (typeof docFieldValue[0] === 'object' && docFieldValue[0] !== null) {\n      return docFieldValue.some(function (val) {\n        return rowFilter(val, userValue, Object.keys(userValue));\n      });\n    }\n    return docFieldValue.some(function (val) {\n      return matchSelector(userValue, doc, parsedField, val);\n    });\n  },\n  '$allMatch': function (doc, userValue, parsedField, docFieldValue) {\n    if (!Array.isArray(docFieldValue)) {\n      return false;\n    }\n\n    /* istanbul ignore next */\n    if (docFieldValue.length === 0) {\n      return false;\n    }\n    if (typeof docFieldValue[0] === 'object' && docFieldValue[0] !== null) {\n      return docFieldValue.every(function (val) {\n        return rowFilter(val, userValue, Object.keys(userValue));\n      });\n    }\n    return docFieldValue.every(function (val) {\n      return matchSelector(userValue, doc, parsedField, val);\n    });\n  },\n  '$eq': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) === 0;\n  },\n  '$gte': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) >= 0;\n  },\n  '$gt': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) > 0;\n  },\n  '$lte': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) <= 0;\n  },\n  '$lt': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) < 0;\n  },\n  '$exists': function (doc, userValue, parsedField, docFieldValue) {\n    //a field that is null is still considered to exist\n    if (userValue) {\n      return fieldIsNotUndefined(docFieldValue);\n    }\n    return !fieldIsNotUndefined(docFieldValue);\n  },\n  '$mod': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && modField(docFieldValue, userValue);\n  },\n  '$ne': function (doc, userValue, parsedField, docFieldValue) {\n    return userValue.every(function (neValue) {\n      return collate(docFieldValue, neValue) !== 0;\n    });\n  },\n  '$in': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && arrayContainsValue(docFieldValue, userValue);\n  },\n  '$nin': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && !arrayContainsValue(docFieldValue, userValue);\n  },\n  '$size': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && Array.isArray(docFieldValue) && arraySize(docFieldValue, userValue);\n  },\n  '$all': function (doc, userValue, parsedField, docFieldValue) {\n    return Array.isArray(docFieldValue) && arrayContainsAllValues(docFieldValue, userValue);\n  },\n  '$regex': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && typeof docFieldValue == \"string\" && userValue.every(function (regexValue) {\n      return regexMatch(docFieldValue, regexValue);\n    });\n  },\n  '$type': function (doc, userValue, parsedField, docFieldValue) {\n    return typeMatch(docFieldValue, userValue);\n  }\n};\n\n// return true if the given doc matches the supplied selector\nfunction matchesSelector(doc, selector) {\n  /* istanbul ignore if */\n  if (typeof selector !== 'object') {\n    // match the CouchDB error message\n    throw new Error('Selector error: expected a JSON object');\n  }\n  selector = massageSelector(selector);\n  var row = {\n    'doc': doc\n  };\n  var rowsMatched = filterInMemoryFields([row], {\n    'selector': selector\n  }, Object.keys(selector));\n  return rowsMatched && rowsMatched.length === 1;\n}\nexport { massageSelector, matchesSelector, filterInMemoryFields, createFieldSorter, rowFilter, isCombinationalField, getKey, getValue, getFieldFromDoc, setFieldInDoc, compare, parseField };","map":{"version":3,"names":["clone","collate","getFieldFromDoc","doc","parsedField","value","i","len","length","key","setFieldInDoc","elem","compare","left","right","parseField","fieldName","fields","current","ch","substring","push","combinationFields","isCombinationalField","field","indexOf","getKey","obj","Object","keys","getValue","mergeAndedSelectors","selectors","res","first","$or","$nor","forEach","selector","matcher","$eq","Array","entries","existing","m","longest","Math","max","merged","fieldMatchers","operator","mergeGtGte","mergeLtLte","mergeNe","mergeEq","mergeRegex","$gte","$gt","$lte","$lt","$ne","$regex","mergeAndedSelectorsNested","prop","isArray","isAndInSelector","isAnd","massageSelector","input","result","wasAnded","orOrNor","subSelector","createFieldSorter","sort","getFieldValuesAsArray","map","sorting","docFieldValue","aRow","bRow","aFieldValues","bFieldValues","collation","_id","filterInMemoryFields","rows","requestDef","inMemoryFields","filter","row","rowFilter","fieldSorter","reverse","skip","limit","slice","every","matchCominationalSelector","matchSelector","maybeUserOperator","userValue","match","subParsedField","undefined","subDocFieldValue","some","orMatchers","find","userOperator","matchers","Error","fieldExists","fieldIsNotUndefined","modField","parseInt","divisor","mod","arrayContainsValue","val","docFieldValueItem","arrayContainsAllValues","arraySize","regexMatch","re","RegExp","test","typeMatch","toString","call","neValue","regexValue","matchesSelector","rowsMatched"],"sources":["/home/sol/Documentos/AUS/3ro segundo cuatri/ing 2/URV/node_modules/pouchdb-selector-core/lib/index.es.js"],"sourcesContent":["import { clone } from 'pouchdb-utils';\nimport { collate } from 'pouchdb-collate';\n\n// this would just be \"return doc[field]\", but fields\n// can be \"deep\" due to dot notation\nfunction getFieldFromDoc(doc, parsedField) {\n  var value = doc;\n  for (var i = 0, len = parsedField.length; i < len; i++) {\n    var key = parsedField[i];\n    value = value[key];\n    if (!value) {\n      break;\n    }\n  }\n  return value;\n}\n\nfunction setFieldInDoc(doc, parsedField, value) {\n  for (var i = 0, len = parsedField.length; i < len-1; i++) {\n    var elem = parsedField[i];\n    doc = doc[elem] = doc[elem] || {};\n  }\n  doc[parsedField[len-1]] = value;\n}\n\nfunction compare(left, right) {\n  return left < right ? -1 : left > right ? 1 : 0;\n}\n\n// Converts a string in dot notation to an array of its components, with backslash escaping\nfunction parseField(fieldName) {\n  // fields may be deep (e.g. \"foo.bar.baz\"), so parse\n  var fields = [];\n  var current = '';\n  for (var i = 0, len = fieldName.length; i < len; i++) {\n    var ch = fieldName[i];\n    if (i > 0 && fieldName[i - 1] === '\\\\' && (ch === '$' || ch === '.')) {\n      // escaped delimiter\n      current = current.substring(0, current.length - 1) + ch;\n    } else if (ch === '.') {\n      // When `.` is not escaped (above), it is a field delimiter\n      fields.push(current);\n      current = '';\n    } else { // normal character\n      current += ch;\n    }\n  }\n  fields.push(current);\n  return fields;\n}\n\nvar combinationFields = ['$or', '$nor', '$not'];\nfunction isCombinationalField(field) {\n  return combinationFields.indexOf(field) > -1;\n}\n\nfunction getKey(obj) {\n  return Object.keys(obj)[0];\n}\n\nfunction getValue(obj) {\n  return obj[getKey(obj)];\n}\n\n\n// flatten an array of selectors joined by an $and operator\nfunction mergeAndedSelectors(selectors) {\n\n  // sort to ensure that e.g. if the user specified\n  // $and: [{$gt: 'a'}, {$gt: 'b'}], then it's collapsed into\n  // just {$gt: 'b'}\n  var res = {};\n  var first = {$or: true, $nor: true};\n\n  selectors.forEach(function (selector) {\n    Object.keys(selector).forEach(function (field) {\n      var matcher = selector[field];\n      if (typeof matcher !== 'object') {\n        matcher = {$eq: matcher};\n      }\n\n      if (isCombinationalField(field)) {\n        // or, nor\n        if (matcher instanceof Array) {\n          if (first[field]) {\n            first[field] = false;\n            res[field] = matcher;\n            return;\n          }\n\n          var entries = [];\n          res[field].forEach(function (existing) {\n            Object.keys(matcher).forEach(function (key) {\n              var m = matcher[key];\n              var longest = Math.max(Object.keys(existing).length, Object.keys(m).length);\n              var merged = mergeAndedSelectors([existing, m]);\n              if (Object.keys(merged).length <= longest) {\n                // we have a situation like: (a :{$eq :1} || ...) && (a {$eq: 2} || ...)\n                // merging would produce a $eq 2 when actually we shouldn't ever match against these merged conditions\n                // merged should always contain more values to be valid\n                return;\n              }\n              entries.push(merged);\n            });\n          });\n          res[field] = entries;\n        } else {\n          // not\n          res[field] = mergeAndedSelectors([matcher]);\n        }\n      } else {\n        var fieldMatchers = res[field] = res[field] || {};\n        Object.keys(matcher).forEach(function (operator) {\n          var value = matcher[operator];\n\n          if (operator === '$gt' || operator === '$gte') {\n            return mergeGtGte(operator, value, fieldMatchers);\n          } else if (operator === '$lt' || operator === '$lte') {\n            return mergeLtLte(operator, value, fieldMatchers);\n          } else if (operator === '$ne') {\n            return mergeNe(value, fieldMatchers);\n          } else if (operator === '$eq') {\n            return mergeEq(value, fieldMatchers);\n          } else if (operator === \"$regex\") {\n            return mergeRegex(value, fieldMatchers);\n          }\n          fieldMatchers[operator] = value;\n        });\n      }\n    });\n  });\n\n  return res;\n}\n\n\n\n// collapse logically equivalent gt/gte values\nfunction mergeGtGte(operator, value, fieldMatchers) {\n  if (typeof fieldMatchers.$eq !== 'undefined') {\n    return; // do nothing\n  }\n  if (typeof fieldMatchers.$gte !== 'undefined') {\n    if (operator === '$gte') {\n      if (value > fieldMatchers.$gte) { // more specificity\n        fieldMatchers.$gte = value;\n      }\n    } else { // operator === '$gt'\n      if (value >= fieldMatchers.$gte) { // more specificity\n        delete fieldMatchers.$gte;\n        fieldMatchers.$gt = value;\n      }\n    }\n  } else if (typeof fieldMatchers.$gt !== 'undefined') {\n    if (operator === '$gte') {\n      if (value > fieldMatchers.$gt) { // more specificity\n        delete fieldMatchers.$gt;\n        fieldMatchers.$gte = value;\n      }\n    } else { // operator === '$gt'\n      if (value > fieldMatchers.$gt) { // more specificity\n        fieldMatchers.$gt = value;\n      }\n    }\n  } else {\n    fieldMatchers[operator] = value;\n  }\n}\n\n// collapse logically equivalent lt/lte values\nfunction mergeLtLte(operator, value, fieldMatchers) {\n  if (typeof fieldMatchers.$eq !== 'undefined') {\n    return; // do nothing\n  }\n  if (typeof fieldMatchers.$lte !== 'undefined') {\n    if (operator === '$lte') {\n      if (value < fieldMatchers.$lte) { // more specificity\n        fieldMatchers.$lte = value;\n      }\n    } else { // operator === '$gt'\n      if (value <= fieldMatchers.$lte) { // more specificity\n        delete fieldMatchers.$lte;\n        fieldMatchers.$lt = value;\n      }\n    }\n  } else if (typeof fieldMatchers.$lt !== 'undefined') {\n    if (operator === '$lte') {\n      if (value < fieldMatchers.$lt) { // more specificity\n        delete fieldMatchers.$lt;\n        fieldMatchers.$lte = value;\n      }\n    } else { // operator === '$gt'\n      if (value < fieldMatchers.$lt) { // more specificity\n        fieldMatchers.$lt = value;\n      }\n    }\n  } else {\n    fieldMatchers[operator] = value;\n  }\n}\n\n// combine $ne values into one array\nfunction mergeNe(value, fieldMatchers) {\n  if ('$ne' in fieldMatchers) {\n    // there are many things this could \"not\" be\n    fieldMatchers.$ne.push(value);\n  } else { // doesn't exist yet\n    fieldMatchers.$ne = [value];\n  }\n}\n\n// add $eq into the mix\nfunction mergeEq(value, fieldMatchers) {\n  // these all have less specificity than the $eq\n  // TODO: check for user errors here\n  delete fieldMatchers.$gt;\n  delete fieldMatchers.$gte;\n  delete fieldMatchers.$lt;\n  delete fieldMatchers.$lte;\n  delete fieldMatchers.$ne;\n  fieldMatchers.$eq = value;\n}\n\n// combine $regex values into one array\nfunction mergeRegex(value, fieldMatchers) {\n  if ('$regex' in fieldMatchers) {\n    // a value could match multiple regexes\n    fieldMatchers.$regex.push(value);\n  } else { // doesn't exist yet\n    fieldMatchers.$regex = [value];\n  }\n}\n\n//#7458: execute function mergeAndedSelectors on nested $and\nfunction mergeAndedSelectorsNested(obj) {\n    for (var prop in obj) {\n        if (Array.isArray(obj)) {\n            for (var i in obj) {\n                if (obj[i]['$and']) {\n                    obj[i] = mergeAndedSelectors(obj[i]['$and']);\n                }\n            }\n        }\n        var value = obj[prop];\n        if (typeof value === 'object') {\n            mergeAndedSelectorsNested(value); // <- recursive call\n        }\n    }\n    return obj;\n}\n\n//#7458: determine id $and is present in selector (at any level)\nfunction isAndInSelector(obj, isAnd) {\n    for (var prop in obj) {\n        if (prop === '$and') {\n            isAnd = true;\n        }\n        var value = obj[prop];\n        if (typeof value === 'object') {\n            isAnd = isAndInSelector(value, isAnd); // <- recursive call\n        }\n    }\n    return isAnd;\n}\n\n//\n// normalize the selector\n//\nfunction massageSelector(input) {\n  var result = clone(input);\n  var wasAnded = false;\n    //#7458: if $and is present in selector (at any level) merge nested $and\n    if (isAndInSelector(result, false)) {\n        result = mergeAndedSelectorsNested(result);\n        if ('$and' in result) {\n            result = mergeAndedSelectors(result['$and']);\n        }\n        wasAnded = true;\n    }\n\n  ['$or', '$nor'].forEach(function (orOrNor) {\n    if (orOrNor in result) {\n      // message each individual selector\n      // e.g. {foo: 'bar'} becomes {foo: {$eq: 'bar'}}\n      result[orOrNor].forEach(function (subSelector) {\n        var fields = Object.keys(subSelector);\n        for (var i = 0; i < fields.length; i++) {\n          var field = fields[i];\n          var matcher = subSelector[field];\n          if (typeof matcher !== 'object' || matcher === null) {\n            subSelector[field] = {$eq: matcher};\n          }\n        }\n      });\n    }\n  });\n\n  if ('$not' in result) {\n    //This feels a little like forcing, but it will work for now,\n    //I would like to come back to this and make the merging of selectors a little more generic\n    result['$not'] = mergeAndedSelectors([result['$not']]);\n  }\n\n  var fields = Object.keys(result);\n\n  for (var i = 0; i < fields.length; i++) {\n    var field = fields[i];\n    var matcher = result[field];\n\n    if (typeof matcher !== 'object' || matcher === null) {\n      matcher = {$eq: matcher};\n    } else if (!wasAnded) {\n      // These values must be placed in an array because these operators can be used multiple times on the same field\n      // when $and is used, mergeAndedSelectors takes care of putting them into arrays, otherwise it's done here:\n      if ('$ne' in matcher) {\n        matcher.$ne = [matcher.$ne];\n      }\n      if ('$regex' in matcher) {\n        matcher.$regex = [matcher.$regex];\n      }\n    }\n    result[field] = matcher;\n  }\n\n  return result;\n}\n\n// create a comparator based on the sort object\nfunction createFieldSorter(sort) {\n\n  function getFieldValuesAsArray(doc) {\n    return sort.map(function (sorting) {\n      var fieldName = getKey(sorting);\n      var parsedField = parseField(fieldName);\n      var docFieldValue = getFieldFromDoc(doc, parsedField);\n      return docFieldValue;\n    });\n  }\n\n  return function (aRow, bRow) {\n    var aFieldValues = getFieldValuesAsArray(aRow.doc);\n    var bFieldValues = getFieldValuesAsArray(bRow.doc);\n    var collation = collate(aFieldValues, bFieldValues);\n    if (collation !== 0) {\n      return collation;\n    }\n    // this is what mango seems to do\n    return compare(aRow.doc._id, bRow.doc._id);\n  };\n}\n\nfunction filterInMemoryFields(rows, requestDef, inMemoryFields) {\n  rows = rows.filter(function (row) {\n    return rowFilter(row.doc, requestDef.selector, inMemoryFields);\n  });\n\n  if (requestDef.sort) {\n    // in-memory sort\n    var fieldSorter = createFieldSorter(requestDef.sort);\n    rows = rows.sort(fieldSorter);\n    if (typeof requestDef.sort[0] !== 'string' &&\n        getValue(requestDef.sort[0]) === 'desc') {\n      rows = rows.reverse();\n    }\n  }\n\n  if ('limit' in requestDef || 'skip' in requestDef) {\n    // have to do the limit in-memory\n    var skip = requestDef.skip || 0;\n    var limit = ('limit' in requestDef ? requestDef.limit : rows.length) + skip;\n    rows = rows.slice(skip, limit);\n  }\n  return rows;\n}\n\nfunction rowFilter(doc, selector, inMemoryFields) {\n  return inMemoryFields.every(function (field) {\n    var matcher = selector[field];\n    var parsedField = parseField(field);\n    var docFieldValue = getFieldFromDoc(doc, parsedField);\n    if (isCombinationalField(field)) {\n      return matchCominationalSelector(field, matcher, doc);\n    }\n\n    return matchSelector(matcher, doc, parsedField, docFieldValue);\n  });\n}\n\nfunction matchSelector(matcher, doc, parsedField, docFieldValue) {\n  if (!matcher) {\n    // no filtering necessary; this field is just needed for sorting\n    return true;\n  }\n\n  // is matcher an object, if so continue recursion\n  if (typeof matcher === 'object') {\n    return Object.keys(matcher).every(function (maybeUserOperator) {\n      var userValue = matcher[ maybeUserOperator ];\n      // explicit operator\n      if (maybeUserOperator.indexOf(\"$\") === 0) {\n        return match(maybeUserOperator, doc, userValue, parsedField, docFieldValue);\n      } else {\n        var subParsedField = parseField(maybeUserOperator);\n\n        if (\n          docFieldValue === undefined &&\n          typeof userValue !== \"object\" &&\n          subParsedField.length > 0\n        ) {\n          // the field does not exist, return or getFieldFromDoc will throw\n          return false;\n        }\n\n        var subDocFieldValue = getFieldFromDoc(docFieldValue, subParsedField);\n\n        if (typeof userValue === \"object\") {\n          // field value is an object that might contain more operators\n          return matchSelector(userValue, doc, parsedField, subDocFieldValue);\n        }\n\n        // implicit operator\n        return match(\"$eq\", doc, userValue, subParsedField, subDocFieldValue);\n      }\n    });\n  }\n\n  // no more depth, No need to recurse further\n  return matcher === docFieldValue;\n}\n\nfunction matchCominationalSelector(field, matcher, doc) {\n\n  if (field === '$or') {\n    return matcher.some(function (orMatchers) {\n      return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n    });\n  }\n\n  if (field === '$not') {\n    return !rowFilter(doc, matcher, Object.keys(matcher));\n  }\n\n  //`$nor`\n  return !matcher.find(function (orMatchers) {\n    return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n  });\n\n}\n\nfunction match(userOperator, doc, userValue, parsedField, docFieldValue) {\n  if (!matchers[userOperator]) {\n    /* istanbul ignore next */\n    throw new Error('unknown operator \"' + userOperator +\n      '\" - should be one of $eq, $lte, $lt, $gt, $gte, $exists, $ne, $in, ' +\n      '$nin, $size, $mod, $regex, $elemMatch, $type, $allMatch or $all');\n  }\n  return matchers[userOperator](doc, userValue, parsedField, docFieldValue);\n}\n\nfunction fieldExists(docFieldValue) {\n  return typeof docFieldValue !== 'undefined' && docFieldValue !== null;\n}\n\nfunction fieldIsNotUndefined(docFieldValue) {\n  return typeof docFieldValue !== 'undefined';\n}\n\nfunction modField(docFieldValue, userValue) {\n  if (typeof docFieldValue !== \"number\" ||\n    parseInt(docFieldValue, 10) !== docFieldValue) {\n    return false;\n  }\n\n  var divisor = userValue[0];\n  var mod = userValue[1];\n\n  return docFieldValue % divisor === mod;\n}\n\nfunction arrayContainsValue(docFieldValue, userValue) {\n  return userValue.some(function (val) {\n    if (docFieldValue instanceof Array) {\n      return docFieldValue.some(function (docFieldValueItem) {\n        return collate(val, docFieldValueItem) === 0;\n      });\n    }\n\n    return collate(val, docFieldValue) === 0;\n  });\n}\n\nfunction arrayContainsAllValues(docFieldValue, userValue) {\n  return userValue.every(function (val) {\n    return docFieldValue.some(function (docFieldValueItem) {\n      return collate(val, docFieldValueItem) === 0;\n    });\n  });\n}\n\nfunction arraySize(docFieldValue, userValue) {\n  return docFieldValue.length === userValue;\n}\n\nfunction regexMatch(docFieldValue, userValue) {\n  var re = new RegExp(userValue);\n\n  return re.test(docFieldValue);\n}\n\nfunction typeMatch(docFieldValue, userValue) {\n\n  switch (userValue) {\n    case 'null':\n      return docFieldValue === null;\n    case 'boolean':\n      return typeof (docFieldValue) === 'boolean';\n    case 'number':\n      return typeof (docFieldValue) === 'number';\n    case 'string':\n      return typeof (docFieldValue) === 'string';\n    case 'array':\n      return docFieldValue instanceof Array;\n    case 'object':\n      return ({}).toString.call(docFieldValue) === '[object Object]';\n  }\n}\n\nvar matchers = {\n\n  '$elemMatch': function (doc, userValue, parsedField, docFieldValue) {\n    if (!Array.isArray(docFieldValue)) {\n      return false;\n    }\n\n    if (docFieldValue.length === 0) {\n      return false;\n    }\n\n    if (typeof docFieldValue[0] === 'object' &&  docFieldValue[0] !== null) {\n      return docFieldValue.some(function (val) {\n        return rowFilter(val, userValue, Object.keys(userValue));\n      });\n    }\n\n    return docFieldValue.some(function (val) {\n      return matchSelector(userValue, doc, parsedField, val);\n    });\n  },\n\n  '$allMatch': function (doc, userValue, parsedField, docFieldValue) {\n    if (!Array.isArray(docFieldValue)) {\n      return false;\n    }\n\n    /* istanbul ignore next */\n    if (docFieldValue.length === 0) {\n      return false;\n    }\n\n    if (typeof docFieldValue[0] === 'object' &&  docFieldValue[0] !== null) {\n      return docFieldValue.every(function (val) {\n        return rowFilter(val, userValue, Object.keys(userValue));\n      });\n    }\n\n    return docFieldValue.every(function (val) {\n      return matchSelector(userValue, doc, parsedField, val);\n    });\n  },\n\n  '$eq': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) === 0;\n  },\n\n  '$gte': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) >= 0;\n  },\n\n  '$gt': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) > 0;\n  },\n\n  '$lte': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) <= 0;\n  },\n\n  '$lt': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) < 0;\n  },\n\n  '$exists': function (doc, userValue, parsedField, docFieldValue) {\n    //a field that is null is still considered to exist\n    if (userValue) {\n      return fieldIsNotUndefined(docFieldValue);\n    }\n\n    return !fieldIsNotUndefined(docFieldValue);\n  },\n\n  '$mod': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && modField(docFieldValue, userValue);\n  },\n\n  '$ne': function (doc, userValue, parsedField, docFieldValue) {\n    return userValue.every(function (neValue) {\n      return collate(docFieldValue, neValue) !== 0;\n    });\n  },\n  '$in': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && arrayContainsValue(docFieldValue, userValue);\n  },\n\n  '$nin': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && !arrayContainsValue(docFieldValue, userValue);\n  },\n\n  '$size': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) &&\n      Array.isArray(docFieldValue) &&\n      arraySize(docFieldValue, userValue);\n  },\n\n  '$all': function (doc, userValue, parsedField, docFieldValue) {\n    return Array.isArray(docFieldValue) && arrayContainsAllValues(docFieldValue, userValue);\n  },\n\n  '$regex': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) &&\n      typeof docFieldValue == \"string\" &&\n      userValue.every(function (regexValue) {\n        return regexMatch(docFieldValue, regexValue);\n      });\n  },\n\n  '$type': function (doc, userValue, parsedField, docFieldValue) {\n    return typeMatch(docFieldValue, userValue);\n  }\n};\n\n// return true if the given doc matches the supplied selector\nfunction matchesSelector(doc, selector) {\n  /* istanbul ignore if */\n  if (typeof selector !== 'object') {\n    // match the CouchDB error message\n    throw new Error('Selector error: expected a JSON object');\n  }\n\n  selector = massageSelector(selector);\n  var row = {\n    'doc': doc\n  };\n\n  var rowsMatched = filterInMemoryFields([row], { 'selector': selector }, Object.keys(selector));\n  return rowsMatched && rowsMatched.length === 1;\n}\n\nexport { massageSelector, matchesSelector, filterInMemoryFields, createFieldSorter, rowFilter, isCombinationalField, getKey, getValue, getFieldFromDoc, setFieldInDoc, compare, parseField };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}