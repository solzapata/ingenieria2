"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = require("react");
const pouchdb_selector_core_1 = require("pouchdb-selector-core");
const context_1 = require("./context");
const state_machine_1 = __importDefault(require("./state-machine"));
const utils_1 = require("./utils");
/**
 * Query, and optionally create, a Mango index and subscribe to its updates.
 * @param {object} [opts] A combination of PouchDB's find options and create index options.
 */
function useFind(options) {
    const { pouchdb: pouch, subscriptionManager } = (0, context_1.useContext)(options.db);
    if (typeof (pouch === null || pouch === void 0 ? void 0 : pouch.createIndex) !== 'function' ||
        typeof (pouch === null || pouch === void 0 ? void 0 : pouch.find) !== 'function') {
        throw new TypeError('db.createIndex() or/and db.find() are not defined. Please install "pouchdb-find"');
    }
    const index = (0, utils_1.useDeepMemo)(options.index);
    const selector = (0, utils_1.useDeepMemo)(options.selector);
    const fields = (0, utils_1.useDeepMemo)(options.fields);
    const sort = (0, utils_1.useDeepMemo)(options.sort);
    const limit = options.limit;
    const skip = options.skip;
    const [state, dispatch] = (0, state_machine_1.default)(() => ({
        docs: [],
    }));
    (0, react_1.useEffect)(() => {
        let isActive = true;
        let isFetching = false;
        let shouldUpdateAfter = false;
        // if _id isn't in the fields array it will be added internally
        const didAddIdToFields = Array.isArray(fields) && fields.length > 0 && !fields.includes('_id');
        // internal fields-array. Ensure to always fetch _id
        const fieldsToFetch = didAddIdToFields ? fields === null || fields === void 0 ? void 0 : fields.concat(['_id']) : fields;
        // Container for the ids in the result. It is in a object to be used as a ref.
        const idsInResult = {
            ids: new Set(),
        };
        let name = undefined;
        let ddoc = undefined;
        // Query a mango query and update the state.
        const query = async () => {
            if (isFetching) {
                shouldUpdateAfter = true;
                return;
            }
            isFetching = true;
            dispatch({ type: 'loading_started' });
            try {
                let indexToUse = undefined;
                if (ddoc && name) {
                    indexToUse = [ddoc, name];
                }
                else if (ddoc) {
                    indexToUse = ddoc;
                }
                const result = (await pouch.find({
                    selector,
                    fields: fieldsToFetch,
                    sort,
                    limit,
                    skip,
                    use_index: indexToUse,
                }));
                if (isActive) {
                    idsInResult.ids = new Set();
                    for (const doc of result.docs) {
                        idsInResult.ids.add(doc._id);
                        // if _id was added to the fields array, remove it,
                        // so that the user only gets what they want.
                        if (didAddIdToFields) {
                            const removeDoc = doc;
                            delete removeDoc._id;
                        }
                    }
                    dispatch({ type: 'loading_finished', payload: result });
                }
            }
            catch (error) {
                if (isActive) {
                    dispatch({
                        type: 'loading_error',
                        payload: { error: error, setResult: false },
                    });
                }
            }
            finally {
                isFetching = false;
                // Re-query if a change did happen while querying
                if (isActive && shouldUpdateAfter) {
                    shouldUpdateAfter = false;
                    query();
                }
            }
        };
        let unsubscribe = undefined;
        dispatch({ type: 'loading_started' });
        // Create an index or get the index that will be used.
        getIndex(pouch, index, { selector })
            .then(([ddocId, indexName]) => {
            if (!isActive)
                return;
            if (ddocId) {
                ddoc = ddocId;
            }
            name = indexName;
            query();
            unsubscribe = subscribe(subscriptionManager, selector, query, ddocId, idsInResult);
        })
            .catch(error => {
            if (isActive) {
                dispatch({
                    type: 'loading_error',
                    payload: { error, setResult: false },
                });
                query();
                unsubscribe = subscribe(subscriptionManager, selector, query, null, idsInResult);
            }
        });
        return () => {
            isActive = false;
            unsubscribe === null || unsubscribe === void 0 ? void 0 : unsubscribe();
        };
    }, [
        pouch,
        subscriptionManager,
        dispatch,
        index,
        selector,
        fields,
        sort,
        limit,
        skip,
    ]);
    return state;
}
exports.default = useFind;
/**
 * Get the ddoc & name of an index. Create it if the index doesn't exist.
 * @param db        - The PouchDB database.
 * @param index     - Name or Create Index options.
 * @param selector  - The selector used.
 */
function getIndex(db, index, selector) {
    if (index && typeof index === 'string') {
        return findIndex(db, selector);
    }
    else if (index && Array.isArray(index)) {
        return Promise.resolve(index);
    }
    else if (index && typeof index === 'object') {
        return createIndex(db, { index });
    }
    else {
        return findIndex(db, selector);
    }
}
/**
 * Create an index. Returns the ddoc & name.
 * @param db - The PouchDB database.
 * @param index - Options for db.createIndex
 */
async function createIndex(db, index) {
    const result = (await db.createIndex(index));
    return [result.id, result.name];
}
/**
 * Find a index for the given selector. Returns ddoc & name.
 * @param db - The PouchDB database.
 * @param selector - The selector used.
 */
async function findIndex(db, selector) {
    const database = db;
    const result = await database.explain(selector);
    return [result.index.ddoc, result.index.name];
}
/**
 * Subscribes to updates in the database and re-query
 * when a document did change that matches the selector.
 * @param subscriptionManager - The current subscription manager.
 * @param selector - Selector, to filter out changes.
 * @param query - Function to run a query.
 * @param id - Id of the ddoc where the index is stored.
 * @param idsInResult - Object containing a Set of ids in the last result.
 */
function subscribe(subscriptionManager, selector, query, id, idsInResult) {
    const ddocName = id
        ? '_design/' + id.replace(/^_design\//, '') // normalize, user can add a ddoc name
        : undefined;
    return subscriptionManager.subscribeToDocs(null, (_del, id, doc) => {
        if (idsInResult.ids.has(id)) {
            query();
        }
        else if (id === ddocName) {
            query();
        }
        else if (doc && typeof pouchdb_selector_core_1.matchesSelector !== 'function') {
            // because pouchdb-selector-core is semver-free zone
            // If matchesSelector doesn't exist, just query every time
            query();
        }
        else if (doc && (0, pouchdb_selector_core_1.matchesSelector)(doc, selector)) {
            query();
        }
    });
}
