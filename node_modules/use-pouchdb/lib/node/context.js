"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useContext = exports.Provider = void 0;
const react_1 = __importStar(require("react"));
const subscription_1 = __importDefault(require("./subscription"));
const PouchContext = /*#__PURE__*/ (0, react_1.createContext)({
    defaultKey: '',
    databases: {},
});
if (process.env.NODE_ENV !== 'production') {
    PouchContext.displayName = 'UsePouchDBContext';
}
/**
 * Create a context to provide access to PouchDB databases.
 * All hooks of usePouchDB will use this context.
 * @param args React arguments.
 */
function Provider(args) {
    const { pouchdb, name } = args;
    const { databases: dbsArg, default: defaultArg } = args;
    // collection of databases added in this Provider
    let databases;
    // key of the default database
    let defaultKey;
    // normalize the two argument types into one
    if (dbsArg != null && defaultArg != null) {
        databases = dbsArg;
        defaultKey = defaultArg.toString();
    }
    else if (pouchdb != null) {
        defaultKey = (name === null || name === void 0 ? void 0 : name.toString()) || pouchdb.name;
        databases = { [defaultKey]: pouchdb };
    }
    else {
        throw new TypeError('databases argument must be pared with the default argument');
    }
    const contextObjects = useAddSubscriptionManager(databases);
    const parentDatabases = (0, react_1.useContext)(PouchContext).databases;
    // merge the contextObjects into the parent context and set the "default" key
    const context = (0, react_1.useMemo)(() => {
        return {
            defaultKey,
            databases: {
                ...parentDatabases,
                ...contextObjects,
            },
        };
    }, [contextObjects, defaultKey, parentDatabases]);
    return (react_1.default.createElement(PouchContext.Provider, { value: context }, args.children));
}
exports.Provider = Provider;
/**
 * Creates for every database a SubscriptionManager.
 * Memorizes all databases and reuses the SubscriptionManagers of them.
 * Also unsubscribes SubscriptionManager.
 * @param databases HashMap containing PouchDB databases.
 */
function useAddSubscriptionManager(databases) {
    // memory for last DB and SubscriptionManager pairs
    const [lastDatabases, setLastDatabases] = (0, react_1.useState)(databases);
    const [lastContextObject, setLastContextObject] = (0, react_1.useState)(null);
    // This is for re-renders, which happens when setState is called while rendering.
    // https://beta.reactjs.org/apis/usestate#storing-information-from-previous-renders
    if (lastContextObject && databases === lastDatabases)
        return lastContextObject;
    const contextObjects = {};
    const dbToUnsubscribe = new Set(Object.keys(lastContextObject !== null && lastContextObject !== void 0 ? lastContextObject : {}));
    let didAddNewDatabase = false;
    for (const [key, db] of Object.entries(databases)) {
        if (lastContextObject && lastDatabases[key] === db) {
            // DB didn't change
            contextObjects[key] = lastContextObject[key];
            dbToUnsubscribe.delete(key);
        }
        else {
            // It is a new or changed DB
            didAddNewDatabase = true;
            contextObjects[key] = {
                pouchdb: db,
                subscriptionManager: new subscription_1.default(db),
            };
        }
    }
    if (didAddNewDatabase || dbToUnsubscribe.size > 0) {
        setLastDatabases(databases);
        setLastContextObject(contextObjects);
    }
    else if (lastContextObject) {
        return lastContextObject; // nothing did change and not first render: use last
    }
    if (lastContextObject) {
        for (const key of dbToUnsubscribe) {
            lastContextObject[key].subscriptionManager.unsubscribeAll();
        }
    }
    return contextObjects;
}
/**
 * Provides access to the Database & SubscriptionManager pair in the usePouchDB-Context.
 * @param name Name of the Database or its overwritten name. Defaults to "default".
 */
function useContext(name) {
    const { defaultKey, databases } = (0, react_1.useContext)(PouchContext);
    if (defaultKey === '' &&
        databases[defaultKey] == null &&
        Object.keys(databases).length === 0) {
        throw new Error('could not find PouchDB context value; please ensure the component is wrapped in a <Provider>');
    }
    const key = name === '_default' ? defaultKey : name !== null && name !== void 0 ? name : defaultKey;
    if (!(key in databases)) {
        throw new Error(`could not find a PouchDB database with name of "${name}"`);
    }
    return databases[key];
}
exports.useContext = useContext;
