import { useEffect } from 'react';
import { useContext } from './context';
import useStateMachine from './state-machine';
import { useDeepMemo } from './utils';
/**
 * Get all docs or a slice of all docs and subscribe to their updates.
 * @param options PouchDB's allDocs options.
 */
export default function useAllDocs(options) {
    const { pouchdb: pouch, subscriptionManager } = useContext(options === null || options === void 0 ? void 0 : options.db);
    const { include_docs, conflicts, attachments, binary, limit, skip, descending, update_seq, } = options || {};
    const { startkey, endkey, inclusive_end } = options || {};
    const { key } = options || {};
    const keys = useDeepMemo(options === null || options === void 0 ? void 0 : options.keys);
    const [state, dispatch, replace] = useStateMachine(() => ({
        rows: [],
        total_rows: 0,
        offset: 0,
    }));
    useEffect(() => {
        let isMounted = true;
        let isFetching = false;
        let shouldUpdateAfter = false;
        const opt = {
            include_docs,
            conflicts,
            attachments,
            binary,
            limit,
            skip,
            descending,
            update_seq,
            startkey,
            endkey,
            inclusive_end,
            key,
            keys,
        };
        const fetch = async () => {
            if (isFetching) {
                shouldUpdateAfter = true;
                return;
            }
            isFetching = true;
            shouldUpdateAfter = false;
            dispatch({ type: 'loading_started' });
            try {
                const result = await pouch.allDocs(opt);
                if (isMounted) {
                    dispatch({
                        type: 'loading_finished',
                        payload: result,
                    });
                }
            }
            catch (err) {
                if (isMounted) {
                    dispatch({
                        type: 'loading_error',
                        payload: {
                            error: err,
                            setResult: false,
                        },
                    });
                }
            }
            finally {
                // refresh if change did happen while querying
                isFetching = false;
                if (shouldUpdateAfter && isMounted) {
                    fetch();
                }
            }
        };
        fetch();
        let keysToSubscribe = null;
        if (key != null) {
            keysToSubscribe = [key];
        }
        else if (keys != null) {
            keysToSubscribe = keys;
        }
        const unsubscribe = subscriptionManager.subscribeToDocs(keysToSubscribe, (deleted, id) => {
            if (!isMounted ||
                !isInRange(id, startkey, endkey, inclusive_end, descending)) {
                return;
            }
            if (deleted) {
                replace(result => {
                    const rows = result.rows.filter(row => row.id !== id);
                    return Object.assign(Object.assign({}, result), { rows, total_rows: result.total_rows - (result.rows.length - rows.length) });
                });
            }
            else {
                fetch();
            }
        });
        return () => {
            isMounted = false;
            unsubscribe();
        };
    }, [
        dispatch,
        replace,
        pouch,
        subscriptionManager,
        include_docs,
        conflicts,
        attachments,
        binary,
        startkey,
        endkey,
        inclusive_end,
        limit,
        skip,
        descending,
        key,
        keys,
        update_seq,
    ]);
    return state;
}
/**
 * Check if the updated document is inside of the range.
 * @param id Id of the updated document
 * @param startkey Startkey option.
 * @param endkey Endkey option.
 * @param inclusive_end Is the endkey inclusive?
 * @param descending Which direction should the slice go?
 */
function isInRange(id, startkey, endkey, inclusive_end, descending) {
    if (startkey &&
        ((descending && id > startkey) || (!descending && id < startkey))) {
        return false;
    }
    if (endkey == null) {
        return true;
    }
    if (inclusive_end) {
        return descending ? id >= endkey : id <= endkey;
    }
    else {
        return descending ? id > endkey : id < endkey;
    }
}
